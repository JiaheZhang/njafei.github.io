<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>njafei&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/njafei/njafei.github.io/"/>
  <updated>2018-03-22T10:08:00.869Z</updated>
  <id>https://github.com/njafei/njafei.github.io/</id>
  
  <author>
    <name>njafei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS module输出原理</title>
    <link href="https://github.com/njafei/njafei.github.io/2018/03/22/nodeJS-module/"/>
    <id>https://github.com/njafei/njafei.github.io/2018/03/22/nodeJS-module/</id>
    <published>2018-03-22T10:04:20.000Z</published>
    <updated>2018-03-22T10:08:00.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="module输出写法"><a href="#module输出写法" class="headerlink" title="module输出写法"></a>module输出写法</h1><p>为了能够复用一些基本功能，我们通常会将其封装在module中。类似这样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//greet.js</div><div class="line">&apos;use strict&apos;;</div><div class="line"></div><div class="line">var s = &apos;Hello&apos;;</div><div class="line"></div><div class="line">function greet(name) &#123;</div><div class="line">    console.log(s + &apos;, &apos; + name + &apos;!&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">module.exports = greet;</div></pre></td></tr></table></figure>
<p>我们也会看到其他的写法，这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;;</div><div class="line"></div><div class="line">exports.foo = &apos;foo&apos;;</div></pre></td></tr></table></figure>
<p>直接通过exports的属性来输出的，这样看起来其实很迷惑人，比如我第一次就有疑惑：</p>
<ul>
<li>module不是模块的意思吗？ 为什么要使用module.exports的赋值来输出？</li>
<li>为什么有时候是exports来赋值输出</li>
<li>其他的地方，是如何使用我的模块呢？</li>
<li>为什么export有些可以输出多个值呢? 比如： modelu.exports = {foo: foo, tool: tool}</li>
</ul>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>这里其实是module在默默地做了一些事情，它会在代码中植入类似这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var module = &#123;</div><div class="line">	id: &apos;greet&apos;,</div><div class="line">	exports: &#123;&#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports = moduel.exports;</div><div class="line"></div><div class="line">load(module.exports, module);</div></pre></td></tr></table></figure>
<p>这样，我们就知道了为什么<code>exports</code>和<code>module.exports</code>都可以作为模块的输出。</p>
<p>这里还要一个要注意的，之所以可以用<code>exports</code>来输出，是因为它指向了<code>module.exports</code>. 所以当<code>exports</code>的指针被修改的时候，这样用就会出问题了。</p>
<p>如果输出是一个数组，或者函数，则两者是不等价的，看下面的例子：</p>
<p>例子一： 等价的输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;foo: &apos;foo&apos;&#125;;</div><div class="line"></div><div class="line">exports.foo = &apos;foo&apos;;</div></pre></td></tr></table></figure>
<p>例子而： 不等价输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">module.exports = function greet()&#123;console.log(&apos;greet&apos;)&#125;;//这时 module.exports指向greet函数</div><div class="line"></div><div class="line">exports = function greet()&#123;console.log(&apos;greet&apos;)&#125;;//这时，exoprts的指针指向greet函数，而module.exports仍然指向&#123;&#125;</div><div class="line"></div><div class="line"></div><div class="line">这里两种方式不等价，主要是因为原来都指向同一个变量，而如果赋值是数据，函数等，则export会改变指针的值。然后最终输出的还是module.exports， 所以在这里，模块的输出就不可以用export</div></pre></td></tr></table></figure>
<p>廖雪峰的博客说是建议全部使用<code>module.exports</code>，这样可以避免混淆。我的建议是大家最好搞清楚原理，这样使用起来才知其所以然。</p>
<p>ok，总结这篇文章，主要是讲了模块(module)的输出原理，为什么有两种写法，为什么每种写法都可以work，两种写法的区别和使用时机。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434502419592fd80bbb0613a42118ccab9435af408fd000" target="_blank" rel="noopener">廖雪峰 JS教程-模块</a></li>
<li><a href="http://cnodejs.org/topic/5231a630101e574521e45ef8" target="_blank" rel="noopener">exports 和 module.exports 的区别</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;module输出写法&quot;&gt;&lt;a href=&quot;#module输出写法&quot; class=&quot;headerlink&quot; title=&quot;module输出写法&quot;&gt;&lt;/a&gt;module输出写法&lt;/h1&gt;&lt;p&gt;为了能够复用一些基本功能，我们通常会将其封装在module中。类似这样子：&lt;
    
    </summary>
    
      <category term="Node" scheme="https://github.com/njafei/njafei.github.io/categories/Node/"/>
    
    
      <category term="Node" scheme="https://github.com/njafei/njafei.github.io/tags/Node/"/>
    
      <category term="module" scheme="https://github.com/njafei/njafei.github.io/tags/module/"/>
    
  </entry>
  
  <entry>
    <title>JS 静态类型检查 PropTypes</title>
    <link href="https://github.com/njafei/njafei.github.io/2018/03/20/JS-PropTypes/"/>
    <id>https://github.com/njafei/njafei.github.io/2018/03/20/JS-PropTypes/</id>
    <published>2018-03-20T06:17:26.000Z</published>
    <updated>2018-03-20T06:18:10.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>JS</code>作为弱类型语言，有时候也会带来很多麻烦，比如需要的参数是<code>Number</code>，而使用方传了<code>String</code>，虽然我们可以通过参数的检查来return掉，但是这样也带来了很多繁琐的步骤。为了避免类似的问题，<code>JS</code>提供了类型检查工具PropTypes，在<code>React V15.5</code>之前，可以直接使用<code>React.PropTypes</code>助手函数，之后则提供了npm包<code>prop-types</code>。</p>
<p>注意，处于性能原因，<code>propTypes</code>仅会在dev模式中work，如果发现类型和定义的不一致，会通过warning来提示。</p>
<p>以下是官网的例子，基本上够用了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">import PropTypes from &apos;prop-types&apos;;</div><div class="line"></div><div class="line">MyComponent.propTypes = &#123;</div><div class="line">  // 你可以声明一个 prop 是一个特定的 JS 原始类型。 </div><div class="line">  // 默认情况下，这些都是可选的。</div><div class="line">  optionalArray: PropTypes.array,</div><div class="line">  optionalBool: PropTypes.bool,</div><div class="line">  optionalFunc: PropTypes.func,</div><div class="line">  optionalNumber: PropTypes.number,</div><div class="line">  optionalObject: PropTypes.object,</div><div class="line">  optionalString: PropTypes.string,</div><div class="line">  optionalSymbol: PropTypes.symbol,</div><div class="line"></div><div class="line">  // 任何东西都可以被渲染:numbers, strings, elements,或者是包含这些类型的数组(或者是片段)。</div><div class="line">  optionalNode: PropTypes.node,</div><div class="line"></div><div class="line">  // 一个 React 元素。</div><div class="line">  optionalElement: PropTypes.element,</div><div class="line"></div><div class="line">  // 你也可以声明一个 prop 是类的一个实例。 </div><div class="line">  // 使用 JS 的 instanceof 运算符。</div><div class="line">  optionalMessage: PropTypes.instanceOf(Message),</div><div class="line"></div><div class="line">  // 你可以声明 prop 是特定的值，类似于枚举</div><div class="line">  optionalEnum: PropTypes.oneOf([&apos;News&apos;, &apos;Photos&apos;]),</div><div class="line"></div><div class="line">  // 一个对象可以是多种类型其中之一</div><div class="line">  optionalUnion: PropTypes.oneOfType([</div><div class="line">    PropTypes.string,</div><div class="line">    PropTypes.number,</div><div class="line">    PropTypes.instanceOf(Message)</div><div class="line">  ]),</div><div class="line"></div><div class="line">  // 一个某种类型的数组</div><div class="line">  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),</div><div class="line"></div><div class="line">  // 属性值为某种类型的对象</div><div class="line">  optionalObjectOf: PropTypes.objectOf(PropTypes.number),</div><div class="line"></div><div class="line">  // 一个特定形式的对象</div><div class="line">  optionalObjectWithShape: PropTypes.shape(&#123;</div><div class="line">    color: PropTypes.string,</div><div class="line">    fontSize: PropTypes.number</div><div class="line">  &#125;),</div><div class="line"></div><div class="line">  // 你可以使用 `isRequired&apos; 链接上述任何一个，以确保在没有提供 prop 的情况下显示警告。</div><div class="line">  requiredFunc: PropTypes.func.isRequired,</div><div class="line"></div><div class="line">  // 任何数据类型的值</div><div class="line">  requiredAny: PropTypes.any.isRequired,</div><div class="line"></div><div class="line">  // 你也可以声明自定义的验证器。如果验证失败返回 Error 对象。不要使用 `console.warn` 或者 throw ，</div><div class="line">  // 因为这不会在 `oneOfType` 类型的验证器中起作用。</div><div class="line">  customProp: function(props, propName, componentName) &#123;</div><div class="line">    if (!/matchme/.test(props[propName])) &#123;</div><div class="line">      return new Error(</div><div class="line">        &apos;Invalid prop `&apos; + propName + &apos;` supplied to&apos; +</div><div class="line">        &apos; `&apos; + componentName + &apos;`. Validation failed.&apos;</div><div class="line">      );</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  // 也可以声明`arrayOf`和`objectOf`类型的验证器，如果验证失败需要返回Error对象。</div><div class="line">  // 会在数组或者对象的每一个元素上调用验证器。验证器的前两个参数分别是数组或者对象本身，</div><div class="line">  // 以及当前元素的键值。</div><div class="line">  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123;</div><div class="line">    if (!/matchme/.test(propValue[key])) &#123;</div><div class="line">      return new Error(</div><div class="line">        &apos;Invalid prop `&apos; + propFullName + &apos;` supplied to&apos; +</div><div class="line">        &apos; `&apos; + componentName + &apos;`. Validation failed.&apos;</div><div class="line">      );</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="默认值指定"><a href="#默认值指定" class="headerlink" title="默认值指定"></a>默认值指定</h2><p>除了能指定参数的类型，还可以指定参数的默认值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Greeting extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 指定 props 的默认值：</div><div class="line">Greeting.defaultProps = &#123;</div><div class="line">  name: &apos;Stranger&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 渲染为 &quot;Hello, Stranger&quot;:</div><div class="line">ReactDOM.render(</div><div class="line">  &lt;Greeting /&gt;,</div><div class="line">  document.getElementById(&apos;example&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>只有当指定的props为undefined的时候，才会使用默认值，如果参数有，但是不符合类型检查，也会使用该参数，而不是使用默认值。</p>
<p>propTypes 的类型检测是在defaultProps 解析之后发生的，因此也会对默认属性 defaultProps 进行类型检测。</p>
<h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p>整体是这样的流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//step1 check defaultProps</div><div class="line">if (参数为undefined)&#123;</div><div class="line">	if (有默认值)&#123;</div><div class="line">		使用默认参数</div><div class="line">	&#125; else &#123;</div><div class="line">		使用undefined</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//step2 check type</div><div class="line">if (不符合类型检查)&#123;</div><div class="line">		警告（）</div><div class="line">	&#125;</div><div class="line">	使用该参数值</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果需要更强大的拓展，可以使用<code>Flow</code> 或者 <code>TypeScript</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.css88.com/react/docs/typechecking-with-proptypes.html" target="_blank" rel="noopener">使用 PropTypes 进行类型检查
</a></li>
<li><a href="https://www.npmjs.com/package/prop-types" target="_blank" rel="noopener">prop-types </a></li>
<li><a href="https://flow.org/en/docs/types/" target="_blank" rel="noopener">Flow</a></li>
<li><a href="https://www.typescriptlang.org/" target="_blank" rel="noopener">TypeScript</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h2&gt;&lt;p&gt;&lt;code&gt;JS&lt;/code&gt;作为弱类型语言，有时候也会带来很多麻烦，比如需要的参数是&lt;code&gt;Number&lt;/code&gt;
    
    </summary>
    
      <category term="JS" scheme="https://github.com/njafei/njafei.github.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://github.com/njafei/njafei.github.io/tags/JS/"/>
    
      <category term="PropTypes" scheme="https://github.com/njafei/njafei.github.io/tags/PropTypes/"/>
    
  </entry>
  
  <entry>
    <title>JS Event-Loop</title>
    <link href="https://github.com/njafei/njafei.github.io/2018/03/19/JS-EventLoop/"/>
    <id>https://github.com/njafei/njafei.github.io/2018/03/19/JS-EventLoop/</id>
    <published>2018-03-19T09:44:39.000Z</published>
    <updated>2018-03-19T09:51:16.670Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看<code>JavaScript</code>的<code>Generator</code>、<code>Promise</code>等实现异步的方法。对于一直用<code>Objective-C</code>编程的我来说，是有些云里雾里。故查了些资料，了解相关的内容，遂有此文。</p>
<h2 id="为什么JavaScript是单线程的语言"><a href="#为什么JavaScript是单线程的语言" class="headerlink" title="为什么JavaScript是单线程的语言"></a>为什么<code>JavaScript</code>是单线程的语言</h2><p>首先，我们要解释下，<code>JS</code>是单线程的，并不是说<code>JS</code>中只有一个线程，而是在<code>JS</code>引擎中负责解释和执行<code>JS</code>语句的线程只有一个，我们称之为主线程。</p>
<p>在<code>JS</code>中，还是有很多其他线程存在的，比如：处理DOM事件的线程，定时器线程，IO线程等。</p>
<p>为什么<code>JS</code>中只有一个线程呢？ 这里要说下<code>JS</code>诞生的背景，它是浏览器中执行脚本的语言，主要用途是和用户交互，为了提升体验，避免多线程带来的同步等问题，简化整个模型，采用了单线程。（<code>Objective-C</code>也是为了交互而生，但是并没有采用单线程，而是支持多线程，我个人觉得这个更多是设计思想的选择，而<code>JS</code>这样设计确实带来了更简单的模式）</p>
<blockquote>
<p>在HTML5中，提出了Web Worker标准，允许JS创建多个线程,但是规定子线程受主线程控制，且不能操作DOM。</p>
</blockquote>
<h2 id="JS任务管理"><a href="#JS任务管理" class="headerlink" title="JS任务管理"></a><code>JS</code>任务管理</h2><p>我们先看一张图，了解下<code>JS</code>中是如何管理和执行任务的：</p>
<p><img src="https://developer.mozilla.org/files/4617/default.svg" alt=""></p>
<p>这里分为三个区域：</p>
<ul>
<li>执行栈（主线程）</li>
<li>任务队列（其他线程）</li>
<li>堆 （对象）</li>
</ul>
<h3 id="主线程任务执行栈"><a href="#主线程任务执行栈" class="headerlink" title="主线程任务执行栈"></a>主线程任务执行栈</h3><p>  主线程的任务使用栈来实现任务执行和调用，这里用栈是因为栈的结构方便实现函数调用顺序的管理。<br>  这里简单举个例子：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> 	let funcA = (x) =&gt; &#123;</div><div class="line">	return x * 2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let funcB = (x) =&gt; &#123;</div><div class="line">	return x + 2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">console.log(funcB(funcA(2)));</div></pre></td></tr></table></figure>
<p>  栈中执行顺序就是</p>
<ul>
<li>funcA</li>
<li>funcB</li>
<li>console.log</li>
</ul>
<h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>每当遇到需要异步执行的任务（请求网络、IO等），JS不会阻塞等待结果，而是往下面执行，当异步的任务执行了之后，系统发送通知出来，然后等待主线程任务栈执行完毕后，执行这些异步回调。</p>
<p>流程如图,就是所谓的<code>Event Loop</code></p>
<p><img src="http://on0hv7n2x.bkt.clouddn.com/JS%20eventLoop%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt=""></p>
<p>注意，这里即使异步的任务很快执行完毕，也会等到执行栈中的任务执行完毕后，才执行，这里用<code>setTimeout</code>来举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">console.log(1);</div><div class="line">setTimeout(()=&gt;&#123;console.log(2)&#125;,0)</div><div class="line">console.log(3);</div></pre></td></tr></table></figure>
<p>这里虽然延迟是0ms，但是输出依然是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">3</div><div class="line">2</div></pre></td></tr></table></figure>
<p>所以setTimeout等的延迟时间，其实是不准确的，如果主线程一直很忙，是不会执行到的。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>这里堆就是用来管理系统中的对象，大部分的语言应该都是使用堆来管理对象（我知道的），这里就不多解释。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要是介绍了<code>JS</code>为什么采用了单线程的思想，然后介绍了<code>JS</code>中是如何任务管理是如何通过主线程+任务队列的方式来实现，从而实现了<code>Event Loop</code>。</p>
<h2 id="参考内容："><a href="#参考内容：" class="headerlink" title="参考内容："></a>参考内容：</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF" target="_blank" rel="noopener">并发模型与事件循环</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop
</a></li>
<li><a href="https://segmentfault.com/a/1190000004322358" target="_blank" rel="noopener">JavaScript：彻底理解同步、异步和事件循环(Event Loop)</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看&lt;code&gt;JavaScript&lt;/code&gt;的&lt;code&gt;Generator&lt;/code&gt;、&lt;code&gt;Promise&lt;/code&gt;等实现异步的方法。对于一直用&lt;code&gt;Objective-C&lt;/code&gt;编程的我来说，是有些云里雾里。故查了些资料，了解相关的内
    
    </summary>
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6之Map</title>
    <link href="https://github.com/njafei/njafei.github.io/2018/02/28/ES6-Map/"/>
    <id>https://github.com/njafei/njafei.github.io/2018/02/28/ES6-Map/</id>
    <published>2018-02-28T06:09:25.000Z</published>
    <updated>2018-02-28T06:12:15.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>在js中，对象(Object)的本质是键值对，但是它的键只能是字符串，这带来了很多不便。为了解决这个问题，ES6中提供了新的数据结构，Map。 Map和Object最大的区别就是它的key可以是对象。</p>
<p>看下初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let map = new Map();</div><div class="line">let obj = [&quot;a&quot;, &quot;b&quot;];</div><div class="line">map.set(obj, &quot;content&quot;);</div><div class="line">map.get(obj);// &quot;content&quot;</div></pre></td></tr></table></figure>
<p>map还可以用数组为参数直接初始化，要求数组中的元素都是标志键值对的数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let map = new Map([[&quot;key1&quot;, &quot;value1&quot;],[[&quot;key2&quot;], &quot;value2&quot;]]);</div></pre></td></tr></table></figure>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>因为map和object是如此的相似，本文不再介绍set、get、has、遍历等方法，需要的话直接看下官网API即可。这里提下注意事项，因为key可以是对象了，所以如果key是对象，map寻找key依据key的内存地址，如果是简单类型，还是根据值。</p>
<p>看下例子： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let map = new Map();</div><div class="line">let key3 = [&quot;a&quot;];</div><div class="line"></div><div class="line">map.set(&quot;a&quot;,1);</div><div class="line">map.set([&quot;a&quot;],1);</div><div class="line">map.set(key3,1);</div><div class="line"></div><div class="line">console.log(map.get(&quot;a&quot;)); // 1 </div><div class="line">console.log(map.get([&quot;a&quot;])); // undefined</div><div class="line">console.log(map.get(key3)); // 1</div></pre></td></tr></table></figure>
<h2 id="weakMap"><a href="#weakMap" class="headerlink" title="weakMap"></a>weakMap</h2><p>weakMap和weakSet有相似之处，都是为了防止内存泄露而设计，key必须是对象，也只对元素弱引用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h2&gt;&lt;p&gt;在js中，对象(Object)的本质是键值对，但是它的键只能是字符串，这带来了很多不便。为了解决这个问题，ES6中提供了新的
    
    </summary>
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/tags/ES6/"/>
    
      <category term="Map" scheme="https://github.com/njafei/njafei.github.io/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>ES6之Set</title>
    <link href="https://github.com/njafei/njafei.github.io/2018/02/28/ES6-Set/"/>
    <id>https://github.com/njafei/njafei.github.io/2018/02/28/ES6-Set/</id>
    <published>2018-02-28T05:44:04.000Z</published>
    <updated>2018-02-28T05:44:56.416Z</updated>
    
    <content type="html"><![CDATA[<p>在ES6中，提供了新的数据结构set，set类似于数组，但是其中的元素是不能重复的。我们先来看个例子：</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let set = new Set();</div><div class="line"></div><div class="line">[1,2,2,3,4,5,5,5].map(x =&gt; set.add(x));</div><div class="line"></div><div class="line">console.log(set.size); //5</div></pre></td></tr></table></figure>
<p>初始化也可以接受数组为入参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let set = new Set([1,2,3,4]);</div></pre></td></tr></table></figure>
<p>刚才讲到，set中所有的元素是不能重复的，那么，怎么定义重复呢？set使用的方法类似于 ===，只有一个特例，NaN, 精确相等任务NaN不等于自身，而set中认为是相等的。</p>
<p>看几个例子，就一目了然了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let set = new Set([&quot;a&quot;, &quot;a&quot;]);</div><div class="line">console.log(set.size); //1</div><div class="line"></div><div class="line">let set = new Set([&#123;&#125;,&#123;&#125;]);</div><div class="line">console.log(set.size); //2</div><div class="line"></div><div class="line">let a = &#123;key: &apos;a&apos;&#125;;</div><div class="line">let b = &#123;key: &apos;b&apos;&#125;;</div><div class="line">let set = new Set([a,a]);</div><div class="line">console.log(set.size); //1</div><div class="line"></div><div class="line">let set = new Set([a,&#123;a&#125;]);</div><div class="line">console.log(set.size); //2</div></pre></td></tr></table></figure>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>属性有两个：</p>
<ol>
<li>construct 默认是Set函数</li>
<li>size, 即set中元素的数量</li>
</ol>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>set有四个操作方法：</p>
<ol>
<li>add() 返回set本身 </li>
<li>delete() 返回删除是否成功的布尔值</li>
<li>has() 返回set中是否某个元素</li>
<li>clear() 情况set，没有返回值</li>
</ol>
<p>这里要注意的是，delete和has中判断两个元素是否相同的方法和初始化中的方法一致，所以尤其要注意对象的判断，基本类型基本不会有问题。</p>
<p>set有四个遍历方法：</p>
<ol>
<li>keys(): 返回所有的key</li>
<li>values(): 返回所有的value</li>
<li>entries(): 返回所有的键值对</li>
<li>forEach(): 回调函数遍历， 和数组用法一致</li>
</ol>
<p>因为set中本身没有key，value之分，所key和value都是set中元素本身，我们来看下例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let set = new Set([&quot;key1&quot;, &quot;key2&quot;, &quot;key3&quot;]);</div><div class="line">console.log(set.keys());//[&quot;key1&quot;, &quot;key2&quot;, &quot;key3&quot;]</div><div class="line"></div><div class="line">console.log(set.values());//[&quot;key1&quot;, &quot;key2&quot;, &quot;key3&quot;]</div><div class="line"></div><div class="line">console.log(set.entries());//[&#123;&quot;key1&quot;: &quot;key1&quot;&#125;,&#123;&quot;key2&quot;: &quot;key2&quot;&#125;,&#123;&quot;key3&quot;: &quot;key3&quot;&#125;]</div></pre></td></tr></table></figure>
<h2 id="weakSet"><a href="#weakSet" class="headerlink" title="weakSet"></a>weakSet</h2><p>weakSet和set类似，只有两个区别：</p>
<ol>
<li>元素只能是对象</li>
<li>对象都是弱引用，即js的垃圾回收机制不会考虑weakSet中的引用</li>
</ol>
<p>因为第一个特点，所以weakSet不能使用遍历、size等方法和属性(因为遍历的时候可能对象已经被释放了)</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>set可以用来实现去重等功能，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let array = [1,2,2,3];</div><div class="line">let set = Set(array);</div><div class="line"></div><div class="line">let newArray = Array.from(set);</div><div class="line">console.log(newArray); //[1,2,3]</div></pre></td></tr></table></figure>
<p>weakSet在互联网上找到的内容不多，阮一峰的《ES6标准入门》中提到，可以用来保存DOM节点，而不用担心节点移除时引起内存泄露。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在ES6中，提供了新的数据结构set，set类似于数组，但是其中的元素是不能重复的。我们先来看个例子：&lt;/p&gt;
&lt;h2 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h2&gt;&lt;figure cl
    
    </summary>
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/tags/ES6/"/>
    
      <category term="Set" scheme="https://github.com/njafei/njafei.github.io/tags/Set/"/>
    
  </entry>
  
  <entry>
    <title>ipa包逆向重新签名打包</title>
    <link href="https://github.com/njafei/njafei.github.io/2018/02/27/ipa-recodesign/"/>
    <id>https://github.com/njafei/njafei.github.io/2018/02/27/ipa-recodesign/</id>
    <published>2018-02-27T05:43:28.000Z</published>
    <updated>2018-02-27T05:44:31.380Z</updated>
    
    <content type="html"><![CDATA[<p>在使用了rn之后，我们很少会修改原生代码，但是如果想要打包，还是重新打包原生代码，挺花时间的，那么，只修改rn的代码情况下，有没有快速出包的方法？ 答案就是今天这篇文章的主题，ipa逆向，然后替换资源，重新打包，这样只需要替换掉js的bundle包，省去了重新archive的时间了。</p>
<p>过程如下：</p>
<ol>
<li>test.ipa 改名为  test.zip</li>
<li>解开zip，打开Payload，显示test资源包，右键显示报内容，就会看到ipa中所有的资源等内容</li>
<li>找到并复制entitlements.plist文件，这个文件是重新签名的时候要使用的，其中记录的是app需要申请的权限</li>
<li>替换你想替换的资源，这里就是rn的bundle.js</li>
<li>确定你想使用的签名证书的名称，通常是：‘iPhone Distribution: Test Company’</li>
<li>重签名 <code>codesign -f -s &quot;iPhone Distribution: Test Company&quot; --entitlements entitlements.plist Payload/Test.app</code></li>
<li>将签名之后的文件夹压缩 <code>zip -r Test.ipa Payload</code></li>
</ol>
<p>其他用法：</p>
<p>这里讲的替换资源是重签名打包的一种用法，我在网上搜索的时候，发现其他人也生出了很多好的思路，比如： 为了防止提供AppStore的包出问题，直接使用最后的测试包，重新签名，然后上传，这里用到的就是重签名替换证书的功能。</p>
<p>综上，重签名打包，可以替换资源和证书，从而达到在不需要重新编译的情况下，替换资源的功能。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用了rn之后，我们很少会修改原生代码，但是如果想要打包，还是重新打包原生代码，挺花时间的，那么，只修改rn的代码情况下，有没有快速出包的方法？ 答案就是今天这篇文章的主题，ipa逆向，然后替换资源，重新打包，这样只需要替换掉js的bundle包，省去了重新archive
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/njafei/njafei.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/njafei/njafei.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>ES6-Proxy</title>
    <link href="https://github.com/njafei/njafei.github.io/2018/02/23/ES6-Proxy/"/>
    <id>https://github.com/njafei/njafei.github.io/2018/02/23/ES6-Proxy/</id>
    <published>2018-02-23T09:37:04.000Z</published>
    <updated>2018-02-23T09:37:34.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>proxy的作用是代理对象的某些行为，其 实质 是重载对象的方法。</p>
<p>举个例子,我们想要读取一个对象的某个属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;a: &apos;a&apos; , b: &apos;b&apos;&#125;;</div><div class="line">console.log(obj.a); // &apos;a&apos;</div></pre></td></tr></table></figure>
<p>而使用了proxy之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;a: &apos;a&apos;, b: &apos;b&apos;&#125;;</div><div class="line">let handler = &#123;</div><div class="line">	get: fucntion(target, propoty)&#123;</div><div class="line">		return 35;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var proxy = new Proxy(obj, handler);</div><div class="line">console.log(proxy.a);// 35</div></pre></td></tr></table></figure>
<p>相当于 proxy通过handler里面的指令，代理了obj的行为。</p>
<p>proxy能代理的，并不仅仅是get函数，还有如下列表，具体的可以网上查阅下文档。</p>
<ul>
<li>get</li>
<li>set</li>
<li>has</li>
<li>deleteProperty</li>
<li>enumerate</li>
<li>hasOwn</li>
<li>ownKeys</li>
<li>getOwnPropertyDescritor</li>
<li>defineProperty</li>
<li>preventExtensions</li>
<li>getPrototypeOf</li>
<li>isExtensible</li>
<li>setPrototypeOf</li>
<li>apply</li>
<li>construct</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>看完了proxy的文档，感觉模模糊糊有了印象，但是还是对它的使用场景没有概念，网上搜索了下，发下一篇非常好的介绍使用场景的文章，地址如下： <a href="https://segmentfault.com/a/1190000006035363" target="_blank" rel="noopener">[译] 实例解析 ES6 Proxy 使用场景</a>，下面我也会使用这篇文章的例子，来介绍proxy到底怎么用。</p>
<h4 id="校验模块"><a href="#校验模块" class="headerlink" title="校验模块"></a>校验模块</h4><p>这里是重写set函数，实现校验功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">let numericDataStore = &#123;  </div><div class="line">    count: 0,</div><div class="line">    amount: 1234,</div><div class="line">    total: 14</div><div class="line">&#125;;</div><div class="line"></div><div class="line">numericDataStore = new Proxy(numericDataStore, &#123;  </div><div class="line">    set(target, key, value, proxy) &#123;</div><div class="line">        if (typeof value !== &apos;number&apos;) &#123;</div><div class="line">            throw Error(&quot;Properties in numericDataStore can only be numbers&quot;);</div><div class="line">        &#125;</div><div class="line">        return Reflect.set(target, key, value, proxy);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 抛出错误，因为 &quot;foo&quot; 不是数值</div><div class="line">numericDataStore.count = &quot;foo&quot;;</div><div class="line"></div><div class="line">// 赋值成功</div><div class="line">numericDataStore.count = 333;</div></pre></td></tr></table></figure>
<h4 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h4><p>js中的私有属性，约定俗成是通过前面加下划线的方式来实现，这里可以用proxy来实现，并且做到了强制私有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var api = &#123;  </div><div class="line">    _apiKey: &apos;123abc456def&apos;,</div><div class="line">    /* mock methods that use this._apiKey */</div><div class="line">    getUsers: function()&#123;&#125;, </div><div class="line">    getUser: function(userId)&#123;&#125;, </div><div class="line">    setUser: function(userId, config)&#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// logs &apos;123abc456def&apos;;</div><div class="line">console.log(&quot;An apiKey we want to keep private&quot;, api._apiKey);</div><div class="line"></div><div class="line">// get and mutate _apiKeys as desired</div><div class="line">var apiKey = api._apiKey;  </div><div class="line">api._apiKey = &apos;987654321&apos;;</div></pre></td></tr></table></figure>
<h4 id="访问日志"><a href="#访问日志" class="headerlink" title="访问日志"></a>访问日志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">let api = &#123;  </div><div class="line">    _apiKey: &apos;123abc456def&apos;,</div><div class="line">    getUsers: function() &#123; /* ... */ &#125;,</div><div class="line">    getUser: function(userId) &#123; /* ... */ &#125;,</div><div class="line">    setUser: function(userId, config) &#123; /* ... */ &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function logMethodAsync(timestamp, method) &#123;  </div><div class="line">    setTimeout(function() &#123;</div><div class="line">        console.log(`$&#123;timestamp&#125; - Logging $&#123;method&#125; request asynchronously.`);</div><div class="line">    &#125;, 0)</div><div class="line">&#125;</div><div class="line"></div><div class="line">api = new Proxy(api, &#123;  </div><div class="line">    get: function(target, key, proxy) &#123;</div><div class="line">        var value = target[key];</div><div class="line">        return function(...arguments) &#123;</div><div class="line">            logMethodAsync(new Date(), key);</div><div class="line">            return Reflect.apply(value, target, arguments);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">api.getUsers();</div></pre></td></tr></table></figure>
<h4 id="预警和拦截"><a href="#预警和拦截" class="headerlink" title="预警和拦截"></a>预警和拦截</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">let dataStore = &#123;  </div><div class="line">    noDelete: 1235,</div><div class="line">    oldMethod: function() &#123;/*...*/ &#125;,</div><div class="line">    doNotChange: &quot;tried and true&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">const NODELETE = [&apos;noDelete&apos;];  </div><div class="line">const NOCHANGE = [&apos;doNotChange&apos;];</div><div class="line">const DEPRECATED = [&apos;oldMethod&apos;];  </div><div class="line"></div><div class="line">dataStore = new Proxy(dataStore, &#123;  </div><div class="line">    set(target, key, value, proxy) &#123;</div><div class="line">        if (NOCHANGE.includes(key)) &#123;</div><div class="line">            throw Error(`Error! $&#123;key&#125; is immutable.`);</div><div class="line">        &#125;</div><div class="line">        return Reflect.set(target, key, value, proxy);</div><div class="line">    &#125;,</div><div class="line">    deleteProperty(target, key) &#123;</div><div class="line">        if (NODELETE.includes(key)) &#123;</div><div class="line">            throw Error(`Error! $&#123;key&#125; cannot be deleted.`);</div><div class="line">        &#125;</div><div class="line">        return Reflect.deleteProperty(target, key);</div><div class="line"></div><div class="line">    &#125;,</div><div class="line">    get(target, key, proxy) &#123;</div><div class="line">        if (DEPRECATED.includes(key)) &#123;</div><div class="line">            console.warn(`Warning! $&#123;key&#125; is deprecated.`);</div><div class="line">        &#125;</div><div class="line">        var val = target[key];</div><div class="line"></div><div class="line">        return typeof val === &apos;function&apos; ?</div><div class="line">            function(...args) &#123;</div><div class="line">                Reflect.apply(target[key], target, args);</div><div class="line">            &#125; :</div><div class="line">            val;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// these will throw errors or log warnings, respectively</div><div class="line">dataStore.doNotChange = &quot;foo&quot;;  </div><div class="line">delete dataStore.noDelete;  </div><div class="line">dataStore.oldMethod();</div></pre></td></tr></table></figure>
<h4 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h4><p>通过特征来过滤不必要的操作，例如下载中，解析中等中间过程，减少响应的压力</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;  </div><div class="line">    getGiantFile: function(fileId) &#123;/*...*/ &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj = new Proxy(obj, &#123;  </div><div class="line">    get(target, key, proxy) &#123;</div><div class="line">        return function(...args) &#123;</div><div class="line">            const id = args[0];</div><div class="line">            let isEnroute = checkEnroute(id);</div><div class="line">            let isDownloading = checkStatus(id);      </div><div class="line">            let cached = getCached(id);</div><div class="line"></div><div class="line">            if (isEnroute || isDownloading) &#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">            if (cached) &#123;</div><div class="line">                return cached;</div><div class="line">            &#125;</div><div class="line">            return Reflect.apply(target[key], target, args);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;p&gt;proxy的作用是代理对象的某些行为，其 实质 是重载对象的方法。&lt;/p&gt;
&lt;p&gt;举个例子,我们想要读取一个对象的某个属性&lt;/p&gt;
&lt;fig
    
    </summary>
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6-Symbols</title>
    <link href="https://github.com/njafei/njafei.github.io/2018/02/22/ES6-Symbols/"/>
    <id>https://github.com/njafei/njafei.github.io/2018/02/22/ES6-Symbols/</id>
    <published>2018-02-22T05:57:42.000Z</published>
    <updated>2018-02-22T06:00:11.628Z</updated>
    
    <content type="html"><![CDATA[<p>#背景<br>ES5中，属性都可以通过点方法来获取和赋值。这也带来了一个问题，当我想给一个类增加属性的时候，除非我看完这个类的所有细节，否则我很难知道一个属性名是否已经被占用。而ES6为了解决这个问题，引入了一个新的原始类型Symbol，它表示独一无二的值，来避免重复的命名。</p>
<p>加入Symbol之后，JS中的基础类型共有：</p>
<ul>
<li>undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>String</li>
<li>Number</li>
<li>Object</li>
<li>Symbol</li>
</ul>
<p>#使用</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>Symbol的初始化方法很简单，但是要注意，它不是对象（Object），所以不能用new初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let s = Symbol();</div></pre></td></tr></table></figure>
<p>Symbol没有属性，是一个类似于string的数据类型，我的理解，Symbol其实就是独一无二的string。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s.name = &apos;symbol&apos;; //error</div></pre></td></tr></table></figure>
<p>Symbol可以通过加参数的形式来区分不同的Symbol，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let s = Symbol(&apos;foo&apos;);</div></pre></td></tr></table></figure>
<p>注意，即使使用相同的参数来初始化，得到的实例也是不同的，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let a = Symbol(&apos;foo&apos;);</div><div class="line">let b = Symbol(&apos;foo&apos;);</div><div class="line"></div><div class="line">let same = a === b;</div><div class="line"></div><div class="line">console.log(same); //false</div></pre></td></tr></table></figure>
<p>如果想要获取以某个string为参数的Symbol，在之后会讲到Symbol.for()函数。</p>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>使用Symbol给属性赋值，用法和string属性赋值基本相似，但是不可以用<code>.</code>,要用<code>[]</code>。以下是三种赋值方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">let s = Symbol();</div><div class="line"></div><div class="line"></div><div class="line">let a = &#123;&#125;;</div><div class="line"></div><div class="line">// method 1</div><div class="line">a[s] = &apos;hello&apos;;</div><div class="line"></div><div class="line">//method 2</div><div class="line">a = &#123;</div><div class="line">	[s] = &apos;hello&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//method 3</div><div class="line"></div><div class="line">Object.defineProperty(a, s, &#123;value: &apos;hello&apos;&#125;);</div></pre></td></tr></table></figure>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>Symbol的一个场景是上述提到的，给一个类增加属性，而避免属性重复。</p>
<p>第二是使用在常量中，<code>switch case</code>来保证唯一性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let CASE1 = Symbol();</div><div class="line">let CASE2 = Symbol();</div><div class="line"></div><div class="line">switch (case) &#123;</div><div class="line">	case CASE1 :&#123;</div><div class="line">		return 1;</div><div class="line">	&#125;</div><div class="line">	case CASE2 :&#123;</div><div class="line">		return 2;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="注意事项（和string属性不同的地方）"><a href="#注意事项（和string属性不同的地方）" class="headerlink" title="注意事项（和string属性不同的地方）"></a>注意事项（和string属性不同的地方）</h1><p>最主要的区别，使用 <code>for ... in</code>、 <code>for ... of</code> 或者<code>Object.keys()</code>、 <code>Object.getOwnPropertyNames()</code>不会返回Symbol</p>
<p>如果想获取对象的所有Symbols，使用函数<code>getOwnPropertySymbols</code></p>
<p>有个新的API，<code>Reflect.ownKyes</code>，会返回所有的String属性和Symbol属性</p>
<h1 id="Symbol-keyFor和Symbol-for"><a href="#Symbol-keyFor和Symbol-for" class="headerlink" title="Symbol.keyFor和Symbol.for"></a>Symbol.keyFor和Symbol.for</h1><h3 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for"></a>Symbol.for</h3><p>Symbol会返回一个新的实例，无论参数是什么，上面已经将到了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let a = Symbol(&apos;foo&apos;);</div><div class="line">let b = Symbol(&apos;foo&apos;);</div><div class="line"></div><div class="line">let same = a === b; //false</div></pre></td></tr></table></figure>
<p>而Symbol.for则会先搜索是否有以这个参数初始化的Symbol，如果有则放回这个Symbol，否则初始化一个新的,实现逻辑如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Symbol.for(params) = &#123;</div><div class="line">	if (searchSymbolInitWithParams)&#123;</div><div class="line">		return found_symbol;</div><div class="line">	&#125; else &#123;</div><div class="line">		return Symbol(params);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和第一个例子对比看下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let a = Symbol.for(&apos;foo&apos;);</div><div class="line">let b = Symbol.for(&apos;foo&apos;);</div><div class="line"></div><div class="line">let same = a === b; //true</div></pre></td></tr></table></figure>
<p>如果Symbol和Symbol.for混用呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let a = Symbol(&apos;foo&apos;);</div><div class="line">let b = Symbol.for(&apos;foo&apos;);</div><div class="line"></div><div class="line">console.log(a===b); //false</div></pre></td></tr></table></figure>
<p>这说明两者是没有打通的，即Symbol初始化的实例无法被Symbol.for找到</p>
<h3 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor"></a>Symbol.keyFor</h3><p>用Symbol.for来初始化的Symbol，如何知道它的初始化参数呢，这里提供了一个方法： Symbol.keyFor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let a = Symbol.for(&apos;foo&apos;);</div><div class="line">let b = Symbol.Keyfor(a);// &apos;foo&apos;</div></pre></td></tr></table></figure>
<p>注意，Symbol初始化不能用这个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let a = Symbol(&apos;foo&apos;);</div><div class="line">let b = Symbol.Keyfor(a);// undefined</div></pre></td></tr></table></figure>
<p>注意：Symbol.for 为Symbol值登记的是全局的，这意味着在不同的iframe都可以取到同一个值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#背景&lt;br&gt;ES5中，属性都可以通过点方法来获取和赋值。这也带来了一个问题，当我想给一个类增加属性的时候，除非我看完这个类的所有细节，否则我很难知道一个属性名是否已经被占用。而ES6为了解决这个问题，引入了一个新的原始类型Symbol，它表示独一无二的值，来避免重复的命名
    
    </summary>
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>React Native性能优化</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/10/25/RNpreformance/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/10/25/RNpreformance/</id>
    <published>2017-10-25T03:00:45.000Z</published>
    <updated>2017-10-25T03:03:48.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于帧"><a href="#关于帧" class="headerlink" title="关于帧"></a>关于帧</h2><p>在讲述如何优化性能之前，我们要先了解一下性能的概念。对一个从未接触过相关概念的人来说，所谓的性能就是当你去使用App的时候很流畅，点击、跳转等交互效果反应很快，而且很顺滑。这是感性的角度，那么理性的角度或者数据的角度看待呢？</p>
<p>这里要介绍一个概念： 帧率。我们知道，所谓的动画或者电影，其实归根结底就是在一秒内快速闪过多张不同的图片，如果快到一定的程度，肉眼会误以为里面的动画都是连贯的。在iOS等设备，标准是每秒60帧（即每秒连续展示60张图片），这个标准足以保证用户的体验。</p>
<p><img src="https://gss0.baidu.com/94o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/d1160924ab18972be457999ee2cd7b899e510a70.jpg" alt="动画示意"></p>
<p>系统会每16.6毫秒询问你下一帧的数据，如果你正在处理比较复杂的任务，则系统会默认这一帧内容保持不变，即出现了丢帧的现象。如果丢的帧比较多，则界面会看起来卡顿，比如用户点击了按钮，但是没有反馈。</p>
<p>对<code>React Native</code>来说，帧分为两种： <code>JavaScript</code>帧和主线程帧（<code>UI</code>帧）</p>
<h3 id="JavaScript帧"><a href="#JavaScript帧" class="headerlink" title="JavaScript帧"></a>JavaScript帧</h3><p><code>React Native</code>大部分的业务处理，都是在<code>JavaScript</code>帧中进行，包括API调用和触摸等交互的处理。那么当处理比较复杂的任务，比如<code>setState</code>然后<code>render</code>，则很可能会丢帧。或者做由JS处理的动画时，也极容易出现丢帧卡顿。</p>
<h3 id="主线程帧（UI帧）"><a href="#主线程帧（UI帧）" class="headerlink" title="主线程帧（UI帧）"></a>主线程帧（<code>UI</code>帧）</h3><p>iOS的主线程是UI线程，所以在iOS的UI效果基本是非常出色的，这也是为什么<code>NavigatorIOS</code>比<code>Navigator</code>的性能好很多的原因（<code>NavigatorIOS</code>是主线程处理，而<code>Navigator</code>是JS线程处理）</p>
<h3 id="如何查看帧数据"><a href="#如何查看帧数据" class="headerlink" title="如何查看帧数据"></a>如何查看帧数据</h3><p>我们可以通过打开<code>RN</code>的<code>Debug</code>菜单，然后选择<code>Show Perf Monitor</code>来查看当前页面的<code>JS</code>帧和主线程帧。</p>
<p>好了，性能的定义和我们评估性能标准已经知道了，下面我们来看下影响性能的因素。</p>
<h2 id="影响性能的因素和提升方案"><a href="#影响性能的因素和提升方案" class="headerlink" title="影响性能的因素和提升方案"></a>影响性能的因素和提升方案</h2><h3 id="宽泛的原因"><a href="#宽泛的原因" class="headerlink" title="宽泛的原因"></a>宽泛的原因</h3><p>我们先抛开RN或者iOS的前端框架，看下对一台带屏幕的设备来说，影响性能的原因有哪些。</p>
<p>我们用金字塔模式来看，首先最明显的有两个</p>
<ul>
<li>设备性能</li>
<li>程序设计</li>
</ul>
<p>从根本上来说，设备性能是最大的瓶颈，不过这个我们程序员暂时无能为力。而程序设计可能引起性能差的有哪些呢？判断程序设计的一个标准就是复杂度， 而复杂度又分为两个：</p>
<ul>
<li>时间复杂度</li>
<li>空间复杂度</li>
</ul>
<p>这时我们的性能因素树是：</p>
<ul>
<li>设备性能</li>
<li>程序设计<ul>
<li>时间复杂度</li>
<li>空间复杂度</li>
</ul>
</li>
</ul>
<p>在设备空间充足的情况下，主要的影响就是时间复杂度，而时间复杂度高的原因有几个：</p>
<ul>
<li>前端方案不合理，UI层次或者顺序设计不合理，浪费性能</li>
<li>使用的算法过于复杂</li>
</ul>
<p>我们挨个说下这两个个问题，前端方案是最容易造成性能不好的原因，比如我们有屏幕上有几个区域，互相之间没有影响，而由于不合理的设计，在一个区域变化的时候，要刷新这个界面，就会出现卡顿。一个合理的前端方案，应该是尽可能减少页面的刷新频率和刷新范围，保证每帧的计算是相对小的。</p>
<p>而算法过于复杂，则是算法消耗的时间太长，影响了UI的渲染。比如使用了圈复杂度非常高的算法，或者有大量的数据要不停地计算。</p>
<p>这样我们的性能因素树变成了：</p>
<ul>
<li>设备性能</li>
<li>程序设计<ul>
<li>空间复杂度</li>
<li>时间复杂度<ul>
<li>前端方案不合理，UI层次或者顺序设计不合理，浪费性能<ul>
<li>使用的算法过于复杂</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>可能还会有人觉得网络等原因会造成卡顿，但是我觉得如果交互设计良好，网络状况不好的话，只会影响数据出现的时间长，而不会造成页面的卡顿。</p>
<p>看完了比较普遍宽泛的原因，我们看下针对RN的</p>
<h3 id="RN的特有原因"><a href="#RN的特有原因" class="headerlink" title="RN的特有原因"></a>RN的特有原因</h3><h4 id="JS-Bridge的效率"><a href="#JS-Bridge的效率" class="headerlink" title="JS Bridge的效率"></a>JS Bridge的效率</h4><p>虽然官方的文章里没有写，但是从我测试看到的数据来看，虽然RN的性能比较接近Native，但是因为JS是运行在子线程中的，所以处理大量数据或者动画的时候，JS的帧数会比较少。</p>
<p>这个我们暂时无能为力</p>
<h4 id="动画和Touchable组件在JS线程中运行"><a href="#动画和Touchable组件在JS线程中运行" class="headerlink" title="动画和Touchable组件在JS线程中运行"></a>动画和Touchable组件在JS线程中运行</h4><p>Animated和Touchable系列组件都是在JS中运行，所以在处理复杂动画或者复杂操作的时候，会出现卡顿。</p>
<p>这里给几个建议：</p>
<ul>
<li><p>关于导航</p>
<ol>
<li>iOS上使用<code>NavigatorIOS</code>替换<code>Navigator</code>，同时，react也推出了新的<a href="https://reactnavigation.org/" target="_blank" rel="noopener">Navigation库</a>希望解决导航卡顿的问题</li>
<li>push的新界面的动画，使用<code>InteractionManager</code>，就是在导航动画结束后执行新的动画，而不是同时执行</li>
</ol>
</li>
<li><p>关于动画</p>
<ol>
<li>如果<code>Animated</code>的效果不能接受，使用<code>LayoutAnimation</code>，它是基于<code>Core Animation</code></li>
<li>android上面尽量少用动画（真的很卡0_0）</li>
</ol>
</li>
</ul>
<h4 id="其他建议"><a href="#其他建议" class="headerlink" title="其他建议"></a>其他建议</h4><ul>
<li>使用<a href="">PureComponent</a></li>
<li>使用 <code>shouldComponentUpdate</code>函数，这个函数默认返回true，但是我们可以通过自定义来优化重新绘制的逻辑</li>
<li>release 去除console.log()</li>
</ul>
<figure class="highlight plain"><figcaption><span>(!__DEV__) &#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  global.console = &#123;</div><div class="line">    info: () =&gt; &#123;&#125;,</div><div class="line">    log: () =&gt; &#123;&#125;,</div><div class="line">    warn: () =&gt; &#123;&#125;,</div><div class="line">    debug: () =&gt; &#123;&#125;,</div><div class="line">    error: () =&gt; &#123;&#125;,</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="最重要的建议"><a href="#最重要的建议" class="headerlink" title="最重要的建议"></a>最重要的建议</h4><ol>
<li>仔细考虑UI的设计</li>
<li>仔细考虑UI的设计</li>
<li>仔细考虑UI的设计</li>
</ol>
<p>一个好的UI设计方案，是可以抵过上面所有的建议加起来的效果的，所以一定要仔细考虑再动手。</p>
<p>参考：</p>
<ul>
<li><a href="http://reactnative.cn/docs/0.49/performance.html#content" target="_blank" rel="noopener">官方文档：性能</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于帧&quot;&gt;&lt;a href=&quot;#关于帧&quot; class=&quot;headerlink&quot; title=&quot;关于帧&quot;&gt;&lt;/a&gt;关于帧&lt;/h2&gt;&lt;p&gt;在讲述如何优化性能之前，我们要先了解一下性能的概念。对一个从未接触过相关概念的人来说，所谓的性能就是当你去使用App的时候很流畅，点
    
    </summary>
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/categories/React-Native/"/>
    
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/tags/React-Native/"/>
    
      <category term="performance" scheme="https://github.com/njafei/njafei.github.io/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>Next增加搜索localSearch</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/10/19/Next-add-localSearch/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/10/19/Next-add-localSearch/</id>
    <published>2017-10-19T08:06:51.000Z</published>
    <updated>2017-10-19T08:12:28.931Z</updated>
    
    <content type="html"><![CDATA[<p>Next本身增加localSearch很简单，三步即可：</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-generator-searchdb --save</div></pre></td></tr></table></figure>
<p>编辑 站点配置文件，新增以下内容到任意位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">search:</div><div class="line">  path: search.xml</div><div class="line">  field: post</div><div class="line">  format: html</div><div class="line">  limit: 10000</div></pre></td></tr></table></figure>
<p>编辑 主题配置文件，启用本地搜索功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># Local search</div><div class="line">local_search:</div><div class="line">  enable: true</div></pre></td></tr></table></figure>
<h2 id="遇到问题，一直loading"><a href="#遇到问题，一直loading" class="headerlink" title="遇到问题，一直loading"></a>遇到问题，一直loading</h2><p>发布了之后，点击搜索一直在loading，查了其他人的文章<a href="https://www.v2ex.com/amp/t/298727" target="_blank" rel="noopener">Hexo next 主题的 local search 功能失效，点击搜索链接无法弹出叠加层
</a>，发现是<code>search.xml</code>出现了问题。</p>
<p>排查问题步骤：</p>
<ol>
<li>command + option + J 打开调试器</li>
<li>点击NetWork，发现卡在了<code>search.xml</code>上面</li>
<li>尝试debug <code>serach.xml</code>文件，打开 <a href="https://njafei.github.io/search.xml" target="_blank" rel="noopener">https://njafei.github.io/search.xml</a></li>
<li>看到警告： <code>error on line 92 at column 35: Input is not proper UTF-8, indicate encoding ! 0x10 0xE6 0x88 0x96</code></li>
<li>编码问题，找到对应的文章，先对其进行<code>utf-8</code>编码，然后放到sublimeText中，我发现中间多了一个类似于<code>DEL</code>的乱码，删除即可</li>
<li>重新发布，搜索可用</li>
</ol>
<h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><p>search有时候会有缓存，这时候，可以打开对应的<code>search.xml</code>文件<a href="https://njafei.github.io/search.xml" target="_blank" rel="noopener">https://njafei.github.io/search.xml</a>，刷新几下即可</p>
<blockquote>
<p>PS： 如果你想刷新你的文件，把前面的链接替换即可。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Next本身增加localSearch很简单，三步即可：&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;安装 hexo-generator-searchdb，在站点的根目录
    
    </summary>
    
    
      <category term="博客搭建和功能增强" scheme="https://github.com/njafei/njafei.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E5%8A%9F%E8%83%BD%E5%A2%9E%E5%BC%BA/"/>
    
  </entry>
  
  <entry>
    <title>ImageOptm 自动化无损优化图片</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/09/26/ImageOptm/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/09/26/ImageOptm/</id>
    <published>2017-09-26T03:01:58.000Z</published>
    <updated>2017-10-19T03:37:16.721Z</updated>
    
    <content type="html"><![CDATA[<p>iOS控制包的大小对于公司来说，是个非常重要的事情。因为苹果公司对于包的大小超过100M的，不会允许用户使用移动网络来下载，这很可能造成商业上的损失。</p>
<p>而在控制包的大小中，一个很重要的原则就是禁止大图片。之前研究其他公司的ipa包的时候，就出现过一个icon高达1M的事故。而平时，虽然程序员们百般小心，难免被设计师暗算给张大图（玩笑），所以靠人终究不是一个可持续的保证质量的方法。</p>
<p>平时用的无损压缩最多的工具是<code>ImageOptm</code>，它可以无损压缩图片（即用户看起来感官无变化，而图片尽可能小），而且它是提供命令行的，<a href="https://imageoptim.com/command-line.html" target="_blank" rel="noopener">ImageOptm command line</a>.</p>
<p>我们就可以通过Jenkins的定时任务，每天凌晨去优化所有的图片，然后再自动commit上传。</p>
<p>具体任务就很简单了，大概几个步骤：</p>
<p>1、Jenkins开个定时任务，更新代码</p>
<p>2、执行ImageOptm脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/Applications/ImageOptim.app/Contents/MacOS/ImageOptim  $WORKSPACE/</div></pre></td></tr></table></figure>
<p>3、上传代码</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS控制包的大小对于公司来说，是个非常重要的事情。因为苹果公司对于包的大小超过100M的，不会允许用户使用移动网络来下载，这很可能造成商业上的损失。&lt;/p&gt;
&lt;p&gt;而在控制包的大小中，一个很重要的原则就是禁止大图片。之前研究其他公司的ipa包的时候，就出现过一个icon高
    
    </summary>
    
    
      <category term="自动化" scheme="https://github.com/njafei/njafei.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Java对空格的encode格式问题</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/09/22/Java-space-encode/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/09/22/Java-space-encode/</id>
    <published>2017-09-22T08:57:41.000Z</published>
    <updated>2017-10-19T03:37:16.721Z</updated>
    
    <content type="html"><![CDATA[<p>今天发现了一个非常奇怪的问题，服务端给了一个encode的url，内容是位“1 1”：</p>
<p>encode之后是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1+1</div></pre></td></tr></table></figure>
<p>前端decode之后是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1+1</div></pre></td></tr></table></figure>
<p>可是在其他的浏览器等decode之后的结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 1</div></pre></td></tr></table></figure>
<p>发现java的encode有个坑，在java中，encode遵循的标准是<a href="http://www.faqs.org/rfcs/rfc1738.html" target="_blank" rel="noopener">rfc1738</a>，而在iOS中，encode遵循的标准是<a href="http://www.faqs.org/rfcs/rfc2396.html" target="_blank" rel="noopener">rfc2396</a>，两者对于空格的encode不同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rfc1738 =&gt; +</div><div class="line">rfc2396 =&gt; %20</div></pre></td></tr></table></figure>
<p>所以今后和Java服务端合作的时候，如果encode之后的文案出现了+号这种莫名奇妙的bug，记得让他们检查下encode的代码，可以通过替换来解决这个问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天发现了一个非常奇怪的问题，服务端给了一个encode的url，内容是位“1 1”：&lt;/p&gt;
&lt;p&gt;encode之后是&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div 
    
    </summary>
    
    
      <category term="小知识" scheme="https://github.com/njafei/njafei.github.io/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>React-Native优化之PureComponent</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/07/27/pureComponent/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/07/27/pureComponent/</id>
    <published>2017-07-27T10:56:18.000Z</published>
    <updated>2017-10-19T03:37:16.730Z</updated>
    
    <content type="html"><![CDATA[<p>React15.3的发布中包含了PureComponent，这个类最重要的用法是为了优化React的性能，下面我们将看下它是如何优化的。</p>
<h1 id="Component-VS-PureComponent"><a href="#Component-VS-PureComponent" class="headerlink" title="Component VS PureComponent"></a>Component VS PureComponent</h1><p>首先要看Component的生命周期：<br><img src="http://on0hv7n2x.bkt.clouddn.com/component-lifecycle.jpg" alt=""></p>
<p>当props或者state改变的时候，会执行<code>shouldComponentUpdate</code>方法来判断是否需要重新render组建，我们平时在做页面的性能优化的时候，往往也是通过这一步来判断的。Component默认的<code>shouldComponentUpdate</code>返回的是true，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">shouldComponentUpdate(nextProps, nextState) &#123;</div><div class="line">  return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而PureComponent的<code>shouldComponentUpdate</code>是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (this._compositeType === CompositeTypes.PureClass) &#123;</div><div class="line">  shouldUpdate = !shallowEqual(prevProps, nextProps) || ! shallowEqual(inst.state, nextState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的比较，只会做潜比较，即比较两者的内存地址是否相同，而对于其值是否发生变化，则不会理会。我们通过以下的例子来看下：</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Sample React Native App</div><div class="line"> * https://github.com/facebook/react-native</div><div class="line"> * @flow</div><div class="line"> */</div><div class="line"></div><div class="line">import React, &#123; PureComponent,Component &#125; from &apos;react&apos;;</div><div class="line">import &#123;</div><div class="line">  AppRegistry,</div><div class="line">  StyleSheet,</div><div class="line">  Text,</div><div class="line">  View,</div><div class="line">  Button</div><div class="line">&#125; from &apos;react-native&apos;;</div><div class="line"></div><div class="line">export default class test extends PureComponent &#123;</div><div class="line">  constructor(props)&#123;</div><div class="line">    super(props);</div><div class="line">    this.state = &#123;</div><div class="line">       number : 1,</div><div class="line">       numbers: [],</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">        &lt;Button title=&#123;&apos;number + 1&apos;&#125; onPress=&#123;this.numberAdd.bind(this)&#125; /&gt;</div><div class="line">        &lt;Text&gt;number value: &#123;this.state.number&#125;&lt;/Text&gt;</div><div class="line">        &lt;Button title=&#123;&apos;numbers + 1&apos;&#125; onPress=&#123;this.numbersAdd.bind(this)&#125; /&gt;</div><div class="line">        &lt;Text&gt;numbers length: &#123;this.state.numbers.length&#125;&lt;/Text&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  numberAdd()&#123;</div><div class="line">      this.setState(&#123;number: ++this.state.number &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  numbersAdd()&#123;</div><div class="line">    let numbers = this.state.numbers;</div><div class="line">    numbers.push(1);</div><div class="line">    this.setState(&#123;numbers: numbers&#125;);</div><div class="line">    console.log(this.state.numbers);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line">  container: &#123;</div><div class="line">    flex: 1,</div><div class="line">    justifyContent: &apos;center&apos;,</div><div class="line">    alignItems: &apos;center&apos;,</div><div class="line">    backgroundColor: &apos;#F5FCFF&apos;,</div><div class="line">  &#125;,</div><div class="line">  welcome: &#123;</div><div class="line">    fontSize: 20,</div><div class="line">    textAlign: &apos;center&apos;,</div><div class="line">    margin: 10,</div><div class="line">  &#125;,</div><div class="line">  instructions: &#123;</div><div class="line">    textAlign: &apos;center&apos;,</div><div class="line">    color: &apos;#333333&apos;,</div><div class="line">    marginBottom: 5,</div><div class="line">  &#125;,</div><div class="line">&#125;);</div><div class="line"></div><div class="line">AppRegistry.registerComponent(&apos;test&apos;, () =&gt; test);</div></pre></td></tr></table></figure>
<p>界面如下：</p>
<p><img src="http://on0hv7n2x.bkt.clouddn.com/screenShotSimulator%20Screen%20Shot%202017%E5%B9%B47%E6%9C%8827%E6%97%A5%20%E4%B8%8B%E5%8D%886.48.31.png" alt=""></p>
<p>这里去点击number+1 和 numbers+1都不会有任何页面的变化。</p>
<h1 id="如何让PureComponent重绘"><a href="#如何让PureComponent重绘" class="headerlink" title="如何让PureComponent重绘"></a>如何让PureComponent重绘</h1><p>那如果PureComponent变化的时候(这其实不符合我们的初衷)，我们要怎么做呢？这里有两个办法：</p>
<ol>
<li>重写shouldUpdateComponent方法</li>
<li>props或者state增减参数</li>
</ol>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">numbersAdd()&#123;</div><div class="line">    let numbers = this.state.numbers;</div><div class="line">    numbers.push(1);</div><div class="line">    this.setState(&#123;numbers: numbers&#125;);</div><div class="line">    console.log(this.state.numbers);</div><div class="line"></div><div class="line">    this.setState(&#123;newState: 1&#125;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这样，shouldComponentUpdate的返回值也会是true。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综上，PureComponent非常适合于不变的组件，尤其是和数据、业务无关的纯展示组件，因为它的节省了大量比较的工作。但是对于大部分的业务来说，界面很少会有不变的组件，所以使用的场景会比较少，但是如果遇到，请尽情使用！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React15.3的发布中包含了PureComponent，这个类最重要的用法是为了优化React的性能，下面我们将看下它是如何优化的。&lt;/p&gt;
&lt;h1 id=&quot;Component-VS-PureComponent&quot;&gt;&lt;a href=&quot;#Component-VS-PureC
    
    </summary>
    
      <category term="react-native" scheme="https://github.com/njafei/njafei.github.io/categories/react-native/"/>
    
    
      <category term="react-native" scheme="https://github.com/njafei/njafei.github.io/tags/react-native/"/>
    
      <category term="component" scheme="https://github.com/njafei/njafei.github.io/tags/component/"/>
    
  </entry>
  
  <entry>
    <title>react-native time定时器 防止内存泄露的注意点</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/07/27/react-native-time-attations/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/07/27/react-native-time-attations/</id>
    <published>2017-07-27T07:50:21.000Z</published>
    <updated>2017-10-19T03:37:16.730Z</updated>
    
    <content type="html"><![CDATA[<p><code>time</code>是<code>react-native</code>提供的一个定时器，在实际使用中，经常会有使用不对，造成内存泄露的情况。很多<code>React Native</code>应用发生致命错误（闪退）是与计时器有关。具体来说，是在某个组件被卸载<code>（unmount）</code>之后，计时器却仍然在运行。</p>
<p>防止出问题的办法也很简单，在<code>unmount</code>的时候，增加卸载定时器的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">componentDidMount() &#123;</div><div class="line">    this.timer = setTimeout(</div><div class="line">      () =&gt; &#123; console.log(&apos;把一个定时器的引用挂在this上&apos;); &#125;,</div><div class="line">      500</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">componentWillUnmount() &#123;</div><div class="line">    // 请注意Un&quot;m&quot;ount的m是小写</div><div class="line">    // 如果存在this.timer，则使用clearTimeout清空。</div><div class="line">    // 如果你使用多个timer，那么用多个变量，或者用个数组来保存引用，然后逐个clear</div><div class="line">    this.timer &amp;&amp; clearTimeout(this.timer);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里的timer是在<code>DidMount</code>中赋值的，如果是多次赋值呢？比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">export default class test extends Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">        &lt;Button title=&#123;&apos;click5000&apos;&#125; onPress=&#123;this.alertInfo.bind(this,5000)&#125; /&gt;</div><div class="line">        &lt;Button title=&#123;&apos;click2000&apos;&#125; onPress=&#123;this.alertInfo.bind(this,2000)&#125; /&gt;</div><div class="line">        &lt;Button title=&#123;&apos;clean timer&apos;&#125; onPress=&#123;this.cleanTimer.bind(this)&#125; /&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  alertInfo(time)&#123;</div><div class="line">      this.timer = setTimeout(</div><div class="line">          ()=&gt;&#123;</div><div class="line">            alert(&apos;hah&apos;);</div><div class="line">          &#125;,</div><div class="line">          time,</div><div class="line">      );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  cleanTimer()&#123;</div><div class="line">    this.timer &amp;&amp; clearTimeout(this.timer);</div><div class="line">    console.log(&apos;timer cleared&apos;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">AppRegistry.registerComponent(&apos;test&apos;, () =&gt; test);</div></pre></td></tr></table></figure>
<p>这里要介绍下<code>setTimeout</code>的返回值，我们打断点可以看到，<code>this.timer</code>是一个number。根据stack上面的其他网友的回答<a href="https://stackoverflow.com/questions/10068981/what-does-settimeout-return" target="_blank" rel="noopener">what-does-settimeout-return</a>，setTimer会返回一个id，代表你已经向js的runtime系统中成功注册了一个定时器任务，这个id就是系统返回的id。</p>
<p>那如果是需要多次赋值，就一定要先将time clear掉，然后再赋值，或者使用多个参数来标志，否则之后就找不到上次的id，也就没办法clear了，同样可能造成内存泄露的情况。</p>
<p>例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Sample React Native App</div><div class="line"> * https://github.com/facebook/react-native</div><div class="line"> * @flow</div><div class="line"> */</div><div class="line"></div><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">import &#123;</div><div class="line">  AppRegistry,</div><div class="line">  StyleSheet,</div><div class="line">  Text,</div><div class="line">  View,</div><div class="line">  Button</div><div class="line">&#125; from &apos;react-native&apos;;</div><div class="line"></div><div class="line">export default class test extends Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">        &lt;Button title=&#123;&apos;click5000&apos;&#125; onPress=&#123;this.alertInfo.bind(this,5000)&#125; /&gt;</div><div class="line">        &lt;Button title=&#123;&apos;click2000&apos;&#125; onPress=&#123;this.alertInfo.bind(this,2000)&#125; /&gt;</div><div class="line">        &lt;Button title=&#123;&apos;clean timer&apos;&#125; onPress=&#123;this.cleanTimer.bind(this)&#125; /&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  alertInfo(time)&#123;</div><div class="line">      this.timer = setTimeout(</div><div class="line">          ()=&gt;&#123;</div><div class="line">            alert(&apos;hah&apos;);</div><div class="line">          &#125;,</div><div class="line">          time,</div><div class="line">      );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  cleanTimer()&#123;</div><div class="line">    this.timer &amp;&amp; clearTimeout(this.timer);</div><div class="line">    console.log(&apos;timer cleared&apos;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line">  container: &#123;</div><div class="line">    flex: 1,</div><div class="line">    justifyContent: &apos;center&apos;,</div><div class="line">    alignItems: &apos;center&apos;,</div><div class="line">    backgroundColor: &apos;#F5FCFF&apos;,</div><div class="line">  &#125;,</div><div class="line">  welcome: &#123;</div><div class="line">    fontSize: 20,</div><div class="line">    textAlign: &apos;center&apos;,</div><div class="line">    margin: 10,</div><div class="line">  &#125;,</div><div class="line">  instructions: &#123;</div><div class="line">    textAlign: &apos;center&apos;,</div><div class="line">    color: &apos;#333333&apos;,</div><div class="line">    marginBottom: 5,</div><div class="line">  &#125;,</div><div class="line">&#125;);</div><div class="line"></div><div class="line">AppRegistry.registerComponent(&apos;test&apos;, () =&gt; test);</div></pre></td></tr></table></figure>
<p>这里的timer多次赋值，虽然前面的值被后面的覆盖，但是前面的time仍然会起效果，如果不想前面的time work，需要clear掉，然后再赋值。</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">alertInfo(time)&#123;</div><div class="line">		this.timer &amp;&amp; clearTimeout(this.timer);</div><div class="line">      this.timer = setTimeout(</div><div class="line">          ()=&gt;&#123;</div><div class="line">            alert(&apos;hah&apos;);</div><div class="line">          &#125;,</div><div class="line">          time,</div><div class="line">      );</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>综上，使用time的注意点：</p>
<ol>
<li>记得unmount的时候，clear</li>
<li>多个timer要使用多个变量或者数组</li>
<li>多次赋值，记得把之前的值clear掉</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;time&lt;/code&gt;是&lt;code&gt;react-native&lt;/code&gt;提供的一个定时器，在实际使用中，经常会有使用不对，造成内存泄露的情况。很多&lt;code&gt;React Native&lt;/code&gt;应用发生致命错误（闪退）是与计时器有关。具体来说，是在某个组件被
    
    </summary>
    
      <category term="react-native" scheme="https://github.com/njafei/njafei.github.io/categories/react-native/"/>
    
    
      <category term="react-native" scheme="https://github.com/njafei/njafei.github.io/tags/react-native/"/>
    
      <category term="注意事项" scheme="https://github.com/njafei/njafei.github.io/tags/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>listView和FlatList的flexGrow默认值为1</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/07/26/listViewFlexGrowDefaultValue/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/07/26/listViewFlexGrowDefaultValue/</id>
    <published>2017-07-26T11:27:06.000Z</published>
    <updated>2017-10-19T03:37:16.728Z</updated>
    
    <content type="html"><![CDATA[<p>今天遇到了适配的问题，有个列表，需要自适应高度，按理说默认应该就是自适应的，但是在实际中发现，其会和另外一个视图1：1 ，然后就发现只有设置其<code>flexGrow: 0</code>的时候，它才会自动适配高度，说明它的flexGrow默认值为1.</p>
<p>看下具体的列子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">import &#123;</div><div class="line">  AppRegistry,</div><div class="line">  StyleSheet,</div><div class="line">  Text,</div><div class="line">  View,</div><div class="line">  ListView,</div><div class="line">&#125; from &apos;react-native&apos;;</div><div class="line"></div><div class="line">export default class testListView extends Component &#123;</div><div class="line">    constructor(props) &#123;</div><div class="line">        super(props);</div><div class="line">        const ds = new ListView.DataSource(&#123;rowHasChanged: (r1, r2) =&gt; r1 !== r2&#125;);</div><div class="line">        this.state = &#123;</div><div class="line">            dataSource: ds.cloneWithRows([</div><div class="line">                &apos;John&apos;, &apos;Joel&apos;, &apos;James&apos;, &apos;Jimmy&apos;, &apos;Jackson&apos;, &apos;Jillian&apos;, &apos;Julie&apos;, &apos;Devin&apos;</div><div class="line">            ])</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">        &lt;View style=&#123;styles.blackView&#125; /&gt;</div><div class="line">        &lt;ListView</div><div class="line">            dataSource=&#123;this.state.dataSource&#125;</div><div class="line">            renderRow=&#123;(rowData) =&gt; &lt;Text&gt;&#123;rowData&#125;&lt;/Text&gt;&#125;</div><div class="line">            style=&#123;styles.list&#125;</div><div class="line">        /&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line">  container: &#123;</div><div class="line">    flexGrow: 1,</div><div class="line">    backgroundColor: &apos;#F5FCFF&apos;,</div><div class="line">  &#125;,</div><div class="line">  list:&#123;</div><div class="line">    backgroundColor: &apos;red&apos;,</div><div class="line">  &#125;,</div><div class="line">  blackView: &#123;</div><div class="line">    flexGrow: 1,</div><div class="line">    backgroundColor: &apos;black&apos;,</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">AppRegistry.registerComponent(&apos;testListView&apos;, () =&gt; testListView);</div></pre></td></tr></table></figure>
<p>这个UI看起来是这样： </p>
<p><img src="http://on0hv7n2x.bkt.clouddn.com/Simulator%20Screen%20Shot%202017%E5%B9%B47%E6%9C%8826%E6%97%A5%20%E4%B8%8B%E5%8D%887.20.31.png" alt=""></p>
<p>如果style中的list改成这样，就好了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">list:&#123;</div><div class="line">    backgroundColor: &apos;red&apos;,</div><div class="line">    flexGrow: 0,  </div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>显示成： </p>
<p><img src="http://on0hv7n2x.bkt.clouddn.com/Simulator%20Screen%20Shot%202017%E5%B9%B47%E6%9C%8826%E6%97%A5%20%E4%B8%8B%E5%8D%887.21.58.png" alt=""></p>
<p>综上，我怀疑<code>FlatList和ListView</code>的<code>flexGrow</code>默认值是1.有遇到类似问题的，不妨试试这样解决。</p>
<p>版本： “react-native”: “0.43.4”</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天遇到了适配的问题，有个列表，需要自适应高度，按理说默认应该就是自适应的，但是在实际中发现，其会和另外一个视图1：1 ，然后就发现只有设置其&lt;code&gt;flexGrow: 0&lt;/code&gt;的时候，它才会自动适配高度，说明它的flexGrow默认值为1.&lt;/p&gt;
&lt;p&gt;看下
    
    </summary>
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/categories/React-Native/"/>
    
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/tags/React-Native/"/>
    
      <category term="奇怪的bug" scheme="https://github.com/njafei/njafei.github.io/tags/%E5%A5%87%E6%80%AA%E7%9A%84bug/"/>
    
  </entry>
  
  <entry>
    <title>如何访问和修改一个对象的私有属性</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/06/15/howToChangeObjectProperty/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/06/15/howToChangeObjectProperty/</id>
    <published>2017-06-15T10:03:36.000Z</published>
    <updated>2017-10-19T03:37:16.728Z</updated>
    
    <content type="html"><![CDATA[<p>有两个思路：</p>
<ul>
<li>KVC</li>
<li>runtime</li>
</ul>
<p>先给出我们接下来要使用的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@interface Person : NSObject</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@interface Person()</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *name;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Person</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h1 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h1><p>KVC是我比较推荐的，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Person *person = [Person new];</div><div class="line">    </div><div class="line">[person setValue:@&quot;new name&quot; forKey:@&quot;name&quot;];</div><div class="line"></div><div class="line">NSString *name = [person valueForKey:@&quot;name&quot;];</div></pre></td></tr></table></figure>
<p>KVC是苹果推荐用来做类似事情的方法，所以这种需求，KVC解决是最好的，代码简洁，效率也比较高。<br>关于KVC的相关内容可以看下<a href="https://njafei.github.io/2017/04/18/KVC/" target="_blank" rel="noopener">KVC详解</a></p>
<h1 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h1><p>runtime的思路就是先读取对象的所有属性，然后找到对象的属性，赋值。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Person *person = [Person new];</div><div class="line"></div><div class="line">unsigned int count = 0; //count记录变量的数量</div><div class="line"></div><div class="line">Ivar *members = class_copyIvarList([person class], &amp;count);</div><div class="line">for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">    Ivar ivar = members[i];</div><div class="line">    const char *memberName = ivar_getName(ivar);</div><div class="line">    NSString *memberNameString = [NSString stringWithFormat:@&quot;%s&quot;,memberName];</div><div class="line">    </div><div class="line">    if ([memberNameString isEqualToString: @&quot;_name&quot;]) &#123;</div><div class="line">        object_setIvar(person, ivar, @&quot;newName&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>runtime的做法相对来讲代码比较多，也不够简洁，但是还是可以实现这个需求的。runtime的详细内容可以参考<a href="https://njafei.github.io/2017/05/04/runtime/" target="_blank" rel="noopener">iOS Runtime 详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有两个思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;KVC&lt;/li&gt;
&lt;li&gt;runtime&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先给出我们接下来要使用的类：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/njafei/njafei.github.io/categories/iOS/"/>
    
    
      <category term="iOS面试题" scheme="https://github.com/njafei/njafei.github.io/tags/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Error RawText ** must be wrapped in an explicit &lt;Text&gt; component 问题解决</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/06/14/stringToBoolError/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/06/14/stringToBoolError/</id>
    <published>2017-06-14T03:05:55.000Z</published>
    <updated>2017-10-19T03:37:16.734Z</updated>
    
    <content type="html"><![CDATA[<p>今天忽然遇到一个页面崩溃，查到错误如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error: RawText &quot;&quot; must be wrapped in an explicit &lt;Text&gt; component.</div></pre></td></tr></table></figure>
<p>查了代码，发现好久都没有动这块的代码了，所以非常疑惑。最后通过2分法不停地查哪里出了问题，最终查到了这个语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">return (</div><div class="line">    &lt;View&gt;</div><div class="line">        &#123;test &amp;&amp; test.string &amp;&amp;</div><div class="line">        &lt;Text&gt;&#123;test.string&#125;&lt;/Text&gt;</div><div class="line">        &#125;</div><div class="line">    &lt;/View&gt;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>其实作用很简单，如果string有值，则展示string。但是这条语句为什么会报错呢？查了半天，发现是因为string的值是’’,然后系统就报错了，类似这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let test = &#123;string: &apos;&apos;&#125;;</div><div class="line">return (</div><div class="line">    &lt;View&gt;</div><div class="line">        &#123;test &amp;&amp; test.string &amp;&amp;</div><div class="line">        &lt;Text&gt;&#123;test.string&#125;&lt;/Text&gt;</div><div class="line">        &#125;</div><div class="line">    &lt;/View&gt;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>后来查了下github，发现很多人也遇到了类似的错误，解决办法如下,使用!!来判断string是否有值，因为这里其实你是希望将<code>string</code>当成<code>bool</code>来使用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let test = &#123;string: &apos;&apos;&#125;;</div><div class="line">return (</div><div class="line">    &lt;View&gt;</div><div class="line">        &#123;test &amp;&amp; !!test.string &amp;&amp;</div><div class="line">        &lt;Text&gt;&#123;test.string&#125;&lt;/Text&gt;</div><div class="line">        &#125;</div><div class="line">    &lt;/View&gt;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>所以以后string的判断，都用!!去判断，否则出现string恰好为’’的时候，就会崩溃。</p>
<p>参考文章：</p>
<ul>
<li><a href="https://github.com/GeekyAnts/NativeBase/issues/186">https://github.com/GeekyAnts/NativeBase/issues/186</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天忽然遇到一个页面崩溃，查到错误如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class
    
    </summary>
    
      <category term="bugFix" scheme="https://github.com/njafei/njafei.github.io/categories/bugFix/"/>
    
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/tags/React-Native/"/>
    
      <category term="奇怪的bug" scheme="https://github.com/njafei/njafei.github.io/tags/%E5%A5%87%E6%80%AA%E7%9A%84bug/"/>
    
  </entry>
  
  <entry>
    <title>block</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/06/13/block/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/06/13/block/</id>
    <published>2017-06-13T05:20:58.000Z</published>
    <updated>2017-10-19T03:37:16.726Z</updated>
    
    <content type="html"><![CDATA[<p>其实使用<code>block</code>的时间也蛮久了，比如使用<code>__block</code>,<code>weak</code>防止循环引用，<code>copy</code>修饰等注意点也都知道，但是一直没有去看过官方的文档，仔细看下所有的点。今天就把官方文档撸一遍，深入了解下。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>苹果在介绍<code>block</code>的使用场景时，是这么说的：</p>
<blockquote>
<p>You use a block when you want to create units of work (that is, code segments) that can be passed around as though they are values. Blocks offer more flexible programming and more power. </p>
</blockquote>
<p>当你想要做一连串的工作时（代码片段），block可以被当成值来传递，从而使程序更加灵活、易用。</p>
<p>我觉得，这个类似于<code>JS</code>的<code>callback</code>，这样写看起来比较直观，不像代理，满天飞，易读性不好。</p>
<h1 id="声明和使用"><a href="#声明和使用" class="headerlink" title="声明和使用"></a>声明和使用</h1><p>正常使用<code>block</code>类似于这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int multiplier = 7;</div><div class="line">int (^myBlock)(int) = ^(int num) &#123;</div><div class="line">    return num * multiplier;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>以前其实我自己在写block的时候，很容易迷糊，因为格式容易记不住，但是看了下面的图，仔细了解下它的结构，以后就好记了</p>
<p><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Blocks/Art/blocks.jpg" alt=""></p>
<p>首先是它的返回值，然后是它的name，接着是参数的类型，声明和实现结构是一样的，只是实现里面会多形参。</p>
<p>看下如何使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int multiplier = 7;</div><div class="line">int (^myBlock)(int) = ^(int num) &#123;</div><div class="line">    return num * multiplier;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">printf(&quot;%d&quot;, myBlock(3));</div><div class="line">// prints &quot;21&quot;</div></pre></td></tr></table></figure>
<p>在苹果提供<code>block</code>之后，它提供了大量的<code>block</code>的函数用法， 比较多的应该就是数据等的遍历。我们自己在写代码的时候，通常数据请求、alert等也都会封装成<code>block</code>的形式，因为真的是易读性比较好。</p>
<h1 id="block和变量"><a href="#block和变量" class="headerlink" title="block和变量"></a>block和变量</h1><p>在<code>block</code>中，是可以直接引用外部的变量的，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int a = 0;</div><div class="line">block(a);</div></pre></td></tr></table></figure>
<p>但是不能直接修改外部的变量，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int a = 0;</div><div class="line">block = ^(int a)&#123;</div><div class="line">	a = 5;//error</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="block"><a href="#block" class="headerlink" title="__block"></a>__block</h4><p>如果你想要在<code>block</code>中改变外部变量的值的话，需要使用<code>__block</code>来修饰，为什么这个关键词可以呢？我们来看下苹果的解释</p>
<blockquote>
<p>__block variables live in storage that is shared between the lexical scope of the variable and all blocks and block copies declared or created within the variable’s lexical scope. Thus, the storage will survive the destruction of the stack frame if any copies of the blocks declared within the frame survive beyond the end of the frame (for example, by being enqueued somewhere for later execution). Multiple blocks in a given lexical scope can simultaneously use a shared variable.</p>
<p>As an optimization, block storage starts out on the stack—just like blocks themselves do. If the block is copied using Block_copy (or in Objective-C when the block is sent a copy), variables are copied to the heap. Thus, the address of a __block variable can change over time.</p>
<p>There are two further restrictions on __block variables: they cannot be variable length arrays, and cannot be structures that contain C99 variable-length arrays.</p>
</blockquote>
<p><code>__block</code>会把变量放到<code>block</code>等的存在的内存中，这样在<code>block</code>存在期间，可以直接修改变量，不同的<code>block</code>都使用这个共享的变量。</p>
<p><code>block</code>默认是存在栈中的，但是如果<code>block</code>被拷贝，则会放到堆中</p>
<p><code>__block</code>有两个注意点，不能是可变化长度的数据，也不能是<a href="https://en.wikipedia.org/wiki/Variable-length_array" target="_blank" rel="noopener">C99标准可变长度的数组</a></p>
<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ol>
<li>为什么要用copy</li>
<li>为什么要避免循环引用，如何避免</li>
<li>避免两个错误模式</li>
</ol>
<h4 id="为什么要用copy"><a href="#为什么要用copy" class="headerlink" title="为什么要用copy"></a>为什么要用copy</h4><p>如上面所述，<code>block</code>默认是存在栈中的，但是如果<code>block</code>被拷贝，则会放到堆中，所以即使你使用strong，其实系统也是会copy一份的，用copy是为了让自己知道，这个<code>block</code>在使用中是会被copy一份的。那么，为什么呢？这因为如果<code>block</code>在栈中，则他的作用域就是栈中所在的作用域，如果在作用域外调用栈的内容，则会崩溃，所以要用copy，就会将其复制到堆中，调用就不会出现问题。当然，用strong也不会有任何问题，但是copy更能让我们使用的时候，知道使用的原因。</p>
<h4 id="循环引用，如何避免"><a href="#循环引用，如何避免" class="headerlink" title="循环引用，如何避免"></a>循环引用，如何避免</h4><p>先看下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">self.printBlock = ^(block)(NSString *) = ^(NSString *name)&#123;</div><div class="line">	[self print: name];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，self会对block强引用，而block中，又会对self强引用，所以系统在回收内存的时候，这两个对象都没有办法回收内存，就造成了内存的泄露了。</p>
<p>怎么避免呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">__weak typeof(self) weakself = self</div><div class="line">self.printBlock = ^(block)(NSString *) = ^(NSString *name)&#123;</div><div class="line">	__strong __typeof(self) strongSelf = weakSelf;//里面使用strong，防止执行block的时候 self被销毁</div><div class="line">	[weakself print: name];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="避免两个错误模式"><a href="#避免两个错误模式" class="headerlink" title="避免两个错误模式"></a>避免两个错误模式</h4><p>苹果在文档中，特意提了两个错误的模式，让大家不要使用，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">void dontDoThis() &#123;</div><div class="line">    void (^blockArray[3])(void);  // an array of 3 block references</div><div class="line"> </div><div class="line">    for (int i = 0; i &lt; 3; ++i) &#123;</div><div class="line">        blockArray[i] = ^&#123; printf(&quot;hello, %d\n&quot;, i); &#125;;</div><div class="line">        // WRONG: The block literal scope is the &quot;for&quot; loop.</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void dontDoThisEither() &#123;</div><div class="line">    void (^block)(void);</div><div class="line"> </div><div class="line">    int i = random():</div><div class="line">    if (i &gt; 1000) &#123;</div><div class="line">        block = ^&#123; printf(&quot;got i at: %d\n&quot;, i); &#125;;</div><div class="line">        // WRONG: The block literal scope is the &quot;then&quot; clause.</div><div class="line">    &#125;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两个用法本身是可以执行的，但是效率太差。本来block是内联的，所以应该先定义，再使用，而不是上文的用法，每次都重新定义一个。</p>
<p>PS： 内联函数的效率非常高，可以理解为内联是之前把代码片段嵌入到使用的地方，而非内联的函数就是要调用函数了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实使用&lt;code&gt;block&lt;/code&gt;的时间也蛮久了，比如使用&lt;code&gt;__block&lt;/code&gt;,&lt;code&gt;weak&lt;/code&gt;防止循环引用，&lt;code&gt;copy&lt;/code&gt;修饰等注意点也都知道，但是一直没有去看过官方的文档，仔细看下所有的点。今天就把官方
    
    </summary>
    
      <category term="iOS基础" scheme="https://github.com/njafei/njafei.github.io/categories/iOS%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Apple文档" scheme="https://github.com/njafei/njafei.github.io/tags/Apple%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>os.system如何传参</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/05/26/os-system%E5%A6%82%E4%BD%95%E4%BC%A0%E5%8F%82/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/05/26/os-system如何传参/</id>
    <published>2017-05-26T03:21:12.000Z</published>
    <updated>2017-10-19T07:34:08.201Z</updated>
    
    <content type="html"><![CDATA[<p>今天写脚本的时候，正好希望在python脚本中调用另外一个python脚本，就使用了os.system来实现这个功能（当然，还有很多的办法，而且每种方法满足的需求不都一样，有兴趣的读者可以谷歌下）。</p>
<p>但是我需要给这个调用里面传入一个参数，网上查了半天，感觉都不太清晰，就写了这篇，简单介绍下。</p>
<p>os.system的定义是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">os.system(&quot;shell command argusFormat&quot; % argus)</div></pre></td></tr></table></figure>
<p>在双引号里面正常写命令，需要用到参数的地方，使用%s等格式代替，然后在双引号的后面加空格，加%号，然后在括号里写入所有的参数，用逗号隔开。</p>
<h4 id="单个参数"><a href="#单个参数" class="headerlink" title="单个参数"></a>单个参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">param = &apos;I&apos;m param&apos;</div><div class="line">os.system(&quot;python haha.py %s&quot; % (param))</div></pre></td></tr></table></figure>
<h4 id="多个参数"><a href="#多个参数" class="headerlink" title="多个参数"></a>多个参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">paramA = &apos;I&apos;m paramA&apos;</div><div class="line">paramB = &apos;I&apos;m paramB&apos;</div><div class="line">os.system(&quot;python haha.py %s %s&quot; % (paramA,paramB))</div></pre></td></tr></table></figure>
<p>需要注意的是，shell中对于空格的要求特别严格，一定要注意别多或者少（写js的来写shell真的好难受0_0）。</p>
<h4 id="python格式化"><a href="#python格式化" class="headerlink" title="python格式化"></a>python格式化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">%s    字符串 (采用str()的显示)</div><div class="line"></div><div class="line">%r    字符串 (采用repr()的显示)</div><div class="line"></div><div class="line">%c    单个字符</div><div class="line"></div><div class="line">%b    二进制整数</div><div class="line"></div><div class="line">%d    十进制整数</div><div class="line"></div><div class="line">%i    十进制整数</div><div class="line"></div><div class="line">%o    八进制整数</div><div class="line"></div><div class="line">%x    十六进制整数</div><div class="line"></div><div class="line">%e    指数 (基底写为e)</div><div class="line"></div><div class="line">%E    指数 (基底写为E)</div><div class="line"></div><div class="line">%f    浮点数</div><div class="line"></div><div class="line">%F    浮点数，与上相同</div><div class="line"></div><div class="line">%g    指数(e)或浮点数 (根据显示长度)</div><div class="line"></div><div class="line">%G    指数(E)或浮点数 (根据显示长度)</div><div class="line"></div><div class="line">%%    字符&quot;%&quot;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天写脚本的时候，正好希望在python脚本中调用另外一个python脚本，就使用了os.system来实现这个功能（当然，还有很多的办法，而且每种方法满足的需求不都一样，有兴趣的读者可以谷歌下）。&lt;/p&gt;
&lt;p&gt;但是我需要给这个调用里面传入一个参数，网上查了半天，感觉都不
    
    </summary>
    
      <category term="python" scheme="https://github.com/njafei/njafei.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://github.com/njafei/njafei.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>ES6之字符串拓展</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/05/23/ES6%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%93%E5%B1%95/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/05/23/ES6之字符串拓展/</id>
    <published>2017-05-23T09:37:12.000Z</published>
    <updated>2017-10-19T03:37:16.720Z</updated>
    
    <content type="html"><![CDATA[<p>ES6中，还是对字符串做了很多的改进，尤其是函数方面，增加了很多个方法。但是核心的变动，其实只有两个：</p>
<ul>
<li><code>Unicode</code>拓展</li>
<li>字符模板</li>
</ul>
<h1 id="Unicode拓展"><a href="#Unicode拓展" class="headerlink" title="Unicode拓展"></a>Unicode拓展</h1><p>在讲ES6之间，我们先了解一些背景知识。</p>
<h4 id="为什么会出现Unicode"><a href="#为什么会出现Unicode" class="headerlink" title="为什么会出现Unicode"></a>为什么会出现Unicode</h4><p>我们知道，计算机最底层其实只能识别‘0’和‘1’，就是yes或者no。但是人脑是非常高级的，我们见面会打招呼“您吃了没？”，这句话如果是想告知计算机的话，它肯定是听不懂的，最后计算机接收的其实类似于：“01010101010001100111”的字符串。那么，当这些字符串通过QQ展示出来的时候，又要去展示对人脑友好的文字。“您吃了没？”和“01001010111”这样的字符串是如何对应的呢？</p>
<p>因为最初的计算机和技术都是美国发明的，所以他们首先提出了方案<code>ASCII</code>，即使用一个字节表示所有的字符和符号。比如：”00000001”表示”a”,”00000010”表示”b”(举例用，数值不对).这样，使用一个字节就解决了所有的英文展示问题。但是256足够表示所有的英文了，中文可没办法，或者其他语言，也不能够用。这样，就提出了<code>Unicode</code>的概念，希望所有的字符，全部都使用<code>Unicode</code>表示。</p>
<p><code>Unicode</code>的第一个版本是打算使用两个字节来表示所有的字符，比如1-200给英文，200-5000给中文等等，这样总共就有2^16次方个，基本足够了。（后来发现还是不够，<code>Unicode的第二个版本就使用4个字节，共2^32个</code>）</p>
<p>所有的字符都有一个数字对应的了，怎么保存呢？这里很多人容易搞错，因为<code>Unicode</code>提出了使用2个字节来表示所有字符，所以大家把<code>UTF16</code>和<code>Unicode</code>弄混淆了。应该说，<code>UTF16</code>来存储和<code>Unicode</code>真的是天作之合，因为两者都是使用两个字节。但是这样也出现了一个问题，比如如果一篇英文文章，他使用的字符段，都是一个字节就能表示出来了，使用2个字节表示，简直是浪费空间，所以又提出了<code>UTF8</code>，即使用1个字节存储，如果出现了需要两个字节的情况，想办法做兼容。</p>
<p>综上，我们说的<code>Unicode</code>是为了表示所有的字符的一种定义方法，而<code>UTF8</code>和<code>UTF16</code>是为了存储<code>Unicode</code>的一种方案。</p>
<p>这里如果比较有兴趣，可以看下博客<a href="http://www.cnblogs.com/kingcat/archive/2012/10/16/2726334.html" target="_blank" rel="noopener">Unicode(UTF-8, UTF-16)令人混淆的概念</a></p>
<h4 id="ES6做的拓展"><a href="#ES6做的拓展" class="headerlink" title="ES6做的拓展"></a>ES6做的拓展</h4><p>JS是支持直接展示<code>Unicode</code>的，比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(&quot;\u0061&quot;);//&quot;a&quot;;</div></pre></td></tr></table></figure>
<p>但是只限 \u0000 - \FFFF之间的，如果是 \u00001这样的，就不支持了。</p>
<p>而ES6对该点做了补充，可以直接使用了，如：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(&quot;\u&#123;00001&#125;&quot;);//使用大括号包含，和四字节的UTF16等价</div></pre></td></tr></table></figure>
<p> 还可以连接使用：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">conslle.log(&quot;\u&#123;1&#125;\u&#123;2&#125;&quot;);//&quot;ab&quot; 都是举例，对应字符串可能不对</div></pre></td></tr></table></figure>
<p> ES6中还补充了很多的函数，大家有兴趣，自己去翻下文档，这里简单罗列下：</p>
<ul>
<li>codePointAt(）</li>
<li>String.fromCodePoint()</li>
<li>at()</li>
<li>normalize()</li>
<li>includes()</li>
<li>startsWith()</li>
<li>endsWith()</li>
<li>repeat()</li>
</ul>
<h1 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h1><p>在JS中，如果我们想要表达一个含有变量的字符串，大概会这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let name = &quot;飞&quot;;</div><div class="line">let lunch = &quot;午饭&quot;;</div><div class="line">let ask = name + &quot;您吃&quot; + lunch + &quot;吗？&quot;;//飞您吃午饭了吗？</div></pre></td></tr></table></figure>
<p>不得不说，这样写，比较丑。</p>
<h4 id="模板字符串-1"><a href="#模板字符串-1" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>ES6中使用字符模板解决了这个问题，让你可以拼接字符串的时候用的更爽。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let name = &quot;飞&quot;;</div><div class="line">let lunch = &quot;午饭&quot;;</div><div class="line">let ask =  `$&#123;name&#125;您吃$&#123;lunch&#125;吗?`; //您吃午饭了吗？</div></pre></td></tr></table></figure>
<p>是不是优雅多了呢？</p>
<p>另外模板字符串还会记录空格、换行等字符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">let ask =  `飞，</div><div class="line">我今天，</div><div class="line">好</div><div class="line">饿</div><div class="line">啊</div><div class="line">`</div></pre></td></tr></table></figure>
<p>打印出来就是：</p>
<pre><code>飞，
我今天，
好
饿
啊
</code></pre><p>再也不用各种空格符号和换行符号了。</p>
<h4 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h4><p>另外还有一个值得注意的地方，就是标签模板，即在“``”前面，将其变为一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">functionName`$&#123;name&#125;,您吃$&#123;lunch&#125;了吗？`</div></pre></td></tr></table></figure>
<p>其实就等同于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">functionName functionName(stringArr,...value)&#123;&#125;;</div></pre></td></tr></table></figure>
<p>stringArr就是模板里的不变的值：“,您吃了吗？”<br>而…value就是里面的变量：${name} 和 ${lunch}.</p>
<p>书上和其他的blog上面都说是可以用做字符串检查，类似于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function SaferHTML(templateData) &#123;</div><div class="line">  var s = templateData[0];</div><div class="line">  for (var i = 1; i &lt; arguments.length; i++) &#123;</div><div class="line">    var arg = String(arguments[i]);</div><div class="line">    // Escape special characters in the substitution.</div><div class="line">    s += arg.replace(/&amp;/g, &quot;&amp;amp;&quot;)</div><div class="line">            .replace(/&lt;/g, &quot;&amp;lt;&quot;)</div><div class="line">            .replace(/&gt;/g, &quot;&amp;gt;&quot;);</div><div class="line">    // Don&apos;t escape special characters in the template.</div><div class="line">    s += templateData[i];</div><div class="line">  &#125;</div><div class="line">  return s;</div><div class="line">&#125;</div><div class="line">// 调用</div><div class="line">var html = SaferHTML`&lt;p&gt;这是关于字符串模板的介绍&lt;/p&gt;`;</div></pre></td></tr></table></figure>
<p>能让你写的代码更优雅一些，算是字符串模板的拓展。</p>
<p>综上，实际使用的话，<code>Unicode</code>其实用的真的不多，但是字符串模板还是应该多关注下，能用尽量用，毕竟，使代码更优雅是每个程序员的最求。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6中，还是对字符串做了很多的改进，尤其是函数方面，增加了很多个方法。但是核心的变动，其实只有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Unicode&lt;/code&gt;拓展&lt;/li&gt;
&lt;li&gt;字符模板&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Unicode拓展&quot;&gt;&lt;a hr
    
    </summary>
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/tags/ES6/"/>
    
      <category term="JavaScript" scheme="https://github.com/njafei/njafei.github.io/tags/JavaScript/"/>
    
      <category term="react-native" scheme="https://github.com/njafei/njafei.github.io/tags/react-native/"/>
    
  </entry>
  
</feed>
