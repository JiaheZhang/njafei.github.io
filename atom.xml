<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>njafei&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/njafei/njafei.github.io/"/>
  <updated>2018-03-23T08:35:49.468Z</updated>
  <id>https://github.com/njafei/njafei.github.io/</id>
  
  <author>
    <name>njafei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>URL协议详解</title>
    <link href="https://github.com/njafei/njafei.github.io/2018/03/23/URL/"/>
    <id>https://github.com/njafei/njafei.github.io/2018/03/23/URL/</id>
    <published>2018-03-23T08:31:14.000Z</published>
    <updated>2018-03-23T08:35:49.468Z</updated>
    
    <content type="html"><![CDATA[<p>我们目前使用的诸如：<code>http://www.baidu.com</code>或者<code>ftp://192.168.1.1</code>等链接，都是URL标准的一个实例。URL全称Uniform Resource Locators(通用资源定位器),标注名称为<a href="http://www.ietf.org/rfc/rfc1738.txt" target="_blank" rel="noopener">rfc1738</a>。</p>
<h1 id="URL的组成部分"><a href="#URL的组成部分" class="headerlink" title="URL的组成部分"></a>URL的组成部分</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;scheme&gt;:&lt;scheme-specific-part&gt;</div></pre></td></tr></table></figure>
<p>URL被冒号分成了两部分，前面是scheme(方案)，后面是scheme的描述部分</p>
<h2 id="scheme"><a href="#scheme" class="headerlink" title="scheme"></a>scheme</h2><p>scheme只能由以下元素组成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a-z(不区分大小写)</div><div class="line">数字</div><div class="line">字符： 加号+ 句号.  连字符-</div></pre></td></tr></table></figure>
<p>shceme目前有这些类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> ftp                     File Transfer protocol（文件传输协议）</div><div class="line"> http                    Hypertext Transfer Protocol（超文本传输协议）</div><div class="line"> gopher                  The Gopher protocol（Gopher协议）</div><div class="line"> mailto                  Electronic mail address（电子邮件地址）</div><div class="line"> news                    USENET news（USENET新闻）</div><div class="line"> nntp                    USENET news using NNTP access</div><div class="line">                        （使用NNTP访问的USENET新闻）</div><div class="line"> telnet                  Reference to interactive sessions</div><div class="line">（交互式会话访问）</div><div class="line"> wais                    Wide Area Information Servers（广域信息服务系统）</div><div class="line"> file                    Host-specific file names（特殊主机文件名）</div><div class="line"> prospero                Prospero Directory Service(prospero目录服务)</div></pre></td></tr></table></figure>
<p>当然，上述的scheme大部分是应用非常广泛的，我们可以自定义scheme，只要解析器支持即可，比如我们公司就根据URL设计了一条App跳转专用的URL，方便服务器分发跳转路径。</p>
<h2 id="scheme描述部分"><a href="#scheme描述部分" class="headerlink" title="scheme描述部分"></a>scheme描述部分</h2><p>scheme的描述部分也可以拆解成以下的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;url-path&gt;</div></pre></td></tr></table></figure>
<p>根据方案的不同，这些部分是可以部分省略的，比如<code>http</code>通常不需要user和password</p>
<p>我们来依次看这些组成部分：</p>
<h3 id="user"><a href="#user" class="headerlink" title="user"></a>user</h3><p>这个比较好理解，就是用户名，没有则省略</p>
<h3 id="password"><a href="#password" class="headerlink" title="password"></a>password</h3><p>用户密码</p>
<h3 id="host"><a href="#host" class="headerlink" title="host"></a>host</h3><p>host(主机)是一个IP地址，由四组十进制数字以<code>.</code>分割组合而成。现在很多对客的地址都是用了域名，然后再通过DNS解析.DNS可以理解为将难以记住的ip地址和单词等组成的域名做映射，从而方便用户的使用。记住<code>https://www.baidu.com</code>可比记住<code>192.292.22.22</code>容易多了。很多的公司在使用的时候也会做DNS优化，即客户端等发出请求的时候，直接向对应的ip发送，从而节省DNS解析的时间，加快用户访问速度，有兴趣的可以网络搜索下。</p>
<h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><p>port(端口)是用来区分不同的网络服务的，从而实现在一个IP的基础上，提供多个网络服务。</p>
<h3 id="url-path"><a href="#url-path" class="headerlink" title="url-path"></a>url-path</h3><p>url路径提供了如何对特定资源访问的详细信息，一般都是文件夹的路径</p>
<h1 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h1><p>URL会使用编码，因为很多字符是不安全的，比如空格，在被转录或者排版的时候，可能会被忽略。”&lt;”和”&gt;”也是不安全的，因为他们被用来作为URL在文本中的分割符。<code>#</code>,<code>/</code>,<code>~</code>,<code>[</code>,<code>]</code>等也都会在不同的场景下给URL的解析带来问题，所以要对不安全的字符进行编码。通常是进行ecode。</p>
<p>总结，本文介绍了URL的组成部分，各部分的用法和使用场景，URL的编码原因等知识。</p>
<h1 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h1><ul>
<li><a href="http://www.ietf.org/rfc/rfc1738.txt" target="_blank" rel="noopener">rfc1738</a></li>
<li><a href="http://www.cppblog.com/woaidongmao/archive/2008/12/28/70569.html" target="_blank" rel="noopener">RFC1738 - 统一资源定位器URL</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们目前使用的诸如：&lt;code&gt;http://www.baidu.com&lt;/code&gt;或者&lt;code&gt;ftp://192.168.1.1&lt;/code&gt;等链接，都是URL标准的一个实例。URL全称Uniform Resource Locators(通用资源定位器),标注名称为
    
    </summary>
    
      <category term="底层协议知识" scheme="https://github.com/njafei/njafei.github.io/categories/%E5%BA%95%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="URL" scheme="https://github.com/njafei/njafei.github.io/tags/URL/"/>
    
  </entry>
  
  <entry>
    <title>Node学习 Lesson1 使用express</title>
    <link href="https://github.com/njafei/njafei.github.io/2018/03/23/NodeLearnLession1/"/>
    <id>https://github.com/njafei/njafei.github.io/2018/03/23/NodeLearnLession1/</id>
    <published>2018-03-23T06:54:43.000Z</published>
    <updated>2018-03-23T06:55:36.633Z</updated>
    
    <content type="html"><![CDATA[<p>初始化项目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm init</div></pre></td></tr></table></figure>
<p>安装express，安装有两个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install express --save //方法一：直接安装，并将配置保存在package.json</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">修改package.josn,增加express及版本信息</div><div class="line">npm install</div></pre></td></tr></table></figure>
<p>创建文件app.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">touch app.js</div><div class="line">open app.js</div></pre></td></tr></table></figure>
<p>写入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var express = require(&apos;express&apos;);</div><div class="line"></div><div class="line">var app = express();</div><div class="line"></div><div class="line">app.get(&apos;/&apos;,function(req, res)&#123;</div><div class="line">    res.send(&apos;hello world&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.listen(3000, function ()&#123;</div><div class="line">    console.log(&apos;app is listening ar port 3000&apos;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>执行node：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node app.js</div></pre></td></tr></table></figure>
<p>在浏览器输入<code>localhost:3000</code>，看到上面有打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hello,world</div></pre></td></tr></table></figure>
<p>课程地址：<a href="https://github.com/alsotang/node-lessons/tree/master/lesson1">《一个最简单的 express 应用》</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初始化项目：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;
    
    </summary>
    
      <category term="NodeLearn" scheme="https://github.com/njafei/njafei.github.io/categories/NodeLearn/"/>
    
    
      <category term="Node" scheme="https://github.com/njafei/njafei.github.io/tags/Node/"/>
    
      <category term="NodeLearn" scheme="https://github.com/njafei/njafei.github.io/tags/NodeLearn/"/>
    
  </entry>
  
  <entry>
    <title>nvm安装、解决nvm command not found问题、卸载</title>
    <link href="https://github.com/njafei/njafei.github.io/2018/03/23/nvm-install/"/>
    <id>https://github.com/njafei/njafei.github.io/2018/03/23/nvm-install/</id>
    <published>2018-03-23T03:15:14.000Z</published>
    <updated>2018-03-23T03:24:13.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>nvm是node的包版本管理工具，github地址如下：<a href="https://github.com/creationix/nvm">nvm</a></p>
<p>安装命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nvm //检查nvm是否安装成功</div><div class="line"></div><div class="line">-bash: nvm: command not found  //boom，失败了</div></pre></td></tr></table></figure>
<h1 id="解决nvm-command-not-found问题"><a href="#解决nvm-command-not-found问题" class="headerlink" title="解决nvm command not found问题"></a>解决<code>nvm command not found</code>问题</h1><p>进入<code>.nvm</code>文件夹，新建<code>.bash_profile</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">touch .bash_profile //新建文件</div><div class="line">open .bash_profile //打开文件</div></pre></td></tr></table></figure>
<p>在里面copy如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export NVM_DIR=&quot;$HOME/.nvm&quot;</div><div class="line">[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm</div></pre></td></tr></table></figure>
<p>关闭文件，然后执行这个文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source .bash_profile</div></pre></td></tr></table></figure>
<p>执行完毕，我们再看看是否安装成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm --version</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0.33.8</div></pre></td></tr></table></figure>
<p>安装成功。</p>
<h1 id="卸载："><a href="#卸载：" class="headerlink" title="卸载："></a>卸载：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ nvm use system</div><div class="line">$ npm uninstall -g a_module</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;p&gt;nvm是node的包版本管理工具，github地址如下：&lt;a href=&quot;https://github.com/creationix/nvm
    
    </summary>
    
      <category term="node" scheme="https://github.com/njafei/njafei.github.io/categories/node/"/>
    
    
      <category term="nvm" scheme="https://github.com/njafei/njafei.github.io/tags/nvm/"/>
    
      <category term="node" scheme="https://github.com/njafei/njafei.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>JS module输出原理</title>
    <link href="https://github.com/njafei/njafei.github.io/2018/03/22/nodeJS-module/"/>
    <id>https://github.com/njafei/njafei.github.io/2018/03/22/nodeJS-module/</id>
    <published>2018-03-22T10:04:20.000Z</published>
    <updated>2018-03-22T10:08:00.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="module输出写法"><a href="#module输出写法" class="headerlink" title="module输出写法"></a>module输出写法</h1><p>为了能够复用一些基本功能，我们通常会将其封装在module中。类似这样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//greet.js</div><div class="line">&apos;use strict&apos;;</div><div class="line"></div><div class="line">var s = &apos;Hello&apos;;</div><div class="line"></div><div class="line">function greet(name) &#123;</div><div class="line">    console.log(s + &apos;, &apos; + name + &apos;!&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">module.exports = greet;</div></pre></td></tr></table></figure>
<p>我们也会看到其他的写法，这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;;</div><div class="line"></div><div class="line">exports.foo = &apos;foo&apos;;</div></pre></td></tr></table></figure>
<p>直接通过exports的属性来输出的，这样看起来其实很迷惑人，比如我第一次就有疑惑：</p>
<ul>
<li>module不是模块的意思吗？ 为什么要使用module.exports的赋值来输出？</li>
<li>为什么有时候是exports来赋值输出</li>
<li>其他的地方，是如何使用我的模块呢？</li>
<li>为什么export有些可以输出多个值呢? 比如： modelu.exports = {foo: foo, tool: tool}</li>
</ul>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>这里其实是module在默默地做了一些事情，它会在代码中植入类似这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var module = &#123;</div><div class="line">	id: &apos;greet&apos;,</div><div class="line">	exports: &#123;&#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports = moduel.exports;</div><div class="line"></div><div class="line">load(module.exports, module);</div></pre></td></tr></table></figure>
<p>这样，我们就知道了为什么<code>exports</code>和<code>module.exports</code>都可以作为模块的输出。</p>
<p>这里还要一个要注意的，之所以可以用<code>exports</code>来输出，是因为它指向了<code>module.exports</code>. 所以当<code>exports</code>的指针被修改的时候，这样用就会出问题了。</p>
<p>如果输出是一个数组，或者函数，则两者是不等价的，看下面的例子：</p>
<p>例子一： 等价的输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;foo: &apos;foo&apos;&#125;;</div><div class="line"></div><div class="line">exports.foo = &apos;foo&apos;;</div></pre></td></tr></table></figure>
<p>例子而： 不等价输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">module.exports = function greet()&#123;console.log(&apos;greet&apos;)&#125;;//这时 module.exports指向greet函数</div><div class="line"></div><div class="line">exports = function greet()&#123;console.log(&apos;greet&apos;)&#125;;//这时，exoprts的指针指向greet函数，而module.exports仍然指向&#123;&#125;</div><div class="line"></div><div class="line"></div><div class="line">这里两种方式不等价，主要是因为原来都指向同一个变量，而如果赋值是数据，函数等，则export会改变指针的值。然后最终输出的还是module.exports， 所以在这里，模块的输出就不可以用export</div></pre></td></tr></table></figure>
<p>廖雪峰的博客说是建议全部使用<code>module.exports</code>，这样可以避免混淆。我的建议是大家最好搞清楚原理，这样使用起来才知其所以然。</p>
<p>ok，总结这篇文章，主要是讲了模块(module)的输出原理，为什么有两种写法，为什么每种写法都可以work，两种写法的区别和使用时机。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434502419592fd80bbb0613a42118ccab9435af408fd000" target="_blank" rel="noopener">廖雪峰 JS教程-模块</a></li>
<li><a href="http://cnodejs.org/topic/5231a630101e574521e45ef8" target="_blank" rel="noopener">exports 和 module.exports 的区别</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;module输出写法&quot;&gt;&lt;a href=&quot;#module输出写法&quot; class=&quot;headerlink&quot; title=&quot;module输出写法&quot;&gt;&lt;/a&gt;module输出写法&lt;/h1&gt;&lt;p&gt;为了能够复用一些基本功能，我们通常会将其封装在module中。类似这样子：&lt;
    
    </summary>
    
      <category term="Node" scheme="https://github.com/njafei/njafei.github.io/categories/Node/"/>
    
    
      <category term="Node" scheme="https://github.com/njafei/njafei.github.io/tags/Node/"/>
    
      <category term="module" scheme="https://github.com/njafei/njafei.github.io/tags/module/"/>
    
  </entry>
  
  <entry>
    <title>JS 静态类型检查 PropTypes</title>
    <link href="https://github.com/njafei/njafei.github.io/2018/03/20/JS-PropTypes/"/>
    <id>https://github.com/njafei/njafei.github.io/2018/03/20/JS-PropTypes/</id>
    <published>2018-03-20T06:17:26.000Z</published>
    <updated>2018-03-20T06:18:10.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>JS</code>作为弱类型语言，有时候也会带来很多麻烦，比如需要的参数是<code>Number</code>，而使用方传了<code>String</code>，虽然我们可以通过参数的检查来return掉，但是这样也带来了很多繁琐的步骤。为了避免类似的问题，<code>JS</code>提供了类型检查工具PropTypes，在<code>React V15.5</code>之前，可以直接使用<code>React.PropTypes</code>助手函数，之后则提供了npm包<code>prop-types</code>。</p>
<p>注意，处于性能原因，<code>propTypes</code>仅会在dev模式中work，如果发现类型和定义的不一致，会通过warning来提示。</p>
<p>以下是官网的例子，基本上够用了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">import PropTypes from &apos;prop-types&apos;;</div><div class="line"></div><div class="line">MyComponent.propTypes = &#123;</div><div class="line">  // 你可以声明一个 prop 是一个特定的 JS 原始类型。 </div><div class="line">  // 默认情况下，这些都是可选的。</div><div class="line">  optionalArray: PropTypes.array,</div><div class="line">  optionalBool: PropTypes.bool,</div><div class="line">  optionalFunc: PropTypes.func,</div><div class="line">  optionalNumber: PropTypes.number,</div><div class="line">  optionalObject: PropTypes.object,</div><div class="line">  optionalString: PropTypes.string,</div><div class="line">  optionalSymbol: PropTypes.symbol,</div><div class="line"></div><div class="line">  // 任何东西都可以被渲染:numbers, strings, elements,或者是包含这些类型的数组(或者是片段)。</div><div class="line">  optionalNode: PropTypes.node,</div><div class="line"></div><div class="line">  // 一个 React 元素。</div><div class="line">  optionalElement: PropTypes.element,</div><div class="line"></div><div class="line">  // 你也可以声明一个 prop 是类的一个实例。 </div><div class="line">  // 使用 JS 的 instanceof 运算符。</div><div class="line">  optionalMessage: PropTypes.instanceOf(Message),</div><div class="line"></div><div class="line">  // 你可以声明 prop 是特定的值，类似于枚举</div><div class="line">  optionalEnum: PropTypes.oneOf([&apos;News&apos;, &apos;Photos&apos;]),</div><div class="line"></div><div class="line">  // 一个对象可以是多种类型其中之一</div><div class="line">  optionalUnion: PropTypes.oneOfType([</div><div class="line">    PropTypes.string,</div><div class="line">    PropTypes.number,</div><div class="line">    PropTypes.instanceOf(Message)</div><div class="line">  ]),</div><div class="line"></div><div class="line">  // 一个某种类型的数组</div><div class="line">  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),</div><div class="line"></div><div class="line">  // 属性值为某种类型的对象</div><div class="line">  optionalObjectOf: PropTypes.objectOf(PropTypes.number),</div><div class="line"></div><div class="line">  // 一个特定形式的对象</div><div class="line">  optionalObjectWithShape: PropTypes.shape(&#123;</div><div class="line">    color: PropTypes.string,</div><div class="line">    fontSize: PropTypes.number</div><div class="line">  &#125;),</div><div class="line"></div><div class="line">  // 你可以使用 `isRequired&apos; 链接上述任何一个，以确保在没有提供 prop 的情况下显示警告。</div><div class="line">  requiredFunc: PropTypes.func.isRequired,</div><div class="line"></div><div class="line">  // 任何数据类型的值</div><div class="line">  requiredAny: PropTypes.any.isRequired,</div><div class="line"></div><div class="line">  // 你也可以声明自定义的验证器。如果验证失败返回 Error 对象。不要使用 `console.warn` 或者 throw ，</div><div class="line">  // 因为这不会在 `oneOfType` 类型的验证器中起作用。</div><div class="line">  customProp: function(props, propName, componentName) &#123;</div><div class="line">    if (!/matchme/.test(props[propName])) &#123;</div><div class="line">      return new Error(</div><div class="line">        &apos;Invalid prop `&apos; + propName + &apos;` supplied to&apos; +</div><div class="line">        &apos; `&apos; + componentName + &apos;`. Validation failed.&apos;</div><div class="line">      );</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  // 也可以声明`arrayOf`和`objectOf`类型的验证器，如果验证失败需要返回Error对象。</div><div class="line">  // 会在数组或者对象的每一个元素上调用验证器。验证器的前两个参数分别是数组或者对象本身，</div><div class="line">  // 以及当前元素的键值。</div><div class="line">  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123;</div><div class="line">    if (!/matchme/.test(propValue[key])) &#123;</div><div class="line">      return new Error(</div><div class="line">        &apos;Invalid prop `&apos; + propFullName + &apos;` supplied to&apos; +</div><div class="line">        &apos; `&apos; + componentName + &apos;`. Validation failed.&apos;</div><div class="line">      );</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="默认值指定"><a href="#默认值指定" class="headerlink" title="默认值指定"></a>默认值指定</h2><p>除了能指定参数的类型，还可以指定参数的默认值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Greeting extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 指定 props 的默认值：</div><div class="line">Greeting.defaultProps = &#123;</div><div class="line">  name: &apos;Stranger&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 渲染为 &quot;Hello, Stranger&quot;:</div><div class="line">ReactDOM.render(</div><div class="line">  &lt;Greeting /&gt;,</div><div class="line">  document.getElementById(&apos;example&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>只有当指定的props为undefined的时候，才会使用默认值，如果参数有，但是不符合类型检查，也会使用该参数，而不是使用默认值。</p>
<p>propTypes 的类型检测是在defaultProps 解析之后发生的，因此也会对默认属性 defaultProps 进行类型检测。</p>
<h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p>整体是这样的流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//step1 check defaultProps</div><div class="line">if (参数为undefined)&#123;</div><div class="line">	if (有默认值)&#123;</div><div class="line">		使用默认参数</div><div class="line">	&#125; else &#123;</div><div class="line">		使用undefined</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//step2 check type</div><div class="line">if (不符合类型检查)&#123;</div><div class="line">		警告（）</div><div class="line">	&#125;</div><div class="line">	使用该参数值</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果需要更强大的拓展，可以使用<code>Flow</code> 或者 <code>TypeScript</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.css88.com/react/docs/typechecking-with-proptypes.html" target="_blank" rel="noopener">使用 PropTypes 进行类型检查
</a></li>
<li><a href="https://www.npmjs.com/package/prop-types" target="_blank" rel="noopener">prop-types </a></li>
<li><a href="https://flow.org/en/docs/types/" target="_blank" rel="noopener">Flow</a></li>
<li><a href="https://www.typescriptlang.org/" target="_blank" rel="noopener">TypeScript</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h2&gt;&lt;p&gt;&lt;code&gt;JS&lt;/code&gt;作为弱类型语言，有时候也会带来很多麻烦，比如需要的参数是&lt;code&gt;Number&lt;/code&gt;
    
    </summary>
    
      <category term="JS" scheme="https://github.com/njafei/njafei.github.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://github.com/njafei/njafei.github.io/tags/JS/"/>
    
      <category term="PropTypes" scheme="https://github.com/njafei/njafei.github.io/tags/PropTypes/"/>
    
  </entry>
  
  <entry>
    <title>JS Event-Loop</title>
    <link href="https://github.com/njafei/njafei.github.io/2018/03/19/JS-EventLoop/"/>
    <id>https://github.com/njafei/njafei.github.io/2018/03/19/JS-EventLoop/</id>
    <published>2018-03-19T09:44:39.000Z</published>
    <updated>2018-03-19T09:51:16.670Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看<code>JavaScript</code>的<code>Generator</code>、<code>Promise</code>等实现异步的方法。对于一直用<code>Objective-C</code>编程的我来说，是有些云里雾里。故查了些资料，了解相关的内容，遂有此文。</p>
<h2 id="为什么JavaScript是单线程的语言"><a href="#为什么JavaScript是单线程的语言" class="headerlink" title="为什么JavaScript是单线程的语言"></a>为什么<code>JavaScript</code>是单线程的语言</h2><p>首先，我们要解释下，<code>JS</code>是单线程的，并不是说<code>JS</code>中只有一个线程，而是在<code>JS</code>引擎中负责解释和执行<code>JS</code>语句的线程只有一个，我们称之为主线程。</p>
<p>在<code>JS</code>中，还是有很多其他线程存在的，比如：处理DOM事件的线程，定时器线程，IO线程等。</p>
<p>为什么<code>JS</code>中只有一个线程呢？ 这里要说下<code>JS</code>诞生的背景，它是浏览器中执行脚本的语言，主要用途是和用户交互，为了提升体验，避免多线程带来的同步等问题，简化整个模型，采用了单线程。（<code>Objective-C</code>也是为了交互而生，但是并没有采用单线程，而是支持多线程，我个人觉得这个更多是设计思想的选择，而<code>JS</code>这样设计确实带来了更简单的模式）</p>
<blockquote>
<p>在HTML5中，提出了Web Worker标准，允许JS创建多个线程,但是规定子线程受主线程控制，且不能操作DOM。</p>
</blockquote>
<h2 id="JS任务管理"><a href="#JS任务管理" class="headerlink" title="JS任务管理"></a><code>JS</code>任务管理</h2><p>我们先看一张图，了解下<code>JS</code>中是如何管理和执行任务的：</p>
<p><img src="https://developer.mozilla.org/files/4617/default.svg" alt=""></p>
<p>这里分为三个区域：</p>
<ul>
<li>执行栈（主线程）</li>
<li>任务队列（其他线程）</li>
<li>堆 （对象）</li>
</ul>
<h3 id="主线程任务执行栈"><a href="#主线程任务执行栈" class="headerlink" title="主线程任务执行栈"></a>主线程任务执行栈</h3><p>  主线程的任务使用栈来实现任务执行和调用，这里用栈是因为栈的结构方便实现函数调用顺序的管理。<br>  这里简单举个例子：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> 	let funcA = (x) =&gt; &#123;</div><div class="line">	return x * 2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let funcB = (x) =&gt; &#123;</div><div class="line">	return x + 2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">console.log(funcB(funcA(2)));</div></pre></td></tr></table></figure>
<p>  栈中执行顺序就是</p>
<ul>
<li>funcA</li>
<li>funcB</li>
<li>console.log</li>
</ul>
<h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>每当遇到需要异步执行的任务（请求网络、IO等），JS不会阻塞等待结果，而是往下面执行，当异步的任务执行了之后，系统发送通知出来，然后等待主线程任务栈执行完毕后，执行这些异步回调。</p>
<p>流程如图,就是所谓的<code>Event Loop</code></p>
<p><img src="http://on0hv7n2x.bkt.clouddn.com/JS%20eventLoop%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt=""></p>
<p>注意，这里即使异步的任务很快执行完毕，也会等到执行栈中的任务执行完毕后，才执行，这里用<code>setTimeout</code>来举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">console.log(1);</div><div class="line">setTimeout(()=&gt;&#123;console.log(2)&#125;,0)</div><div class="line">console.log(3);</div></pre></td></tr></table></figure>
<p>这里虽然延迟是0ms，但是输出依然是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">3</div><div class="line">2</div></pre></td></tr></table></figure>
<p>所以setTimeout等的延迟时间，其实是不准确的，如果主线程一直很忙，是不会执行到的。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>这里堆就是用来管理系统中的对象，大部分的语言应该都是使用堆来管理对象（我知道的），这里就不多解释。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要是介绍了<code>JS</code>为什么采用了单线程的思想，然后介绍了<code>JS</code>中是如何任务管理是如何通过主线程+任务队列的方式来实现，从而实现了<code>Event Loop</code>。</p>
<h2 id="参考内容："><a href="#参考内容：" class="headerlink" title="参考内容："></a>参考内容：</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF" target="_blank" rel="noopener">并发模型与事件循环</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop
</a></li>
<li><a href="https://segmentfault.com/a/1190000004322358" target="_blank" rel="noopener">JavaScript：彻底理解同步、异步和事件循环(Event Loop)</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看&lt;code&gt;JavaScript&lt;/code&gt;的&lt;code&gt;Generator&lt;/code&gt;、&lt;code&gt;Promise&lt;/code&gt;等实现异步的方法。对于一直用&lt;code&gt;Objective-C&lt;/code&gt;编程的我来说，是有些云里雾里。故查了些资料，了解相关的内
    
    </summary>
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6之Map</title>
    <link href="https://github.com/njafei/njafei.github.io/2018/02/28/ES6-Map/"/>
    <id>https://github.com/njafei/njafei.github.io/2018/02/28/ES6-Map/</id>
    <published>2018-02-28T06:09:25.000Z</published>
    <updated>2018-02-28T06:12:15.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>在js中，对象(Object)的本质是键值对，但是它的键只能是字符串，这带来了很多不便。为了解决这个问题，ES6中提供了新的数据结构，Map。 Map和Object最大的区别就是它的key可以是对象。</p>
<p>看下初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let map = new Map();</div><div class="line">let obj = [&quot;a&quot;, &quot;b&quot;];</div><div class="line">map.set(obj, &quot;content&quot;);</div><div class="line">map.get(obj);// &quot;content&quot;</div></pre></td></tr></table></figure>
<p>map还可以用数组为参数直接初始化，要求数组中的元素都是标志键值对的数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let map = new Map([[&quot;key1&quot;, &quot;value1&quot;],[[&quot;key2&quot;], &quot;value2&quot;]]);</div></pre></td></tr></table></figure>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>因为map和object是如此的相似，本文不再介绍set、get、has、遍历等方法，需要的话直接看下官网API即可。这里提下注意事项，因为key可以是对象了，所以如果key是对象，map寻找key依据key的内存地址，如果是简单类型，还是根据值。</p>
<p>看下例子： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let map = new Map();</div><div class="line">let key3 = [&quot;a&quot;];</div><div class="line"></div><div class="line">map.set(&quot;a&quot;,1);</div><div class="line">map.set([&quot;a&quot;],1);</div><div class="line">map.set(key3,1);</div><div class="line"></div><div class="line">console.log(map.get(&quot;a&quot;)); // 1 </div><div class="line">console.log(map.get([&quot;a&quot;])); // undefined</div><div class="line">console.log(map.get(key3)); // 1</div></pre></td></tr></table></figure>
<h2 id="weakMap"><a href="#weakMap" class="headerlink" title="weakMap"></a>weakMap</h2><p>weakMap和weakSet有相似之处，都是为了防止内存泄露而设计，key必须是对象，也只对元素弱引用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h2&gt;&lt;p&gt;在js中，对象(Object)的本质是键值对，但是它的键只能是字符串，这带来了很多不便。为了解决这个问题，ES6中提供了新的
    
    </summary>
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/tags/ES6/"/>
    
      <category term="Map" scheme="https://github.com/njafei/njafei.github.io/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>ES6之Set</title>
    <link href="https://github.com/njafei/njafei.github.io/2018/02/28/ES6-Set/"/>
    <id>https://github.com/njafei/njafei.github.io/2018/02/28/ES6-Set/</id>
    <published>2018-02-28T05:44:04.000Z</published>
    <updated>2018-02-28T05:44:56.416Z</updated>
    
    <content type="html"><![CDATA[<p>在ES6中，提供了新的数据结构set，set类似于数组，但是其中的元素是不能重复的。我们先来看个例子：</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let set = new Set();</div><div class="line"></div><div class="line">[1,2,2,3,4,5,5,5].map(x =&gt; set.add(x));</div><div class="line"></div><div class="line">console.log(set.size); //5</div></pre></td></tr></table></figure>
<p>初始化也可以接受数组为入参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let set = new Set([1,2,3,4]);</div></pre></td></tr></table></figure>
<p>刚才讲到，set中所有的元素是不能重复的，那么，怎么定义重复呢？set使用的方法类似于 ===，只有一个特例，NaN, 精确相等任务NaN不等于自身，而set中认为是相等的。</p>
<p>看几个例子，就一目了然了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let set = new Set([&quot;a&quot;, &quot;a&quot;]);</div><div class="line">console.log(set.size); //1</div><div class="line"></div><div class="line">let set = new Set([&#123;&#125;,&#123;&#125;]);</div><div class="line">console.log(set.size); //2</div><div class="line"></div><div class="line">let a = &#123;key: &apos;a&apos;&#125;;</div><div class="line">let b = &#123;key: &apos;b&apos;&#125;;</div><div class="line">let set = new Set([a,a]);</div><div class="line">console.log(set.size); //1</div><div class="line"></div><div class="line">let set = new Set([a,&#123;a&#125;]);</div><div class="line">console.log(set.size); //2</div></pre></td></tr></table></figure>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>属性有两个：</p>
<ol>
<li>construct 默认是Set函数</li>
<li>size, 即set中元素的数量</li>
</ol>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>set有四个操作方法：</p>
<ol>
<li>add() 返回set本身 </li>
<li>delete() 返回删除是否成功的布尔值</li>
<li>has() 返回set中是否某个元素</li>
<li>clear() 情况set，没有返回值</li>
</ol>
<p>这里要注意的是，delete和has中判断两个元素是否相同的方法和初始化中的方法一致，所以尤其要注意对象的判断，基本类型基本不会有问题。</p>
<p>set有四个遍历方法：</p>
<ol>
<li>keys(): 返回所有的key</li>
<li>values(): 返回所有的value</li>
<li>entries(): 返回所有的键值对</li>
<li>forEach(): 回调函数遍历， 和数组用法一致</li>
</ol>
<p>因为set中本身没有key，value之分，所key和value都是set中元素本身，我们来看下例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let set = new Set([&quot;key1&quot;, &quot;key2&quot;, &quot;key3&quot;]);</div><div class="line">console.log(set.keys());//[&quot;key1&quot;, &quot;key2&quot;, &quot;key3&quot;]</div><div class="line"></div><div class="line">console.log(set.values());//[&quot;key1&quot;, &quot;key2&quot;, &quot;key3&quot;]</div><div class="line"></div><div class="line">console.log(set.entries());//[&#123;&quot;key1&quot;: &quot;key1&quot;&#125;,&#123;&quot;key2&quot;: &quot;key2&quot;&#125;,&#123;&quot;key3&quot;: &quot;key3&quot;&#125;]</div></pre></td></tr></table></figure>
<h2 id="weakSet"><a href="#weakSet" class="headerlink" title="weakSet"></a>weakSet</h2><p>weakSet和set类似，只有两个区别：</p>
<ol>
<li>元素只能是对象</li>
<li>对象都是弱引用，即js的垃圾回收机制不会考虑weakSet中的引用</li>
</ol>
<p>因为第一个特点，所以weakSet不能使用遍历、size等方法和属性(因为遍历的时候可能对象已经被释放了)</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>set可以用来实现去重等功能，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let array = [1,2,2,3];</div><div class="line">let set = Set(array);</div><div class="line"></div><div class="line">let newArray = Array.from(set);</div><div class="line">console.log(newArray); //[1,2,3]</div></pre></td></tr></table></figure>
<p>weakSet在互联网上找到的内容不多，阮一峰的《ES6标准入门》中提到，可以用来保存DOM节点，而不用担心节点移除时引起内存泄露。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在ES6中，提供了新的数据结构set，set类似于数组，但是其中的元素是不能重复的。我们先来看个例子：&lt;/p&gt;
&lt;h2 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h2&gt;&lt;figure cl
    
    </summary>
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/tags/ES6/"/>
    
      <category term="Set" scheme="https://github.com/njafei/njafei.github.io/tags/Set/"/>
    
  </entry>
  
  <entry>
    <title>ipa包逆向重新签名打包</title>
    <link href="https://github.com/njafei/njafei.github.io/2018/02/27/ipa-recodesign/"/>
    <id>https://github.com/njafei/njafei.github.io/2018/02/27/ipa-recodesign/</id>
    <published>2018-02-27T05:43:28.000Z</published>
    <updated>2018-02-27T05:44:31.380Z</updated>
    
    <content type="html"><![CDATA[<p>在使用了rn之后，我们很少会修改原生代码，但是如果想要打包，还是重新打包原生代码，挺花时间的，那么，只修改rn的代码情况下，有没有快速出包的方法？ 答案就是今天这篇文章的主题，ipa逆向，然后替换资源，重新打包，这样只需要替换掉js的bundle包，省去了重新archive的时间了。</p>
<p>过程如下：</p>
<ol>
<li>test.ipa 改名为  test.zip</li>
<li>解开zip，打开Payload，显示test资源包，右键显示报内容，就会看到ipa中所有的资源等内容</li>
<li>找到并复制entitlements.plist文件，这个文件是重新签名的时候要使用的，其中记录的是app需要申请的权限</li>
<li>替换你想替换的资源，这里就是rn的bundle.js</li>
<li>确定你想使用的签名证书的名称，通常是：‘iPhone Distribution: Test Company’</li>
<li>重签名 <code>codesign -f -s &quot;iPhone Distribution: Test Company&quot; --entitlements entitlements.plist Payload/Test.app</code></li>
<li>将签名之后的文件夹压缩 <code>zip -r Test.ipa Payload</code></li>
</ol>
<p>其他用法：</p>
<p>这里讲的替换资源是重签名打包的一种用法，我在网上搜索的时候，发现其他人也生出了很多好的思路，比如： 为了防止提供AppStore的包出问题，直接使用最后的测试包，重新签名，然后上传，这里用到的就是重签名替换证书的功能。</p>
<p>综上，重签名打包，可以替换资源和证书，从而达到在不需要重新编译的情况下，替换资源的功能。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用了rn之后，我们很少会修改原生代码，但是如果想要打包，还是重新打包原生代码，挺花时间的，那么，只修改rn的代码情况下，有没有快速出包的方法？ 答案就是今天这篇文章的主题，ipa逆向，然后替换资源，重新打包，这样只需要替换掉js的bundle包，省去了重新archive
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/njafei/njafei.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/njafei/njafei.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>ES6-Proxy</title>
    <link href="https://github.com/njafei/njafei.github.io/2018/02/23/ES6-Proxy/"/>
    <id>https://github.com/njafei/njafei.github.io/2018/02/23/ES6-Proxy/</id>
    <published>2018-02-23T09:37:04.000Z</published>
    <updated>2018-02-23T09:37:34.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>proxy的作用是代理对象的某些行为，其 实质 是重载对象的方法。</p>
<p>举个例子,我们想要读取一个对象的某个属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;a: &apos;a&apos; , b: &apos;b&apos;&#125;;</div><div class="line">console.log(obj.a); // &apos;a&apos;</div></pre></td></tr></table></figure>
<p>而使用了proxy之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;a: &apos;a&apos;, b: &apos;b&apos;&#125;;</div><div class="line">let handler = &#123;</div><div class="line">	get: fucntion(target, propoty)&#123;</div><div class="line">		return 35;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var proxy = new Proxy(obj, handler);</div><div class="line">console.log(proxy.a);// 35</div></pre></td></tr></table></figure>
<p>相当于 proxy通过handler里面的指令，代理了obj的行为。</p>
<p>proxy能代理的，并不仅仅是get函数，还有如下列表，具体的可以网上查阅下文档。</p>
<ul>
<li>get</li>
<li>set</li>
<li>has</li>
<li>deleteProperty</li>
<li>enumerate</li>
<li>hasOwn</li>
<li>ownKeys</li>
<li>getOwnPropertyDescritor</li>
<li>defineProperty</li>
<li>preventExtensions</li>
<li>getPrototypeOf</li>
<li>isExtensible</li>
<li>setPrototypeOf</li>
<li>apply</li>
<li>construct</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>看完了proxy的文档，感觉模模糊糊有了印象，但是还是对它的使用场景没有概念，网上搜索了下，发下一篇非常好的介绍使用场景的文章，地址如下： <a href="https://segmentfault.com/a/1190000006035363" target="_blank" rel="noopener">[译] 实例解析 ES6 Proxy 使用场景</a>，下面我也会使用这篇文章的例子，来介绍proxy到底怎么用。</p>
<h4 id="校验模块"><a href="#校验模块" class="headerlink" title="校验模块"></a>校验模块</h4><p>这里是重写set函数，实现校验功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">let numericDataStore = &#123;  </div><div class="line">    count: 0,</div><div class="line">    amount: 1234,</div><div class="line">    total: 14</div><div class="line">&#125;;</div><div class="line"></div><div class="line">numericDataStore = new Proxy(numericDataStore, &#123;  </div><div class="line">    set(target, key, value, proxy) &#123;</div><div class="line">        if (typeof value !== &apos;number&apos;) &#123;</div><div class="line">            throw Error(&quot;Properties in numericDataStore can only be numbers&quot;);</div><div class="line">        &#125;</div><div class="line">        return Reflect.set(target, key, value, proxy);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 抛出错误，因为 &quot;foo&quot; 不是数值</div><div class="line">numericDataStore.count = &quot;foo&quot;;</div><div class="line"></div><div class="line">// 赋值成功</div><div class="line">numericDataStore.count = 333;</div></pre></td></tr></table></figure>
<h4 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h4><p>js中的私有属性，约定俗成是通过前面加下划线的方式来实现，这里可以用proxy来实现，并且做到了强制私有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var api = &#123;  </div><div class="line">    _apiKey: &apos;123abc456def&apos;,</div><div class="line">    /* mock methods that use this._apiKey */</div><div class="line">    getUsers: function()&#123;&#125;, </div><div class="line">    getUser: function(userId)&#123;&#125;, </div><div class="line">    setUser: function(userId, config)&#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// logs &apos;123abc456def&apos;;</div><div class="line">console.log(&quot;An apiKey we want to keep private&quot;, api._apiKey);</div><div class="line"></div><div class="line">// get and mutate _apiKeys as desired</div><div class="line">var apiKey = api._apiKey;  </div><div class="line">api._apiKey = &apos;987654321&apos;;</div></pre></td></tr></table></figure>
<h4 id="访问日志"><a href="#访问日志" class="headerlink" title="访问日志"></a>访问日志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">let api = &#123;  </div><div class="line">    _apiKey: &apos;123abc456def&apos;,</div><div class="line">    getUsers: function() &#123; /* ... */ &#125;,</div><div class="line">    getUser: function(userId) &#123; /* ... */ &#125;,</div><div class="line">    setUser: function(userId, config) &#123; /* ... */ &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function logMethodAsync(timestamp, method) &#123;  </div><div class="line">    setTimeout(function() &#123;</div><div class="line">        console.log(`$&#123;timestamp&#125; - Logging $&#123;method&#125; request asynchronously.`);</div><div class="line">    &#125;, 0)</div><div class="line">&#125;</div><div class="line"></div><div class="line">api = new Proxy(api, &#123;  </div><div class="line">    get: function(target, key, proxy) &#123;</div><div class="line">        var value = target[key];</div><div class="line">        return function(...arguments) &#123;</div><div class="line">            logMethodAsync(new Date(), key);</div><div class="line">            return Reflect.apply(value, target, arguments);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">api.getUsers();</div></pre></td></tr></table></figure>
<h4 id="预警和拦截"><a href="#预警和拦截" class="headerlink" title="预警和拦截"></a>预警和拦截</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">let dataStore = &#123;  </div><div class="line">    noDelete: 1235,</div><div class="line">    oldMethod: function() &#123;/*...*/ &#125;,</div><div class="line">    doNotChange: &quot;tried and true&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">const NODELETE = [&apos;noDelete&apos;];  </div><div class="line">const NOCHANGE = [&apos;doNotChange&apos;];</div><div class="line">const DEPRECATED = [&apos;oldMethod&apos;];  </div><div class="line"></div><div class="line">dataStore = new Proxy(dataStore, &#123;  </div><div class="line">    set(target, key, value, proxy) &#123;</div><div class="line">        if (NOCHANGE.includes(key)) &#123;</div><div class="line">            throw Error(`Error! $&#123;key&#125; is immutable.`);</div><div class="line">        &#125;</div><div class="line">        return Reflect.set(target, key, value, proxy);</div><div class="line">    &#125;,</div><div class="line">    deleteProperty(target, key) &#123;</div><div class="line">        if (NODELETE.includes(key)) &#123;</div><div class="line">            throw Error(`Error! $&#123;key&#125; cannot be deleted.`);</div><div class="line">        &#125;</div><div class="line">        return Reflect.deleteProperty(target, key);</div><div class="line"></div><div class="line">    &#125;,</div><div class="line">    get(target, key, proxy) &#123;</div><div class="line">        if (DEPRECATED.includes(key)) &#123;</div><div class="line">            console.warn(`Warning! $&#123;key&#125; is deprecated.`);</div><div class="line">        &#125;</div><div class="line">        var val = target[key];</div><div class="line"></div><div class="line">        return typeof val === &apos;function&apos; ?</div><div class="line">            function(...args) &#123;</div><div class="line">                Reflect.apply(target[key], target, args);</div><div class="line">            &#125; :</div><div class="line">            val;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// these will throw errors or log warnings, respectively</div><div class="line">dataStore.doNotChange = &quot;foo&quot;;  </div><div class="line">delete dataStore.noDelete;  </div><div class="line">dataStore.oldMethod();</div></pre></td></tr></table></figure>
<h4 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h4><p>通过特征来过滤不必要的操作，例如下载中，解析中等中间过程，减少响应的压力</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;  </div><div class="line">    getGiantFile: function(fileId) &#123;/*...*/ &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj = new Proxy(obj, &#123;  </div><div class="line">    get(target, key, proxy) &#123;</div><div class="line">        return function(...args) &#123;</div><div class="line">            const id = args[0];</div><div class="line">            let isEnroute = checkEnroute(id);</div><div class="line">            let isDownloading = checkStatus(id);      </div><div class="line">            let cached = getCached(id);</div><div class="line"></div><div class="line">            if (isEnroute || isDownloading) &#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">            if (cached) &#123;</div><div class="line">                return cached;</div><div class="line">            &#125;</div><div class="line">            return Reflect.apply(target[key], target, args);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;p&gt;proxy的作用是代理对象的某些行为，其 实质 是重载对象的方法。&lt;/p&gt;
&lt;p&gt;举个例子,我们想要读取一个对象的某个属性&lt;/p&gt;
&lt;fig
    
    </summary>
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6-Symbols</title>
    <link href="https://github.com/njafei/njafei.github.io/2018/02/22/ES6-Symbols/"/>
    <id>https://github.com/njafei/njafei.github.io/2018/02/22/ES6-Symbols/</id>
    <published>2018-02-22T05:57:42.000Z</published>
    <updated>2018-02-22T06:00:11.628Z</updated>
    
    <content type="html"><![CDATA[<p>#背景<br>ES5中，属性都可以通过点方法来获取和赋值。这也带来了一个问题，当我想给一个类增加属性的时候，除非我看完这个类的所有细节，否则我很难知道一个属性名是否已经被占用。而ES6为了解决这个问题，引入了一个新的原始类型Symbol，它表示独一无二的值，来避免重复的命名。</p>
<p>加入Symbol之后，JS中的基础类型共有：</p>
<ul>
<li>undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>String</li>
<li>Number</li>
<li>Object</li>
<li>Symbol</li>
</ul>
<p>#使用</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>Symbol的初始化方法很简单，但是要注意，它不是对象（Object），所以不能用new初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let s = Symbol();</div></pre></td></tr></table></figure>
<p>Symbol没有属性，是一个类似于string的数据类型，我的理解，Symbol其实就是独一无二的string。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s.name = &apos;symbol&apos;; //error</div></pre></td></tr></table></figure>
<p>Symbol可以通过加参数的形式来区分不同的Symbol，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let s = Symbol(&apos;foo&apos;);</div></pre></td></tr></table></figure>
<p>注意，即使使用相同的参数来初始化，得到的实例也是不同的，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let a = Symbol(&apos;foo&apos;);</div><div class="line">let b = Symbol(&apos;foo&apos;);</div><div class="line"></div><div class="line">let same = a === b;</div><div class="line"></div><div class="line">console.log(same); //false</div></pre></td></tr></table></figure>
<p>如果想要获取以某个string为参数的Symbol，在之后会讲到Symbol.for()函数。</p>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>使用Symbol给属性赋值，用法和string属性赋值基本相似，但是不可以用<code>.</code>,要用<code>[]</code>。以下是三种赋值方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">let s = Symbol();</div><div class="line"></div><div class="line"></div><div class="line">let a = &#123;&#125;;</div><div class="line"></div><div class="line">// method 1</div><div class="line">a[s] = &apos;hello&apos;;</div><div class="line"></div><div class="line">//method 2</div><div class="line">a = &#123;</div><div class="line">	[s] = &apos;hello&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//method 3</div><div class="line"></div><div class="line">Object.defineProperty(a, s, &#123;value: &apos;hello&apos;&#125;);</div></pre></td></tr></table></figure>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>Symbol的一个场景是上述提到的，给一个类增加属性，而避免属性重复。</p>
<p>第二是使用在常量中，<code>switch case</code>来保证唯一性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let CASE1 = Symbol();</div><div class="line">let CASE2 = Symbol();</div><div class="line"></div><div class="line">switch (case) &#123;</div><div class="line">	case CASE1 :&#123;</div><div class="line">		return 1;</div><div class="line">	&#125;</div><div class="line">	case CASE2 :&#123;</div><div class="line">		return 2;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="注意事项（和string属性不同的地方）"><a href="#注意事项（和string属性不同的地方）" class="headerlink" title="注意事项（和string属性不同的地方）"></a>注意事项（和string属性不同的地方）</h1><p>最主要的区别，使用 <code>for ... in</code>、 <code>for ... of</code> 或者<code>Object.keys()</code>、 <code>Object.getOwnPropertyNames()</code>不会返回Symbol</p>
<p>如果想获取对象的所有Symbols，使用函数<code>getOwnPropertySymbols</code></p>
<p>有个新的API，<code>Reflect.ownKyes</code>，会返回所有的String属性和Symbol属性</p>
<h1 id="Symbol-keyFor和Symbol-for"><a href="#Symbol-keyFor和Symbol-for" class="headerlink" title="Symbol.keyFor和Symbol.for"></a>Symbol.keyFor和Symbol.for</h1><h3 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for"></a>Symbol.for</h3><p>Symbol会返回一个新的实例，无论参数是什么，上面已经将到了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let a = Symbol(&apos;foo&apos;);</div><div class="line">let b = Symbol(&apos;foo&apos;);</div><div class="line"></div><div class="line">let same = a === b; //false</div></pre></td></tr></table></figure>
<p>而Symbol.for则会先搜索是否有以这个参数初始化的Symbol，如果有则放回这个Symbol，否则初始化一个新的,实现逻辑如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Symbol.for(params) = &#123;</div><div class="line">	if (searchSymbolInitWithParams)&#123;</div><div class="line">		return found_symbol;</div><div class="line">	&#125; else &#123;</div><div class="line">		return Symbol(params);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和第一个例子对比看下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let a = Symbol.for(&apos;foo&apos;);</div><div class="line">let b = Symbol.for(&apos;foo&apos;);</div><div class="line"></div><div class="line">let same = a === b; //true</div></pre></td></tr></table></figure>
<p>如果Symbol和Symbol.for混用呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let a = Symbol(&apos;foo&apos;);</div><div class="line">let b = Symbol.for(&apos;foo&apos;);</div><div class="line"></div><div class="line">console.log(a===b); //false</div></pre></td></tr></table></figure>
<p>这说明两者是没有打通的，即Symbol初始化的实例无法被Symbol.for找到</p>
<h3 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor"></a>Symbol.keyFor</h3><p>用Symbol.for来初始化的Symbol，如何知道它的初始化参数呢，这里提供了一个方法： Symbol.keyFor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let a = Symbol.for(&apos;foo&apos;);</div><div class="line">let b = Symbol.Keyfor(a);// &apos;foo&apos;</div></pre></td></tr></table></figure>
<p>注意，Symbol初始化不能用这个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let a = Symbol(&apos;foo&apos;);</div><div class="line">let b = Symbol.Keyfor(a);// undefined</div></pre></td></tr></table></figure>
<p>注意：Symbol.for 为Symbol值登记的是全局的，这意味着在不同的iframe都可以取到同一个值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#背景&lt;br&gt;ES5中，属性都可以通过点方法来获取和赋值。这也带来了一个问题，当我想给一个类增加属性的时候，除非我看完这个类的所有细节，否则我很难知道一个属性名是否已经被占用。而ES6为了解决这个问题，引入了一个新的原始类型Symbol，它表示独一无二的值，来避免重复的命名
    
    </summary>
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>React Native性能优化</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/10/25/RNpreformance/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/10/25/RNpreformance/</id>
    <published>2017-10-25T03:00:45.000Z</published>
    <updated>2017-10-25T03:03:48.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于帧"><a href="#关于帧" class="headerlink" title="关于帧"></a>关于帧</h2><p>在讲述如何优化性能之前，我们要先了解一下性能的概念。对一个从未接触过相关概念的人来说，所谓的性能就是当你去使用App的时候很流畅，点击、跳转等交互效果反应很快，而且很顺滑。这是感性的角度，那么理性的角度或者数据的角度看待呢？</p>
<p>这里要介绍一个概念： 帧率。我们知道，所谓的动画或者电影，其实归根结底就是在一秒内快速闪过多张不同的图片，如果快到一定的程度，肉眼会误以为里面的动画都是连贯的。在iOS等设备，标准是每秒60帧（即每秒连续展示60张图片），这个标准足以保证用户的体验。</p>
<p><img src="https://gss0.baidu.com/94o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/d1160924ab18972be457999ee2cd7b899e510a70.jpg" alt="动画示意"></p>
<p>系统会每16.6毫秒询问你下一帧的数据，如果你正在处理比较复杂的任务，则系统会默认这一帧内容保持不变，即出现了丢帧的现象。如果丢的帧比较多，则界面会看起来卡顿，比如用户点击了按钮，但是没有反馈。</p>
<p>对<code>React Native</code>来说，帧分为两种： <code>JavaScript</code>帧和主线程帧（<code>UI</code>帧）</p>
<h3 id="JavaScript帧"><a href="#JavaScript帧" class="headerlink" title="JavaScript帧"></a>JavaScript帧</h3><p><code>React Native</code>大部分的业务处理，都是在<code>JavaScript</code>帧中进行，包括API调用和触摸等交互的处理。那么当处理比较复杂的任务，比如<code>setState</code>然后<code>render</code>，则很可能会丢帧。或者做由JS处理的动画时，也极容易出现丢帧卡顿。</p>
<h3 id="主线程帧（UI帧）"><a href="#主线程帧（UI帧）" class="headerlink" title="主线程帧（UI帧）"></a>主线程帧（<code>UI</code>帧）</h3><p>iOS的主线程是UI线程，所以在iOS的UI效果基本是非常出色的，这也是为什么<code>NavigatorIOS</code>比<code>Navigator</code>的性能好很多的原因（<code>NavigatorIOS</code>是主线程处理，而<code>Navigator</code>是JS线程处理）</p>
<h3 id="如何查看帧数据"><a href="#如何查看帧数据" class="headerlink" title="如何查看帧数据"></a>如何查看帧数据</h3><p>我们可以通过打开<code>RN</code>的<code>Debug</code>菜单，然后选择<code>Show Perf Monitor</code>来查看当前页面的<code>JS</code>帧和主线程帧。</p>
<p>好了，性能的定义和我们评估性能标准已经知道了，下面我们来看下影响性能的因素。</p>
<h2 id="影响性能的因素和提升方案"><a href="#影响性能的因素和提升方案" class="headerlink" title="影响性能的因素和提升方案"></a>影响性能的因素和提升方案</h2><h3 id="宽泛的原因"><a href="#宽泛的原因" class="headerlink" title="宽泛的原因"></a>宽泛的原因</h3><p>我们先抛开RN或者iOS的前端框架，看下对一台带屏幕的设备来说，影响性能的原因有哪些。</p>
<p>我们用金字塔模式来看，首先最明显的有两个</p>
<ul>
<li>设备性能</li>
<li>程序设计</li>
</ul>
<p>从根本上来说，设备性能是最大的瓶颈，不过这个我们程序员暂时无能为力。而程序设计可能引起性能差的有哪些呢？判断程序设计的一个标准就是复杂度， 而复杂度又分为两个：</p>
<ul>
<li>时间复杂度</li>
<li>空间复杂度</li>
</ul>
<p>这时我们的性能因素树是：</p>
<ul>
<li>设备性能</li>
<li>程序设计<ul>
<li>时间复杂度</li>
<li>空间复杂度</li>
</ul>
</li>
</ul>
<p>在设备空间充足的情况下，主要的影响就是时间复杂度，而时间复杂度高的原因有几个：</p>
<ul>
<li>前端方案不合理，UI层次或者顺序设计不合理，浪费性能</li>
<li>使用的算法过于复杂</li>
</ul>
<p>我们挨个说下这两个个问题，前端方案是最容易造成性能不好的原因，比如我们有屏幕上有几个区域，互相之间没有影响，而由于不合理的设计，在一个区域变化的时候，要刷新这个界面，就会出现卡顿。一个合理的前端方案，应该是尽可能减少页面的刷新频率和刷新范围，保证每帧的计算是相对小的。</p>
<p>而算法过于复杂，则是算法消耗的时间太长，影响了UI的渲染。比如使用了圈复杂度非常高的算法，或者有大量的数据要不停地计算。</p>
<p>这样我们的性能因素树变成了：</p>
<ul>
<li>设备性能</li>
<li>程序设计<ul>
<li>空间复杂度</li>
<li>时间复杂度<ul>
<li>前端方案不合理，UI层次或者顺序设计不合理，浪费性能<ul>
<li>使用的算法过于复杂</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>可能还会有人觉得网络等原因会造成卡顿，但是我觉得如果交互设计良好，网络状况不好的话，只会影响数据出现的时间长，而不会造成页面的卡顿。</p>
<p>看完了比较普遍宽泛的原因，我们看下针对RN的</p>
<h3 id="RN的特有原因"><a href="#RN的特有原因" class="headerlink" title="RN的特有原因"></a>RN的特有原因</h3><h4 id="JS-Bridge的效率"><a href="#JS-Bridge的效率" class="headerlink" title="JS Bridge的效率"></a>JS Bridge的效率</h4><p>虽然官方的文章里没有写，但是从我测试看到的数据来看，虽然RN的性能比较接近Native，但是因为JS是运行在子线程中的，所以处理大量数据或者动画的时候，JS的帧数会比较少。</p>
<p>这个我们暂时无能为力</p>
<h4 id="动画和Touchable组件在JS线程中运行"><a href="#动画和Touchable组件在JS线程中运行" class="headerlink" title="动画和Touchable组件在JS线程中运行"></a>动画和Touchable组件在JS线程中运行</h4><p>Animated和Touchable系列组件都是在JS中运行，所以在处理复杂动画或者复杂操作的时候，会出现卡顿。</p>
<p>这里给几个建议：</p>
<ul>
<li><p>关于导航</p>
<ol>
<li>iOS上使用<code>NavigatorIOS</code>替换<code>Navigator</code>，同时，react也推出了新的<a href="https://reactnavigation.org/" target="_blank" rel="noopener">Navigation库</a>希望解决导航卡顿的问题</li>
<li>push的新界面的动画，使用<code>InteractionManager</code>，就是在导航动画结束后执行新的动画，而不是同时执行</li>
</ol>
</li>
<li><p>关于动画</p>
<ol>
<li>如果<code>Animated</code>的效果不能接受，使用<code>LayoutAnimation</code>，它是基于<code>Core Animation</code></li>
<li>android上面尽量少用动画（真的很卡0_0）</li>
</ol>
</li>
</ul>
<h4 id="其他建议"><a href="#其他建议" class="headerlink" title="其他建议"></a>其他建议</h4><ul>
<li>使用<a href="">PureComponent</a></li>
<li>使用 <code>shouldComponentUpdate</code>函数，这个函数默认返回true，但是我们可以通过自定义来优化重新绘制的逻辑</li>
<li>release 去除console.log()</li>
</ul>
<figure class="highlight plain"><figcaption><span>(!__DEV__) &#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  global.console = &#123;</div><div class="line">    info: () =&gt; &#123;&#125;,</div><div class="line">    log: () =&gt; &#123;&#125;,</div><div class="line">    warn: () =&gt; &#123;&#125;,</div><div class="line">    debug: () =&gt; &#123;&#125;,</div><div class="line">    error: () =&gt; &#123;&#125;,</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="最重要的建议"><a href="#最重要的建议" class="headerlink" title="最重要的建议"></a>最重要的建议</h4><ol>
<li>仔细考虑UI的设计</li>
<li>仔细考虑UI的设计</li>
<li>仔细考虑UI的设计</li>
</ol>
<p>一个好的UI设计方案，是可以抵过上面所有的建议加起来的效果的，所以一定要仔细考虑再动手。</p>
<p>参考：</p>
<ul>
<li><a href="http://reactnative.cn/docs/0.49/performance.html#content" target="_blank" rel="noopener">官方文档：性能</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于帧&quot;&gt;&lt;a href=&quot;#关于帧&quot; class=&quot;headerlink&quot; title=&quot;关于帧&quot;&gt;&lt;/a&gt;关于帧&lt;/h2&gt;&lt;p&gt;在讲述如何优化性能之前，我们要先了解一下性能的概念。对一个从未接触过相关概念的人来说，所谓的性能就是当你去使用App的时候很流畅，点
    
    </summary>
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/categories/React-Native/"/>
    
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/tags/React-Native/"/>
    
      <category term="performance" scheme="https://github.com/njafei/njafei.github.io/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>Next增加搜索localSearch</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/10/19/Next-add-localSearch/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/10/19/Next-add-localSearch/</id>
    <published>2017-10-19T08:06:51.000Z</published>
    <updated>2017-10-19T08:12:28.931Z</updated>
    
    <content type="html"><![CDATA[<p>Next本身增加localSearch很简单，三步即可：</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-generator-searchdb --save</div></pre></td></tr></table></figure>
<p>编辑 站点配置文件，新增以下内容到任意位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">search:</div><div class="line">  path: search.xml</div><div class="line">  field: post</div><div class="line">  format: html</div><div class="line">  limit: 10000</div></pre></td></tr></table></figure>
<p>编辑 主题配置文件，启用本地搜索功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># Local search</div><div class="line">local_search:</div><div class="line">  enable: true</div></pre></td></tr></table></figure>
<h2 id="遇到问题，一直loading"><a href="#遇到问题，一直loading" class="headerlink" title="遇到问题，一直loading"></a>遇到问题，一直loading</h2><p>发布了之后，点击搜索一直在loading，查了其他人的文章<a href="https://www.v2ex.com/amp/t/298727" target="_blank" rel="noopener">Hexo next 主题的 local search 功能失效，点击搜索链接无法弹出叠加层
</a>，发现是<code>search.xml</code>出现了问题。</p>
<p>排查问题步骤：</p>
<ol>
<li>command + option + J 打开调试器</li>
<li>点击NetWork，发现卡在了<code>search.xml</code>上面</li>
<li>尝试debug <code>serach.xml</code>文件，打开 <a href="https://njafei.github.io/search.xml" target="_blank" rel="noopener">https://njafei.github.io/search.xml</a></li>
<li>看到警告： <code>error on line 92 at column 35: Input is not proper UTF-8, indicate encoding ! 0x10 0xE6 0x88 0x96</code></li>
<li>编码问题，找到对应的文章，先对其进行<code>utf-8</code>编码，然后放到sublimeText中，我发现中间多了一个类似于<code>DEL</code>的乱码，删除即可</li>
<li>重新发布，搜索可用</li>
</ol>
<h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><p>search有时候会有缓存，这时候，可以打开对应的<code>search.xml</code>文件<a href="https://njafei.github.io/search.xml" target="_blank" rel="noopener">https://njafei.github.io/search.xml</a>，刷新几下即可</p>
<blockquote>
<p>PS： 如果你想刷新你的文件，把前面的链接替换即可。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Next本身增加localSearch很简单，三步即可：&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;安装 hexo-generator-searchdb，在站点的根目录
    
    </summary>
    
    
      <category term="博客搭建和功能增强" scheme="https://github.com/njafei/njafei.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E5%8A%9F%E8%83%BD%E5%A2%9E%E5%BC%BA/"/>
    
  </entry>
  
  <entry>
    <title>ImageOptm 自动化无损优化图片</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/09/26/ImageOptm/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/09/26/ImageOptm/</id>
    <published>2017-09-26T03:01:58.000Z</published>
    <updated>2017-10-19T03:37:16.721Z</updated>
    
    <content type="html"><![CDATA[<p>iOS控制包的大小对于公司来说，是个非常重要的事情。因为苹果公司对于包的大小超过100M的，不会允许用户使用移动网络来下载，这很可能造成商业上的损失。</p>
<p>而在控制包的大小中，一个很重要的原则就是禁止大图片。之前研究其他公司的ipa包的时候，就出现过一个icon高达1M的事故。而平时，虽然程序员们百般小心，难免被设计师暗算给张大图（玩笑），所以靠人终究不是一个可持续的保证质量的方法。</p>
<p>平时用的无损压缩最多的工具是<code>ImageOptm</code>，它可以无损压缩图片（即用户看起来感官无变化，而图片尽可能小），而且它是提供命令行的，<a href="https://imageoptim.com/command-line.html" target="_blank" rel="noopener">ImageOptm command line</a>.</p>
<p>我们就可以通过Jenkins的定时任务，每天凌晨去优化所有的图片，然后再自动commit上传。</p>
<p>具体任务就很简单了，大概几个步骤：</p>
<p>1、Jenkins开个定时任务，更新代码</p>
<p>2、执行ImageOptm脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/Applications/ImageOptim.app/Contents/MacOS/ImageOptim  $WORKSPACE/</div></pre></td></tr></table></figure>
<p>3、上传代码</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS控制包的大小对于公司来说，是个非常重要的事情。因为苹果公司对于包的大小超过100M的，不会允许用户使用移动网络来下载，这很可能造成商业上的损失。&lt;/p&gt;
&lt;p&gt;而在控制包的大小中，一个很重要的原则就是禁止大图片。之前研究其他公司的ipa包的时候，就出现过一个icon高
    
    </summary>
    
    
      <category term="自动化" scheme="https://github.com/njafei/njafei.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Java对空格的encode格式问题</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/09/22/Java-space-encode/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/09/22/Java-space-encode/</id>
    <published>2017-09-22T08:57:41.000Z</published>
    <updated>2017-10-19T03:37:16.721Z</updated>
    
    <content type="html"><![CDATA[<p>今天发现了一个非常奇怪的问题，服务端给了一个encode的url，内容是位“1 1”：</p>
<p>encode之后是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1+1</div></pre></td></tr></table></figure>
<p>前端decode之后是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1+1</div></pre></td></tr></table></figure>
<p>可是在其他的浏览器等decode之后的结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 1</div></pre></td></tr></table></figure>
<p>发现java的encode有个坑，在java中，encode遵循的标准是<a href="http://www.faqs.org/rfcs/rfc1738.html" target="_blank" rel="noopener">rfc1738</a>，而在iOS中，encode遵循的标准是<a href="http://www.faqs.org/rfcs/rfc2396.html" target="_blank" rel="noopener">rfc2396</a>，两者对于空格的encode不同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rfc1738 =&gt; +</div><div class="line">rfc2396 =&gt; %20</div></pre></td></tr></table></figure>
<p>所以今后和Java服务端合作的时候，如果encode之后的文案出现了+号这种莫名奇妙的bug，记得让他们检查下encode的代码，可以通过替换来解决这个问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天发现了一个非常奇怪的问题，服务端给了一个encode的url，内容是位“1 1”：&lt;/p&gt;
&lt;p&gt;encode之后是&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div 
    
    </summary>
    
    
      <category term="小知识" scheme="https://github.com/njafei/njafei.github.io/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>React-Native优化之PureComponent</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/07/27/pureComponent/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/07/27/pureComponent/</id>
    <published>2017-07-27T10:56:18.000Z</published>
    <updated>2017-10-19T03:37:16.730Z</updated>
    
    <content type="html"><![CDATA[<p>React15.3的发布中包含了PureComponent，这个类最重要的用法是为了优化React的性能，下面我们将看下它是如何优化的。</p>
<h1 id="Component-VS-PureComponent"><a href="#Component-VS-PureComponent" class="headerlink" title="Component VS PureComponent"></a>Component VS PureComponent</h1><p>首先要看Component的生命周期：<br><img src="http://on0hv7n2x.bkt.clouddn.com/component-lifecycle.jpg" alt=""></p>
<p>当props或者state改变的时候，会执行<code>shouldComponentUpdate</code>方法来判断是否需要重新render组建，我们平时在做页面的性能优化的时候，往往也是通过这一步来判断的。Component默认的<code>shouldComponentUpdate</code>返回的是true，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">shouldComponentUpdate(nextProps, nextState) &#123;</div><div class="line">  return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而PureComponent的<code>shouldComponentUpdate</code>是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (this._compositeType === CompositeTypes.PureClass) &#123;</div><div class="line">  shouldUpdate = !shallowEqual(prevProps, nextProps) || ! shallowEqual(inst.state, nextState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的比较，只会做潜比较，即比较两者的内存地址是否相同，而对于其值是否发生变化，则不会理会。我们通过以下的例子来看下：</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Sample React Native App</div><div class="line"> * https://github.com/facebook/react-native</div><div class="line"> * @flow</div><div class="line"> */</div><div class="line"></div><div class="line">import React, &#123; PureComponent,Component &#125; from &apos;react&apos;;</div><div class="line">import &#123;</div><div class="line">  AppRegistry,</div><div class="line">  StyleSheet,</div><div class="line">  Text,</div><div class="line">  View,</div><div class="line">  Button</div><div class="line">&#125; from &apos;react-native&apos;;</div><div class="line"></div><div class="line">export default class test extends PureComponent &#123;</div><div class="line">  constructor(props)&#123;</div><div class="line">    super(props);</div><div class="line">    this.state = &#123;</div><div class="line">       number : 1,</div><div class="line">       numbers: [],</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">        &lt;Button title=&#123;&apos;number + 1&apos;&#125; onPress=&#123;this.numberAdd.bind(this)&#125; /&gt;</div><div class="line">        &lt;Text&gt;number value: &#123;this.state.number&#125;&lt;/Text&gt;</div><div class="line">        &lt;Button title=&#123;&apos;numbers + 1&apos;&#125; onPress=&#123;this.numbersAdd.bind(this)&#125; /&gt;</div><div class="line">        &lt;Text&gt;numbers length: &#123;this.state.numbers.length&#125;&lt;/Text&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  numberAdd()&#123;</div><div class="line">      this.setState(&#123;number: ++this.state.number &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  numbersAdd()&#123;</div><div class="line">    let numbers = this.state.numbers;</div><div class="line">    numbers.push(1);</div><div class="line">    this.setState(&#123;numbers: numbers&#125;);</div><div class="line">    console.log(this.state.numbers);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line">  container: &#123;</div><div class="line">    flex: 1,</div><div class="line">    justifyContent: &apos;center&apos;,</div><div class="line">    alignItems: &apos;center&apos;,</div><div class="line">    backgroundColor: &apos;#F5FCFF&apos;,</div><div class="line">  &#125;,</div><div class="line">  welcome: &#123;</div><div class="line">    fontSize: 20,</div><div class="line">    textAlign: &apos;center&apos;,</div><div class="line">    margin: 10,</div><div class="line">  &#125;,</div><div class="line">  instructions: &#123;</div><div class="line">    textAlign: &apos;center&apos;,</div><div class="line">    color: &apos;#333333&apos;,</div><div class="line">    marginBottom: 5,</div><div class="line">  &#125;,</div><div class="line">&#125;);</div><div class="line"></div><div class="line">AppRegistry.registerComponent(&apos;test&apos;, () =&gt; test);</div></pre></td></tr></table></figure>
<p>界面如下：</p>
<p><img src="http://on0hv7n2x.bkt.clouddn.com/screenShotSimulator%20Screen%20Shot%202017%E5%B9%B47%E6%9C%8827%E6%97%A5%20%E4%B8%8B%E5%8D%886.48.31.png" alt=""></p>
<p>这里去点击number+1 和 numbers+1都不会有任何页面的变化。</p>
<h1 id="如何让PureComponent重绘"><a href="#如何让PureComponent重绘" class="headerlink" title="如何让PureComponent重绘"></a>如何让PureComponent重绘</h1><p>那如果PureComponent变化的时候(这其实不符合我们的初衷)，我们要怎么做呢？这里有两个办法：</p>
<ol>
<li>重写shouldUpdateComponent方法</li>
<li>props或者state增减参数</li>
</ol>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">numbersAdd()&#123;</div><div class="line">    let numbers = this.state.numbers;</div><div class="line">    numbers.push(1);</div><div class="line">    this.setState(&#123;numbers: numbers&#125;);</div><div class="line">    console.log(this.state.numbers);</div><div class="line"></div><div class="line">    this.setState(&#123;newState: 1&#125;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这样，shouldComponentUpdate的返回值也会是true。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综上，PureComponent非常适合于不变的组件，尤其是和数据、业务无关的纯展示组件，因为它的节省了大量比较的工作。但是对于大部分的业务来说，界面很少会有不变的组件，所以使用的场景会比较少，但是如果遇到，请尽情使用！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React15.3的发布中包含了PureComponent，这个类最重要的用法是为了优化React的性能，下面我们将看下它是如何优化的。&lt;/p&gt;
&lt;h1 id=&quot;Component-VS-PureComponent&quot;&gt;&lt;a href=&quot;#Component-VS-PureC
    
    </summary>
    
      <category term="react-native" scheme="https://github.com/njafei/njafei.github.io/categories/react-native/"/>
    
    
      <category term="react-native" scheme="https://github.com/njafei/njafei.github.io/tags/react-native/"/>
    
      <category term="component" scheme="https://github.com/njafei/njafei.github.io/tags/component/"/>
    
  </entry>
  
  <entry>
    <title>react-native time定时器 防止内存泄露的注意点</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/07/27/react-native-time-attations/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/07/27/react-native-time-attations/</id>
    <published>2017-07-27T07:50:21.000Z</published>
    <updated>2017-10-19T03:37:16.730Z</updated>
    
    <content type="html"><![CDATA[<p><code>time</code>是<code>react-native</code>提供的一个定时器，在实际使用中，经常会有使用不对，造成内存泄露的情况。很多<code>React Native</code>应用发生致命错误（闪退）是与计时器有关。具体来说，是在某个组件被卸载<code>（unmount）</code>之后，计时器却仍然在运行。</p>
<p>防止出问题的办法也很简单，在<code>unmount</code>的时候，增加卸载定时器的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">componentDidMount() &#123;</div><div class="line">    this.timer = setTimeout(</div><div class="line">      () =&gt; &#123; console.log(&apos;把一个定时器的引用挂在this上&apos;); &#125;,</div><div class="line">      500</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">componentWillUnmount() &#123;</div><div class="line">    // 请注意Un&quot;m&quot;ount的m是小写</div><div class="line">    // 如果存在this.timer，则使用clearTimeout清空。</div><div class="line">    // 如果你使用多个timer，那么用多个变量，或者用个数组来保存引用，然后逐个clear</div><div class="line">    this.timer &amp;&amp; clearTimeout(this.timer);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里的timer是在<code>DidMount</code>中赋值的，如果是多次赋值呢？比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">export default class test extends Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">        &lt;Button title=&#123;&apos;click5000&apos;&#125; onPress=&#123;this.alertInfo.bind(this,5000)&#125; /&gt;</div><div class="line">        &lt;Button title=&#123;&apos;click2000&apos;&#125; onPress=&#123;this.alertInfo.bind(this,2000)&#125; /&gt;</div><div class="line">        &lt;Button title=&#123;&apos;clean timer&apos;&#125; onPress=&#123;this.cleanTimer.bind(this)&#125; /&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  alertInfo(time)&#123;</div><div class="line">      this.timer = setTimeout(</div><div class="line">          ()=&gt;&#123;</div><div class="line">            alert(&apos;hah&apos;);</div><div class="line">          &#125;,</div><div class="line">          time,</div><div class="line">      );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  cleanTimer()&#123;</div><div class="line">    this.timer &amp;&amp; clearTimeout(this.timer);</div><div class="line">    console.log(&apos;timer cleared&apos;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">AppRegistry.registerComponent(&apos;test&apos;, () =&gt; test);</div></pre></td></tr></table></figure>
<p>这里要介绍下<code>setTimeout</code>的返回值，我们打断点可以看到，<code>this.timer</code>是一个number。根据stack上面的其他网友的回答<a href="https://stackoverflow.com/questions/10068981/what-does-settimeout-return" target="_blank" rel="noopener">what-does-settimeout-return</a>，setTimer会返回一个id，代表你已经向js的runtime系统中成功注册了一个定时器任务，这个id就是系统返回的id。</p>
<p>那如果是需要多次赋值，就一定要先将time clear掉，然后再赋值，或者使用多个参数来标志，否则之后就找不到上次的id，也就没办法clear了，同样可能造成内存泄露的情况。</p>
<p>例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Sample React Native App</div><div class="line"> * https://github.com/facebook/react-native</div><div class="line"> * @flow</div><div class="line"> */</div><div class="line"></div><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">import &#123;</div><div class="line">  AppRegistry,</div><div class="line">  StyleSheet,</div><div class="line">  Text,</div><div class="line">  View,</div><div class="line">  Button</div><div class="line">&#125; from &apos;react-native&apos;;</div><div class="line"></div><div class="line">export default class test extends Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">        &lt;Button title=&#123;&apos;click5000&apos;&#125; onPress=&#123;this.alertInfo.bind(this,5000)&#125; /&gt;</div><div class="line">        &lt;Button title=&#123;&apos;click2000&apos;&#125; onPress=&#123;this.alertInfo.bind(this,2000)&#125; /&gt;</div><div class="line">        &lt;Button title=&#123;&apos;clean timer&apos;&#125; onPress=&#123;this.cleanTimer.bind(this)&#125; /&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  alertInfo(time)&#123;</div><div class="line">      this.timer = setTimeout(</div><div class="line">          ()=&gt;&#123;</div><div class="line">            alert(&apos;hah&apos;);</div><div class="line">          &#125;,</div><div class="line">          time,</div><div class="line">      );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  cleanTimer()&#123;</div><div class="line">    this.timer &amp;&amp; clearTimeout(this.timer);</div><div class="line">    console.log(&apos;timer cleared&apos;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line">  container: &#123;</div><div class="line">    flex: 1,</div><div class="line">    justifyContent: &apos;center&apos;,</div><div class="line">    alignItems: &apos;center&apos;,</div><div class="line">    backgroundColor: &apos;#F5FCFF&apos;,</div><div class="line">  &#125;,</div><div class="line">  welcome: &#123;</div><div class="line">    fontSize: 20,</div><div class="line">    textAlign: &apos;center&apos;,</div><div class="line">    margin: 10,</div><div class="line">  &#125;,</div><div class="line">  instructions: &#123;</div><div class="line">    textAlign: &apos;center&apos;,</div><div class="line">    color: &apos;#333333&apos;,</div><div class="line">    marginBottom: 5,</div><div class="line">  &#125;,</div><div class="line">&#125;);</div><div class="line"></div><div class="line">AppRegistry.registerComponent(&apos;test&apos;, () =&gt; test);</div></pre></td></tr></table></figure>
<p>这里的timer多次赋值，虽然前面的值被后面的覆盖，但是前面的time仍然会起效果，如果不想前面的time work，需要clear掉，然后再赋值。</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">alertInfo(time)&#123;</div><div class="line">		this.timer &amp;&amp; clearTimeout(this.timer);</div><div class="line">      this.timer = setTimeout(</div><div class="line">          ()=&gt;&#123;</div><div class="line">            alert(&apos;hah&apos;);</div><div class="line">          &#125;,</div><div class="line">          time,</div><div class="line">      );</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>综上，使用time的注意点：</p>
<ol>
<li>记得unmount的时候，clear</li>
<li>多个timer要使用多个变量或者数组</li>
<li>多次赋值，记得把之前的值clear掉</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;time&lt;/code&gt;是&lt;code&gt;react-native&lt;/code&gt;提供的一个定时器，在实际使用中，经常会有使用不对，造成内存泄露的情况。很多&lt;code&gt;React Native&lt;/code&gt;应用发生致命错误（闪退）是与计时器有关。具体来说，是在某个组件被
    
    </summary>
    
      <category term="react-native" scheme="https://github.com/njafei/njafei.github.io/categories/react-native/"/>
    
    
      <category term="react-native" scheme="https://github.com/njafei/njafei.github.io/tags/react-native/"/>
    
      <category term="注意事项" scheme="https://github.com/njafei/njafei.github.io/tags/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>listView和FlatList的flexGrow默认值为1</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/07/26/listViewFlexGrowDefaultValue/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/07/26/listViewFlexGrowDefaultValue/</id>
    <published>2017-07-26T11:27:06.000Z</published>
    <updated>2017-10-19T03:37:16.728Z</updated>
    
    <content type="html"><![CDATA[<p>今天遇到了适配的问题，有个列表，需要自适应高度，按理说默认应该就是自适应的，但是在实际中发现，其会和另外一个视图1：1 ，然后就发现只有设置其<code>flexGrow: 0</code>的时候，它才会自动适配高度，说明它的flexGrow默认值为1.</p>
<p>看下具体的列子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">import &#123;</div><div class="line">  AppRegistry,</div><div class="line">  StyleSheet,</div><div class="line">  Text,</div><div class="line">  View,</div><div class="line">  ListView,</div><div class="line">&#125; from &apos;react-native&apos;;</div><div class="line"></div><div class="line">export default class testListView extends Component &#123;</div><div class="line">    constructor(props) &#123;</div><div class="line">        super(props);</div><div class="line">        const ds = new ListView.DataSource(&#123;rowHasChanged: (r1, r2) =&gt; r1 !== r2&#125;);</div><div class="line">        this.state = &#123;</div><div class="line">            dataSource: ds.cloneWithRows([</div><div class="line">                &apos;John&apos;, &apos;Joel&apos;, &apos;James&apos;, &apos;Jimmy&apos;, &apos;Jackson&apos;, &apos;Jillian&apos;, &apos;Julie&apos;, &apos;Devin&apos;</div><div class="line">            ])</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">        &lt;View style=&#123;styles.blackView&#125; /&gt;</div><div class="line">        &lt;ListView</div><div class="line">            dataSource=&#123;this.state.dataSource&#125;</div><div class="line">            renderRow=&#123;(rowData) =&gt; &lt;Text&gt;&#123;rowData&#125;&lt;/Text&gt;&#125;</div><div class="line">            style=&#123;styles.list&#125;</div><div class="line">        /&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line">  container: &#123;</div><div class="line">    flexGrow: 1,</div><div class="line">    backgroundColor: &apos;#F5FCFF&apos;,</div><div class="line">  &#125;,</div><div class="line">  list:&#123;</div><div class="line">    backgroundColor: &apos;red&apos;,</div><div class="line">  &#125;,</div><div class="line">  blackView: &#123;</div><div class="line">    flexGrow: 1,</div><div class="line">    backgroundColor: &apos;black&apos;,</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">AppRegistry.registerComponent(&apos;testListView&apos;, () =&gt; testListView);</div></pre></td></tr></table></figure>
<p>这个UI看起来是这样： </p>
<p><img src="http://on0hv7n2x.bkt.clouddn.com/Simulator%20Screen%20Shot%202017%E5%B9%B47%E6%9C%8826%E6%97%A5%20%E4%B8%8B%E5%8D%887.20.31.png" alt=""></p>
<p>如果style中的list改成这样，就好了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">list:&#123;</div><div class="line">    backgroundColor: &apos;red&apos;,</div><div class="line">    flexGrow: 0,  </div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>显示成： </p>
<p><img src="http://on0hv7n2x.bkt.clouddn.com/Simulator%20Screen%20Shot%202017%E5%B9%B47%E6%9C%8826%E6%97%A5%20%E4%B8%8B%E5%8D%887.21.58.png" alt=""></p>
<p>综上，我怀疑<code>FlatList和ListView</code>的<code>flexGrow</code>默认值是1.有遇到类似问题的，不妨试试这样解决。</p>
<p>版本： “react-native”: “0.43.4”</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天遇到了适配的问题，有个列表，需要自适应高度，按理说默认应该就是自适应的，但是在实际中发现，其会和另外一个视图1：1 ，然后就发现只有设置其&lt;code&gt;flexGrow: 0&lt;/code&gt;的时候，它才会自动适配高度，说明它的flexGrow默认值为1.&lt;/p&gt;
&lt;p&gt;看下
    
    </summary>
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/categories/React-Native/"/>
    
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/tags/React-Native/"/>
    
      <category term="奇怪的bug" scheme="https://github.com/njafei/njafei.github.io/tags/%E5%A5%87%E6%80%AA%E7%9A%84bug/"/>
    
  </entry>
  
  <entry>
    <title>如何访问和修改一个对象的私有属性</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/06/15/howToChangeObjectProperty/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/06/15/howToChangeObjectProperty/</id>
    <published>2017-06-15T10:03:36.000Z</published>
    <updated>2017-10-19T03:37:16.728Z</updated>
    
    <content type="html"><![CDATA[<p>有两个思路：</p>
<ul>
<li>KVC</li>
<li>runtime</li>
</ul>
<p>先给出我们接下来要使用的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@interface Person : NSObject</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@interface Person()</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *name;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Person</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h1 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h1><p>KVC是我比较推荐的，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Person *person = [Person new];</div><div class="line">    </div><div class="line">[person setValue:@&quot;new name&quot; forKey:@&quot;name&quot;];</div><div class="line"></div><div class="line">NSString *name = [person valueForKey:@&quot;name&quot;];</div></pre></td></tr></table></figure>
<p>KVC是苹果推荐用来做类似事情的方法，所以这种需求，KVC解决是最好的，代码简洁，效率也比较高。<br>关于KVC的相关内容可以看下<a href="https://njafei.github.io/2017/04/18/KVC/" target="_blank" rel="noopener">KVC详解</a></p>
<h1 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h1><p>runtime的思路就是先读取对象的所有属性，然后找到对象的属性，赋值。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Person *person = [Person new];</div><div class="line"></div><div class="line">unsigned int count = 0; //count记录变量的数量</div><div class="line"></div><div class="line">Ivar *members = class_copyIvarList([person class], &amp;count);</div><div class="line">for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">    Ivar ivar = members[i];</div><div class="line">    const char *memberName = ivar_getName(ivar);</div><div class="line">    NSString *memberNameString = [NSString stringWithFormat:@&quot;%s&quot;,memberName];</div><div class="line">    </div><div class="line">    if ([memberNameString isEqualToString: @&quot;_name&quot;]) &#123;</div><div class="line">        object_setIvar(person, ivar, @&quot;newName&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>runtime的做法相对来讲代码比较多，也不够简洁，但是还是可以实现这个需求的。runtime的详细内容可以参考<a href="https://njafei.github.io/2017/05/04/runtime/" target="_blank" rel="noopener">iOS Runtime 详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有两个思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;KVC&lt;/li&gt;
&lt;li&gt;runtime&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先给出我们接下来要使用的类：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/njafei/njafei.github.io/categories/iOS/"/>
    
    
      <category term="iOS面试题" scheme="https://github.com/njafei/njafei.github.io/tags/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Error RawText ** must be wrapped in an explicit &lt;Text&gt; component 问题解决</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/06/14/stringToBoolError/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/06/14/stringToBoolError/</id>
    <published>2017-06-14T03:05:55.000Z</published>
    <updated>2017-10-19T03:37:16.734Z</updated>
    
    <content type="html"><![CDATA[<p>今天忽然遇到一个页面崩溃，查到错误如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error: RawText &quot;&quot; must be wrapped in an explicit &lt;Text&gt; component.</div></pre></td></tr></table></figure>
<p>查了代码，发现好久都没有动这块的代码了，所以非常疑惑。最后通过2分法不停地查哪里出了问题，最终查到了这个语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">return (</div><div class="line">    &lt;View&gt;</div><div class="line">        &#123;test &amp;&amp; test.string &amp;&amp;</div><div class="line">        &lt;Text&gt;&#123;test.string&#125;&lt;/Text&gt;</div><div class="line">        &#125;</div><div class="line">    &lt;/View&gt;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>其实作用很简单，如果string有值，则展示string。但是这条语句为什么会报错呢？查了半天，发现是因为string的值是’’,然后系统就报错了，类似这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let test = &#123;string: &apos;&apos;&#125;;</div><div class="line">return (</div><div class="line">    &lt;View&gt;</div><div class="line">        &#123;test &amp;&amp; test.string &amp;&amp;</div><div class="line">        &lt;Text&gt;&#123;test.string&#125;&lt;/Text&gt;</div><div class="line">        &#125;</div><div class="line">    &lt;/View&gt;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>后来查了下github，发现很多人也遇到了类似的错误，解决办法如下,使用!!来判断string是否有值，因为这里其实你是希望将<code>string</code>当成<code>bool</code>来使用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let test = &#123;string: &apos;&apos;&#125;;</div><div class="line">return (</div><div class="line">    &lt;View&gt;</div><div class="line">        &#123;test &amp;&amp; !!test.string &amp;&amp;</div><div class="line">        &lt;Text&gt;&#123;test.string&#125;&lt;/Text&gt;</div><div class="line">        &#125;</div><div class="line">    &lt;/View&gt;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>所以以后string的判断，都用!!去判断，否则出现string恰好为’’的时候，就会崩溃。</p>
<p>参考文章：</p>
<ul>
<li><a href="https://github.com/GeekyAnts/NativeBase/issues/186">https://github.com/GeekyAnts/NativeBase/issues/186</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天忽然遇到一个页面崩溃，查到错误如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class
    
    </summary>
    
      <category term="bugFix" scheme="https://github.com/njafei/njafei.github.io/categories/bugFix/"/>
    
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/tags/React-Native/"/>
    
      <category term="奇怪的bug" scheme="https://github.com/njafei/njafei.github.io/tags/%E5%A5%87%E6%80%AA%E7%9A%84bug/"/>
    
  </entry>
  
</feed>
