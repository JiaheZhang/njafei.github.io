<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>njafei&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/njafei/njafei.github.io/"/>
  <updated>2017-04-17T02:52:12.000Z</updated>
  <id>https://github.com/njafei/njafei.github.io/</id>
  
  <author>
    <name>njafei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RN 最容易crash的代码用法及应对措施（持续更新）</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/04/17/RN-Crash-Reasons/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/04/17/RN-Crash-Reasons/</id>
    <published>2017-04-17T02:37:55.000Z</published>
    <updated>2017-04-17T02:52:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量保护"><a href="#变量保护" class="headerlink" title="变量保护"></a>变量保护</h2><p>出现最多的就是在使用redux来做数据层，使用this.props的属性没有去查询时候为undefined，这种情况，基本是必crash</p>
<p>比如下例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//show user name</div><div class="line">&lt;Text&gt;&#123;this.props.userInfo.name&#125;&lt;/Text&gt;</div></pre></td></tr></table></figure>
<p>如果userInfo为undefined的话，就会崩溃，错误如下：</p>
<blockquote>
<p>TypeError: Cannot read property ‘name’ of undefined</p>
</blockquote>
<p>在这里name为undefined的时候反而没有问题，因为name是一个简单的属性，直接赋值给Text是没有问题的。</p>
<p>那如何避免这种问题呢？在赋值前加下判断会比较好：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let name = this.props.userInfo &amp;&amp; this.props.userInfo.name ? this.props.userInfo.name : &apos;&apos;;</div><div class="line"></div><div class="line">//show user name</div><div class="line">&lt;Text&gt;&#123;this.props.userInfo.name&#125;&lt;/Text&gt;</div></pre></td></tr></table></figure>
<p>这样基本可以避免崩溃的问题了。</p>
<p>但是如果都这样判断，实际是比较复杂的，所以如果你的业务比较简单，我建议可以直接在render做一个大的保护，即没有数据的时候，不去render这些业务内容.<br>思路如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">render()&#123;</div><div class="line">	if(!this.props.userInfo)&#123;</div><div class="line">		return (</div><div class="line">			&lt;EmptyView /&gt;</div><div class="line">		)</div><div class="line">	&#125; else &#123;</div><div class="line">		return (</div><div class="line">			//注意，如果name的层级更深，还是建议做保护</div><div class="line">			&lt;Text&gt;&#123;this.props.userInfo.name&#125;&lt;/Text&gt;</div><div class="line">		)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>定时器其实在iOS中也是一个非常容易出问题的地方，crash率会比较高。究其原因，我想是主要是因为定时器存在一个事件发生的延后性（废话嘛0_o）,但是很多时候会忘记，当定时任务真的发生的时候，语境变化了吗？如果语境都已经被dealloc了，定时任务仍然被激活，系统就会愤怒地罢工了。</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">componentDidMount() &#123;</div><div class="line">    setTimeout(</div><div class="line">      () =&gt; &#123; console.log(&apos;这就可能会崩溃&apos;); &#125;,</div><div class="line">      500</div><div class="line">    );</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>如果500ms之内，这个component就会Unmount了，那直接回崩溃。RN官方的建议如下：</p>
<h4 id="TimerMixin"><a href="#TimerMixin" class="headerlink" title="TimerMixin"></a>TimerMixin</h4><p>为了解决这个问题，我们引入了TimerMixin。如果你在组件中引入TimerMixin，就可以把你原本的setTimeout(fn, 500)改为this.setTimeout(fn, 500)(只需要在前面加上this.)，然后当你的组件卸载时，所有的计时器事件也会被正确的清除。</p>
<p>这个库并没有跟着React Native一起发布。你需要在项目文件夹下输入npm i react-timer-mixin –save来单独安装它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var TimerMixin = require(&apos;react-timer-mixin&apos;);</div><div class="line"></div><div class="line">var Component = React.createClass(&#123;</div><div class="line">  mixins: [TimerMixin],</div><div class="line">  componentDidMount: function() &#123;</div><div class="line">    this.setTimeout(</div><div class="line">      () =&gt; &#123; console.log(&apos;这样我就不会导致内存泄露!&apos;); &#125;,</div><div class="line">      500</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="代码保护（推荐）"><a href="#代码保护（推荐）" class="headerlink" title="代码保护（推荐）"></a>代码保护（推荐）</h4><p>Mixin属于ES5语法，对于ES6代码来说，无法直接使用Mixin。如果你的项目是用ES6代码编写，同时又使用了计时器，那么你只需铭记在unmount组件时清除（clearTimeout/clearInterval）所有用到的定时器，那么也可以实现和TimerMixin同样的效果。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import React,&#123;</div><div class="line">  Component</div><div class="line">&#125; from &apos;react&apos;;</div><div class="line"></div><div class="line">export default class Hello extends Component &#123;</div><div class="line">  componentDidMount() &#123;</div><div class="line">    this.timer = setTimeout(</div><div class="line">      () =&gt; &#123; console.log(&apos;把一个定时器的引用挂在this上&apos;); &#125;,</div><div class="line">      500</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">  componentWillUnmount() &#123;</div><div class="line">    // 如果存在this.timer，则使用clearTimeout清空。</div><div class="line">    // 如果你使用多个timer，那么用多个变量，或者用个数组来保存引用，然后逐个clear</div><div class="line">    this.timer &amp;&amp; clearTimeout(this.timer);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我今天看了我们项目的代码，发现几乎没有人做保护，代码copy的现象，真的是令人发指，可能很多人都没仔细看过官方的文档。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;变量保护&quot;&gt;&lt;a href=&quot;#变量保护&quot; class=&quot;headerlink&quot; title=&quot;变量保护&quot;&gt;&lt;/a&gt;变量保护&lt;/h2&gt;&lt;p&gt;出现最多的就是在使用redux来做数据层，使用this.props的属性没有去查询时候为undefined，这种情况，基本是
    
    </summary>
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/categories/React-Native/"/>
    
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>如何给同一个电脑上的不同git项目设置不同的name和email</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/04/11/settingNameAndEmailForEachProject/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/04/11/settingNameAndEmailForEachProject/</id>
    <published>2017-04-11T06:38:15.000Z</published>
    <updated>2017-04-11T14:39:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在自己的电脑上同时使用github和公司的git仓库，带来了一个问题就是之前只是设置了全局的name和email，但是两边的代码需要使用不同的user，每次都要手动去改，然后我搜索了下，发现其实我们可以给每个git项目，单独配置一个name和email的。规则如下：</p>
<blockquote>
<p>如果项目由独立配置，则使用独立配置，如果没有独立配置，则使用全局配置</p>
</blockquote>
<p>命令就很简单了：<br>全局name和email配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name gitaccount</div><div class="line">$ git config --global user.email gitaccount@example.com</div></pre></td></tr></table></figure>
<p>给单独的git项目设定配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cd gitFolder</div><div class="line">$ git config --global user.name gitaccount</div><div class="line">$ git config --global user.email gitaccount@example.com</div></pre></td></tr></table></figure>
<p>这样，如果本地有多个git user 或者多个项目的话，使用起来就比较方便了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在自己的电脑上同时使用github和公司的git仓库，带来了一个问题就是之前只是设置了全局的name和email，但是两边的代码需要使用不同的user，每次都要手动去改，然后我搜索了下，发现其实我们可以给每个git项目，单独配置一个name和email的。规则如下：&lt;/
    
    </summary>
    
      <category term="小知识" scheme="https://github.com/njafei/njafei.github.io/categories/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="git" scheme="https://github.com/njafei/njafei.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>React_Native拆分bundle之patch拆包</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/04/06/React-Native-Seperate-Bundle/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/04/06/React-Native-Seperate-Bundle/</id>
    <published>2017-04-06T02:26:41.000Z</published>
    <updated>2017-04-06T08:23:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要拆包"><a href="#为什么要拆包" class="headerlink" title="为什么要拆包"></a>为什么要拆包</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>随着RN的包越来越大，第一次载入RN包的时长越来越长，用户需要等待的时间也就越长，体验较差。另外多个团队开发的话，互相之间的依赖也是个大问题，出现编译不过的话，就会出现水桶效应，所有的团队都要等待这个有问题的团队，从而拉低了整体的效率。</p>
<p>另外我一直希望，能够将React-Native的业务功能，做成类似小程序一样：即用即载入，随时可以更新。想想我们的app里面包含了多少个用户也许永远用不到的功能，还有当我们希望上一个新功能的时候，一定要等待新的版本的审核，这给运营等带来了巨大的麻烦和风险。如果用户点击某个功能，然后马上载入线上的webBundle，用户之后就可以直接使用我们的最新功能了，以后再次进入的时候，也无需等待，那该多好。</p>
<h2 id="拆包目标"><a href="#拆包目标" class="headerlink" title="拆包目标"></a>拆包目标</h2><p>所以我们拆包的目标就很明确了：</p>
<pre><code>1. 优化载入时间，提高用户体验
2. 解开依赖关系，提高开发效率
3. 实现webBundle，即用即载入
</code></pre><p>示意图如下：<br><img src="http://on0hv7n2x.bkt.clouddn.com/React-Native%E6%8B%86%E5%8C%85%E6%96%B9%E6%A1%88%E7%BB%93%E6%9E%84%E5%9B%BE.jpeg" alt=""></p>
<h2 id="国外国内app拆包情况"><a href="#国外国内app拆包情况" class="headerlink" title="国外国内app拆包情况"></a>国外国内app拆包情况</h2><p>上面啰嗦了为什么想要去拆包，好像是蛮有必要的O_o。但是当我去看国内外著名的app使用React-Native的情况时，发现真的是泾渭分明：国内基本都拆包了，包括携程、QQ音乐等，而国外没有拆包的，比如React-Native的创造者FaceBook，虽然他们的包大小已经到了10M。</p>
<p>不禁让我很疑惑，难道国外没有这个需求么？为什么拆包和热更新等几乎国内的硬需求，他们却好像完全没有这方面的需求。希望有读者知道的话可以告知我~</p>
<h1 id="拆包的几种方案"><a href="#拆包的几种方案" class="headerlink" title="拆包的几种方案"></a>拆包的几种方案</h1><p>在讲具体的方案之前，我们先看下，React-Native的包，究竟是如何打出来，然后是怎么载入到native中的。</p>
<h2 id="如何打包"><a href="#如何打包" class="headerlink" title="如何打包"></a>如何打包</h2><p>这里我直接使用QQ技术团队的一张图：<br><img src="http://on0hv7n2x.bkt.clouddn.com/React-NativeJsBundle%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B" alt=""></p>
<h2 id="如何载入"><a href="#如何载入" class="headerlink" title="如何载入"></a>如何载入</h2><p>这里主要讲下iOS React-Native0.39版本的情况。<br>RN提供了两种形式来载入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1. - (NSURL *)sourceURLForBridge:(RCTBridge *)bridge</div><div class="line">2. - (void)loadSourceForBridge:(RCTBridge *)bridge</div><div class="line">                 onProgress:(RCTSourceLoadProgressBlock)onProgress</div><div class="line">                 onComplete:(RCTSourceLoadBlock)loadCallback;</div></pre></td></tr></table></figure>
<p>第一种数据是默认模式，第二种是可以控制载入中的各个步骤。这块可以看下RCTBridgeDelegate。</p>
<h2 id="主流方案"><a href="#主流方案" class="headerlink" title="主流方案"></a>主流方案</h2><p>在网上查了相关的资料，主流的方案基本都是把Main.jsbundl拆分成基础包common.jsbundle+业务包bundle，和上面拆包目标基本一样，不赘述。</p>
<p>具体的拆分思路就很不一样了：</p>
<pre><code>1. 侵入RN代码，修改打包流程，使得打出来的包就是基础+业务包，如QQ音乐
2. 在RN打包的基础上，实现新的打包方案，如携程 moles-Packer
3. Patch方案，打包流程不变，生成基础包后，根据diff来生成每个业务不同的patch包
</code></pre><h1 id="patch方案"><a href="#patch方案" class="headerlink" title="patch方案"></a>patch方案</h1><p>因为方案1和方案要随着RN的升级，不断调整，成本比较高，而且要投入较多的人力，所以我们先看下方案3。</p>
<p>先说下patch，patch就是根据特定算法，讲两个不同的事物diff比较，然后生成的包含两个事物差别的包。我们这里使用的是google的<code>diffAndPatch</code>算法。</p>
<p><img src="http://on0hv7n2x.bkt.clouddn.com/React-Native%E7%94%9F%E6%88%90%E5%8C%85.png" alt=""></p>
<h2 id="基础包common-jsbundle"><a href="#基础包common-jsbundle" class="headerlink" title="基础包common.jsbundle"></a>基础包common.jsbundle</h2><p>首先我们先生成基础包common.jsbundle.这里我们写一个空的js文件，只包含react-native头文件common.ios.js：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import React from &apos;react&apos;; </div><div class="line">import &#123;&#125; from &apos;react-native&apos;;</div></pre></td></tr></table></figure>
<p>然后我们基于这单个文件打包，打出来的包就是只包含react-native基础框架的bundle，我们成为common.jsbundle.</p>
<p>注：</p>
<p>RN打包过程中会做混淆，所有的类最终都变成了代号为数字的function，所以这里顺序就非常重要，而对基础包的引用顺序就要严格和common.ios.js一样了，这里建议所有的业务代码直接引用common.ios.js文件。另外如果有公共组件等，也都可以放到common.ios.js文件中，这样就会被包含在基础包中了。</p>
<h2 id="业务包-business-patch"><a href="#业务包-business-patch" class="headerlink" title="业务包 business.patch"></a>业务包 business.patch</h2><p>每条业务线的代码，都需要单独维护自己的indexBisiness.js,打包的时候，入口文件就是这个index，这样就打出来了一个业务business.bundle。<br>然后使用diff，计算出业务patch。这样就算出了patch，我们叫做business.patch</p>
<h2 id="native方案"><a href="#native方案" class="headerlink" title="native方案"></a>native方案</h2><p>现在我们已经有了common.jsbundle + bisiness1.patch + business2.patch + …<br>如果打开了bisiness1中的home.js，我们首先要将common.jsbundle和bisiness1.patch使用算法合并，计算出最终bisiness1.jsbundle.然后通过上面讲到的native载入方案载入具体的bundle。</p>
<p>根据当前的bridgeName生成bisiness bundle</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">- (NSString *)getNewBundle</div><div class="line">&#123;</div><div class="line">  </div><div class="line">  NSString *commonBundlePath = [[NSBundle mainBundle] pathForResource:@&quot;common&quot; ofType:@&quot;jsbundle&quot;];</div><div class="line">  NSString *commonBundleJSCode = [[NSString alloc] initWithContentsOfFile:commonBundlePath encoding:NSUTF8StringEncoding error:nil];</div><div class="line">  </div><div class="line">  NSString *patch1Path = [[NSBundle mainBundle] pathForResource:self.bridgeName ofType:@&quot;patch&quot;];</div><div class="line">  NSString *patch1JSCode = [[NSString alloc] initWithContentsOfFile:patch1Path encoding:NSUTF8StringEncoding error:nil];</div><div class="line">  </div><div class="line">  </div><div class="line">  DiffMatchPatch *diffMatchPatch = [[DiffMatchPatch alloc] init];</div><div class="line">  NSArray *convertedPatches = [diffMatchPatch patch_fromText:patch1JSCode error:nil];</div><div class="line">  </div><div class="line">  NSArray *resultsArray = [diffMatchPatch patch_apply:convertedPatches toString:commonBundleJSCode];</div><div class="line">  NSString *resultJSCode = resultsArray[0]; //patch合并后的js</div><div class="line">  </div><div class="line">  </div><div class="line">  NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</div><div class="line">  NSString *docDir = [paths objectAtIndex:0];</div><div class="line">  NSString *newPath = [NSString stringWithFormat:@&quot;%@/%@.jsbundle&quot;,docDir,self.bridgeName];</div><div class="line">  </div><div class="line">  if (resultsArray.count &gt; 1) &#123;</div><div class="line">    [resultJSCode writeToFile:newPath atomically:NO encoding:NSUTF8StringEncoding error:nil];</div><div class="line">    return newPath;</div><div class="line">  &#125;</div><div class="line">  else &#123;</div><div class="line">    return @&quot;&quot;;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>加载bisiness bundle：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge</div><div class="line">&#123;</div><div class="line">    NSString *path = [[NSBundle mainBundle] pathForResource:self.bridgeName ofType:@&quot;jsbundle&quot;];</div><div class="line">    NSURL *jsBundleURL = [NSURL URLWithString:path];</div><div class="line">  </div><div class="line">  return jsBundleURL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，code就基本完成了。如果想看所有的代码，请看底部的githubDemo</p>
<h2 id="方案优缺点"><a href="#方案优缺点" class="headerlink" title="方案优缺点"></a>方案优缺点</h2><p>优点：</p>
<pre><code>1. 技术方案简单，实现快
2. 稳定、不用担心RN升级问题
3. 业务互相独立
4. 方便后面做web bundle
</code></pre><p>缺点：</p>
<pre><code>1. 内存占用大
2. 打包会变大
3. 业务之间资源和代码没法互相引用
</code></pre><h2 id="优化和拓展计划"><a href="#优化和拓展计划" class="headerlink" title="优化和拓展计划"></a>优化和拓展计划</h2><pre><code>1. 打包可以不用patch的方案，采用脚本逐行写入
2.web bundle 可以直接基于这个方案做
3.如果解决了函数命名和依赖的问题，就可以采用一个bundle策略
</code></pre><h2 id="Demo-in-github"><a href="#Demo-in-github" class="headerlink" title="Demo in github"></a>Demo in github</h2><p><a href="https://github.com/njafei/ReactNativeSeperateBundle">ReactNativeSeperateBundle</a></p>
<ol>
<li>cd ReactNativeSeperateBundle</li>
<li>npm install</li>
<li>run project</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;为什么要拆包&quot;&gt;&lt;a href=&quot;#为什么要拆包&quot; class=&quot;headerlink&quot; title=&quot;为什么要拆包&quot;&gt;&lt;/a&gt;为什么要拆包&lt;/h1&gt;&lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背
    
    </summary>
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/categories/React-Native/"/>
    
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>iOS 响应链 Responder Chain</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/03/29/Responder-chain/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/03/29/Responder-chain/</id>
    <published>2017-03-29T07:12:33.000Z</published>
    <updated>2017-03-29T09:21:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h1><p>iOS设备和用户的交互其实有很多种方式，包括触摸屏幕，摇晃设备，多媒体控制（音量等）等。当设备检测到这三种事件中的一种的时候，iOS就会捕获当前事件的时间和内容，然后发出消息，通知App发生了事件，这个就是<code>Event</code>。<br><img src="http://on0hv7n2x.bkt.clouddn.com/UIEvent_Type.png" alt="UIEvent category"></p>
<h1 id="Responder"><a href="#Responder" class="headerlink" title="Responder"></a>Responder</h1><p>有了<code>Event</code>之后，系统需要找到能够处理这个<code>event</code>的对象，而能够处理event的对象，就是<code>UIResponder</code>.我们常用的<code>UIApplication</code>、<code>UIView</code>、<code>UIViewController</code>，其实都是<code>UIResponder</code>的实例。<code>UIResponder</code>为了要处理特定的事件，要实现<code>corresponding</code>方法。比如touch事件，那么<code>Responder</code>就要实现<code>touchesBegan：withEvent</code>,<code>touchedMoved:withEvent:</code>等方法。</p>
<p><img src="http://on0hv7n2x.bkt.clouddn.com/UIResponder.png" alt="UIResponder"></p>
<h1 id="Responder-Chain"><a href="#Responder-Chain" class="headerlink" title="Responder Chain"></a>Responder Chain</h1><p>如果有当前的界面有多个Responder的时候，到底是谁来响应呢？这里其实是根据特定的一个顺序，依次寻找响应的对象，这个就叫响应链（<code>Responder Chain</code>）机制了。在<code>Responder Chain</code>中，系统首先<code>UIkit</code>会按照一定的规则（下节会讲到）来找到当前的<code>first responder</code>，通常是事件发生的<code>view</code>，我们叫做<code>initial view</code>,然后根据这个view是否有处理的能力（比如touch事件就是看是否实现了上述的<code>touchesBegan：withEvent</code>等方法），如果当前的<code>responder</code>无法处理该事件，那么会响应链的顺序来查找下个响应者，通常的顺序是： view -&gt; super view -&gt; viewController -&gt; window -&gt; UIApplicaiton，如下图：<br><img src="http://on0hv7n2x.bkt.clouddn.com/ResponderChain.png" alt="ResponderChain"></p>
<p>如果到了响应链的最后一个节点，还是没有找到响应者，那么系统就会抛弃这条event。</p>
<h1 id="Hit-Test-View，Hit-Testing"><a href="#Hit-Test-View，Hit-Testing" class="headerlink" title="Hit-Test View，Hit-Testing"></a>Hit-Test View，Hit-Testing</h1><p>那么系统是如何找到<code>first responder</code>的呢？答：使用<code>Hit-Testing</code>。<br>当触摸事件发生时，iOS会使用<code>Hit-Testing</code>超找当前事件所在的<code>view</code>，它会从<code>UIApplication</code>开始，依次往下寻找事件发生的<code>view</code>，直到找到这个<code>view</code>，顺序和上述的响应链，其实是相反的，我怀疑可能响应链就是在<code>Hit-Testing</code>的过程中建立的，但是没有查到相关的资料。</p>
<p>我们看个苹果的官方列子：<br><img src="http://on0hv7n2x.bkt.clouddn.com/Hit-Testing.png" alt=""></p>
<p>如果触摸事件发生在D中，那么系统会依次检查：</p>
<ol>
<li>触摸区域在A中，遍历它的所有subViews</li>
<li>触摸区域在C中，遍历它的所有subViews</li>
<li>触摸事件在D中</li>
</ol>
<p>D就是所谓的<code>Hit-Test View</code>，也是上述的响应链中的<code>first responder</code></p>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><ul>
<li><a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html" target="_blank" rel="external">EventHandlingiPhoneOS 官方文档忽然实效了</a></li>
<li><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/Responder.html#//apple_ref/doc/uid/TP40009071-CH1-SW2" target="_blank" rel="external">Responder object</a></li>
<li><a href="https://www.zybuluo.com/MicroCai/note/66142" target="_blank" rel="external">iOS Events and Responder Chain</a></li>
<li><a href="http://www.jianshu.com/p/05cbcd774f45" target="_blank" rel="external">iOS中的响应链（The Responder Chain）</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Event&quot;&gt;&lt;a href=&quot;#Event&quot; class=&quot;headerlink&quot; title=&quot;Event&quot;&gt;&lt;/a&gt;Event&lt;/h1&gt;&lt;p&gt;iOS设备和用户的交互其实有很多种方式，包括触摸屏幕，摇晃设备，多媒体控制（音量等）等。当设备检测到这三种事件中的一
    
    </summary>
    
      <category term="iOS基础" scheme="https://github.com/njafei/njafei.github.io/categories/iOS%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础知识" scheme="https://github.com/njafei/njafei.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Apple文档翻译之Event-Handing-Guide-for-iOS</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/03/27/Event-Handing-Guide-for-iOS/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/03/27/Event-Handing-Guide-for-iOS/</id>
    <published>2017-03-27T07:38:29.000Z</published>
    <updated>2017-03-28T08:33:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="About-Events-in-iOS"><a href="#About-Events-in-iOS" class="headerlink" title="About Events in iOS"></a>About Events in iOS</h1><p>用户会使用很多的方式来操作他们的iOS设备，比如点击屏幕或者摇晃屏幕。当用户正在操作硬件或者向App传递信息时，iOS会获取时间和方式。你的App给用户的反馈越自然、越直接，用户就会越有兴趣。</p>
<p><img src="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/events_to_app_2x.png" alt=""></p>
<h4 id="AT-a-Glance"><a href="#AT-a-Glance" class="headerlink" title="AT a Glance"></a>AT a Glance</h4><p>Event是当用户有动作时，（<code>UIKit</code>）向App发出的通知。在iOS中，有很多形式的event：多点触摸，滑动、多媒体控制。最后一个事件被熟知为远程控制事件，因为它可以从一个附件中发出。</p>
<h4 id="UIKit让你的App处理手势更轻松"><a href="#UIKit让你的App处理手势更轻松" class="headerlink" title="UIKit让你的App处理手势更轻松"></a>UIKit让你的App处理手势更轻松</h4><p>iOS应用可以识别组合的触摸，然后直接以特定方式反馈，比如收缩的触摸会缩小内容，间隔触摸划过内容等。实际上，很多的手势太常见了，所以他们被内置在<code>UIKit</code>中。比如<a href="https://developer.apple.com/reference/uikit/uicontrol" target="_blank" rel="external">UIControl</a>子类，比如<a href="https://developer.apple.com/reference/uikit/uibutton" target="_blank" rel="external">UIButton</a>和<a href="https://developer.apple.com/reference/uikit/uislider" target="_blank" rel="external">UISlider</a>，回应特殊的手势-button的点击和slider的拖动。当你配置这些control，他们会在触摸发生时，发出一个message给目标。你也可以通过使用gesture recognizers在view上实现这个目标动作。当你给一个view添加一个getsture recognizer，这个view会像一个control一样给你指定的触摸回应。</p>
<p>Gesture recognizer提供了一个高度抽象的复杂事件处理逻辑。当使用触摸事件时，请优选gesture recognizer，因为它们很强大，可复用，适用性强。你也可以使用内置的getsure recognizer然后个性化它的行为。或者你可以创造一个新的gesture recognizer来识别一个新的触摸事件。</p>
<blockquote>
<p>相关章节：<a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/GestureRecognizer_basics/GestureRecognizer_basics.html#//apple_ref/doc/uid/TP40009541-CH2-SW2" target="_blank" rel="external">Gesture Recognizers</a></p>
</blockquote>
<h5 id="一个事件为了找到处理它的对象，要遍历一个特定的路径"><a href="#一个事件为了找到处理它的对象，要遍历一个特定的路径" class="headerlink" title="一个事件为了找到处理它的对象，要遍历一个特定的路径"></a>一个事件为了找到处理它的对象，要遍历一个特定的路径</h5><p>当iOS recognizer是事件时，它首先会将事件传递给初始的看起来最相关的对象，比如touch发生的view。如果初始的对象不能处理事件，<code>iOS</code>会继续传递事件给更大范围的对象，直接它找到了一个对象有足够的上下文处理这个事件。这些对象的序列，就是被熟知的响应链（responder chain），iOS会顺着响应链传递事件，同时它也传递回应事件的责任。这种设计模式让事件处理更加动态和合作性高。</p>
<blockquote>
<p>相关章节 <a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW2" target="_blank" rel="external">响应链 Responder Chain</a></p>
</blockquote>
<h4 id="UIEvent封装了触摸，摇晃，远程控制事件"><a href="#UIEvent封装了触摸，摇晃，远程控制事件" class="headerlink" title="UIEvent封装了触摸，摇晃，远程控制事件"></a>UIEvent封装了触摸，摇晃，远程控制事件</h4><p>许多<code>UIEvent</code>是UIKit <a href="https://developer.apple.com/reference/uikit/uievent" target="_blank" rel="external">UIEvent</a>的实例。一个<code>UIEvent</code>包括了关于事件app需要使用的信息，以决定如何回应这个事件。比如当一个用户事件发生时，手指触摸屏幕或者滑动它的表面，iOS持续的发送event对象给app。每个event对象都有一个type-触摸、摇晃、远程控制来作为它的子类型。</p>
<blockquote>
<p>相关章节： <a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/multitouch_background/multitouch_background.html#//apple_ref/doc/uid/TP40009541-CH5-SW9" target="_blank" rel="external">多点触摸</a>、<a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/motion_event_basics/motion_event_basics.html#//apple_ref/doc/uid/TP40009541-CH6-SW14" target="_blank" rel="external">手势</a>、<a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Remote-ControlEvents/Remote-ControlEvents.html#//apple_ref/doc/uid/TP40009541-CH7-SW3" target="_blank" rel="external">远程控制</a></p>
</blockquote>
<h4 id="当用户触摸界面时，App接收多点触摸事件"><a href="#当用户触摸界面时，App接收多点触摸事件" class="headerlink" title="当用户触摸界面时，App接收多点触摸事件"></a>当用户触摸界面时，App接收多点触摸事件</h4><p>在你的App上，UIKit controls和gesture recognizers 也行足够你来应对触摸事件了。甚至你可以使用Gesture recognizer来定制你的view。根据经验，你会使用触摸事件当你的app回应和view本身绑定的事件，比如摸出画东西。在这些列子中，你只负责低优先级的触摸事件，事件touch method，在method中，你分析未经加工的触摸事件，然后适当回应。</p>
<blockquote>
<p>相关章节 <a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/multitouch_background/multitouch_background.html#//apple_ref/doc/uid/TP40009541-CH5-SW9" target="_blank" rel="external">多点触摸 multitouch Event</a></p>
</blockquote>
<h4 id="当用户移动设备时，App接收到移动事件（Motion-Event）"><a href="#当用户移动设备时，App接收到移动事件（Motion-Event）" class="headerlink" title="当用户移动设备时，App接收到移动事件（Motion Event）"></a>当用户移动设备时，App接收到移动事件（Motion Event）</h4><p>Motion事件提供了关于设备的地点、方向和移动的信息。通过回应Motion事件，你可以提供微量却强大的功能。加速器和陀螺仪数据能让你判断是倾斜、旋转，还是摇晃。</p>
<p>Motion事件有许多形式，你可以通过不同的framework来处理他们。当用户摇晃设备时，<code>UIKit</code>传递<code>UIEvent</code>对象给app。如果你想要app能接收高速、持续的加速器和陀螺仪数据，请使用<code>Core Motion framework</code>。</p>
<blockquote>
<p>相关章节 <a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/motion_event_basics/motion_event_basics.html#//apple_ref/doc/uid/TP40009541-CH6-SW14" target="_blank" rel="external">Motion Event</a></p>
</blockquote>
<h4 id="当用户操作多媒体控制，用户收到远程控制事件"><a href="#当用户操作多媒体控制，用户收到远程控制事件" class="headerlink" title="当用户操作多媒体控制，用户收到远程控制事件"></a>当用户操作多媒体控制，用户收到远程控制事件</h4><p>iOS controls 和外部附件可以给app发送远程控制事件。这些事件允许用户去控制音频和视频，比如通过耳机调整音量。</p>
<blockquote>
<p>相关章节： <a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Remote-ControlEvents/Remote-ControlEvents.html#//apple_ref/doc/uid/TP40009541-CH7-SW3" target="_blank" rel="external">Remote Control Event</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;About-Events-in-iOS&quot;&gt;&lt;a href=&quot;#About-Events-in-iOS&quot; class=&quot;headerlink&quot; title=&quot;About Events in iOS&quot;&gt;&lt;/a&gt;About Events in iOS&lt;/h1&gt;&lt;p&gt;用户
    
    </summary>
    
      <category term="文档翻译" scheme="https://github.com/njafei/njafei.github.io/categories/%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Apple文档" scheme="https://github.com/njafei/njafei.github.io/tags/Apple%E6%96%87%E6%A1%A3/"/>
    
      <category term="基础知识" scheme="https://github.com/njafei/njafei.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Apple文档翻译之UIResponder</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/03/21/UIResponder/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/03/21/UIResponder/</id>
    <published>2017-03-21T07:20:54.000Z</published>
    <updated>2017-03-28T08:34:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>UIResponder</code>是回应和处理事件的抽象接口,<code>UIResponder</code>的实例，包括：<code>UIApplication</code>、<code>UIViewController</code>、<code>UIView</code>（包含<code>UIWindow</code>），组成了<code>UIKit</code>处理事件的核心。当事件发生时，<code>UIKit</code>会把事件派发给<code>UIResponder</code>去处理。</p>
<p>有许多种事件，包括触摸、手势、遥控和点击事件。为了处理特定的事件，一个<code>responder</code>（响应）必须重写<code>corresponding</code>方法。比如，要想处理<code>touch</code>事件，一个<code>responder</code>要实现<code>touchesBegan：withEvent</code>,<code>touchedMoved:withEvent:</code>等方法。在触摸事件的列子中，<code>responder</code>使用UIKit提供的事件信息来追踪触摸的改变，然后适时地更新界面。</p>
<p>除了处理事件，<code>UIKit responder</code>还负责转发那边没有被处理的事件给app的其他部分。如果一个指定的<code>responder</code>没有处理事件，它就会转发这个事件到响应链的下一个<code>responder</code>。UIKit动态地管理响应链，使用预定的规则来决定下一个收到事件的对象。比如：一个<code>view</code>转发事件到它的<code>superView</code>，或者<code>Rootview</code>转发事件给它的v<code>iew controller</code>。</p>
<p><code>Responder</code>处理<code>UIEvent</code>和其他通过输入界面的自定义输入，最典型的就是系统的键盘。当用户点击<code>UITextField</code>和<code>UITextView</code>，这个view变成了第一个<code>responder</code>，然后展示它的输入界面：键盘。同样的，你可以创造一个自定义的输入界面，然后在其他<code>responders</code>活跃的时候展示它。为了把输入界面和<code>responder</code>联系在一起，要把<code>view</code>赋值给<code>responder</code>的属性。</p>
<p>原文链接  <a href="https://developer.apple.com/reference/uikit/uiresponder#//apple_ref/occ/cl/UIResponder" target="_blank" rel="external">UIResponder</a></p>
<p>如果有任何建议和优化的地方，欢迎给我留言。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;UIResponder&lt;/code&gt;是回应和处理事件的抽象接口,&lt;code&gt;UIResponder&lt;/code&gt;的实例，包括：&lt;code&gt;UIApplication&lt;/code&gt;、&lt;code&gt;UIViewController&lt;/code&gt;、&lt;code&gt;UIVie
    
    </summary>
    
      <category term="文档翻译" scheme="https://github.com/njafei/njafei.github.io/categories/%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Apple文档" scheme="https://github.com/njafei/njafei.github.io/tags/Apple%E6%96%87%E6%A1%A3/"/>
    
      <category term="基础知识" scheme="https://github.com/njafei/njafei.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>github pages + hexo 原理探究</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/03/18/githubPagesStudy/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/03/18/githubPagesStudy/</id>
    <published>2017-03-18T13:07:15.000Z</published>
    <updated>2017-03-28T08:29:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>利用一个下午搭建起了github pages + hexo 的静态博客，试用了下效果，还是挺满意的，至少比csdn的页面好看多了，哈哈。<br>搭建的过程中，也遇到了很多的问题，尤其是中间如何把hexo 和github连在一起，又是如何更新博客这块，有很多疑问，我自己尝试，还不小心把本地的hexo的文件删除了，不得不重新init了一个，配置都要重新来一遍，所以这篇文章着重探讨，github pages的流程到底是如何展开的。</p>
<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>先说下<a href="https://pages.github.com/" target="_blank" rel="external">github pages</a>,github pages 是github提供给用户用来展示个人或者项目主页的静态网页系统。每个用户都可以使用自己的github项目创建，上传静态页面的html文件，github会帮你自动更新你的页面。</p>
<p><a href="https://hexo.io/zh-cn/" target="_blank" rel="external">hexo</a>是一个用来生成静态界面的框架，使用hexo，你就可以直接使用mark down 来写文章，而不用关心前端样式的展现。</p>
<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>我们来看下流程图：<br><img src="http://on0hv7n2x.bkt.clouddn.com/github%20pages%20%E6%95%B0%E6%8D%AE%E6%B5%81.png" alt="数据流程图"></p>
<p>这样看就很简单了，我们本地使用markDown语法写好文件，然后执行hexo或者其他静态网页生成工具，生成好静态文件，然后使用hexo等工具的发布功能，就会使用ssh来更新github项目的文件，即生成一个新的commit然后push。github检测到这个项目更新，就会更新你的网站的内容（会有缓存）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;利用一个下午搭建起了github pages + hexo 的静态博客，试用了下效果，还是挺满意的，至少比csdn的页面好看多了，哈哈。&lt;b
    
    </summary>
    
      <category term="闲来研究" scheme="https://github.com/njafei/njafei.github.io/categories/%E9%97%B2%E6%9D%A5%E7%A0%94%E7%A9%B6/"/>
    
    
  </entry>
  
</feed>
