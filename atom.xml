<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>njafei&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/njafei/njafei.github.io/"/>
  <updated>2017-04-28T03:07:40.000Z</updated>
  <id>https://github.com/njafei/njafei.github.io/</id>
  
  <author>
    <name>njafei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQLite-Python学习</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/04/28/sqlite-python/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/04/28/sqlite-python/</id>
    <published>2017-04-28T03:05:29.000Z</published>
    <updated>2017-04-28T03:07:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>注： 本文默认有基本的数据库和SQLite知识</p>
</blockquote>
<p>最近在做SQLite数据库相关的自动化任务，所以学习了下<code>phthon</code>中如何使用<code>SQLite</code>，网上的教程如：<a href="http://www.runoob.com/sqlite/sqlite-python.html" target="_blank" rel="external">runoob</a>、 <a href="https://docs.python.org/2/library/sqlite3.html" target="_blank" rel="external">docs.python</a>等的说明不太详细，而且很多细节和demo都写的比较粗，遂有此文。</p>
<h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>首先我们要连接数据库，要不然没法操作。<code>python</code>2.5之后，内置了<code>sqlite3</code>，所以我们可以直接用内置的命令。</p>
<p>介绍第一个命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sqlite3.connect(database [,timeout ,other optional arguments]);</div></pre></td></tr></table></figure>
<ul>
<li>database： 数据库的path，如果不给，就会创建一个。如果给的“:memory:”，则会创建一个建在RAM上的数据库。</li>
<li>timeout: 默认是5s，当数据库锁定的时候，最长的等待时间</li>
<li><p>optional arguments： 暂时没查到有哪些参数可选</p>
<p>比如我们想要新建一个数据库：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"></div><div class="line">import sqlite3</div><div class="line"></div><div class="line">newData = sqlite3.connect(&apos;new.sqlite&apos;)</div><div class="line">print &quot;open new Database successfully&quot;;</div></pre></td></tr></table></figure>
<p>这样，就建好了一个名为new的数据库，并连接上。</p>
<p>如果想建一个RAM上面的数据库，就使用<code>:memory</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">newData = sqlite3.connect(&apos;:memory:&apos;)</div></pre></td></tr></table></figure>
<p>还可以设置10s的<code>timeout</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">newData = sqlite3.connect(&apos;:memory:&apos;[,10]);</div></pre></td></tr></table></figure>
<p>关闭数据库连接就比较简单了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">newData.close();</div></pre></td></tr></table></figure>
<h1 id="数据库执行SQL语句"><a href="#数据库执行SQL语句" class="headerlink" title="数据库执行SQL语句"></a>数据库执行<code>SQL</code>语句</h1><h4 id="执行简单语句"><a href="#执行简单语句" class="headerlink" title="执行简单语句"></a>执行简单语句</h4><p>这里主要有两种方式：</p>
<ul>
<li>数据库直接执行 <code>connection.execute()</code></li>
<li>通过cursor执行 <code>cursor.execute</code></li>
</ul>
<p>举个例子，我们希望建一个如下的数据表并插入数据：user</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>money</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>jack</td>
<td>100</td>
</tr>
<tr>
<td>1</td>
<td>rose</td>
<td>200</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#create table</div><div class="line">newData.execute(&quot;create table user (id, name, money)&quot;);</div><div class="line"></div><div class="line">#insert data</div><div class="line">newData.execute(&quot;insert into user values (1,&apos;jack&apos;,100)&quot;);</div><div class="line">newData.execute(&quot;insert into user values (2,&apos;rose&apos;,200)&quot;);</div><div class="line"></div><div class="line">#打印看下是否成功</div><div class="line">users = newData.execute(&quot;select * from user&quot;);</div><div class="line">print(&apos;row in new data&apos;);</div><div class="line">for row in users:</div><div class="line">	print row[0],</div><div class="line">	print row[1]</div><div class="line"></div><div class="line">newData.commit();</div><div class="line">newData.close();</div></pre></td></tr></table></figure>
<p>这里面有个注意点：一定要<code>commit</code> 和 <code>close</code> ，否则不会保存。</p>
<blockquote>
<p>commit: 该方法提交当前的事务。如果您未调用该方法，那么自您上一次调用 commit() 以来所做的任何动作对其他数据库连接来说是不可见的。</p>
</blockquote>
<p>这里的<code>execute</code>也可以用cursor执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#获取cursor</div><div class="line">c = localData.cursor()</div><div class="line"></div><div class="line">#cursor执行语句</div><div class="line">c.execute(&quot;select * from user&quot;);</div></pre></td></tr></table></figure>
<h4 id="执行带参数的语句"><a href="#执行带参数的语句" class="headerlink" title="执行带参数的语句"></a>执行带参数的语句</h4><p>如果我们有用到python里声明的变量，就只能通过<code>cursor</code>了。比如想要计算数组的和，放到amy的money中：</p>
<p>这里先介绍下有参数的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cursor.execute(sql, seq_of_parameters)</div><div class="line"></div><div class="line">cursor.execute(&quot;insert into people values (?, ?)&quot;, (who, age))</div></pre></td></tr></table></figure>
<p>execute只接收两个参数，sql和param，sql中的变量名，都用?或者命名代替，然后依次写在参数中。记住，一定要放到一个括号中，否则会认为有三个参数，会报错：<code>TypeError: function takes at most 2 arguments (3 given)</code></p>
<p>实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#获取cursor</div><div class="line">c = localData.cursor()</div><div class="line"></div><div class="line">#计算总和</div><div class="line">name = &apos;amy&apos;;</div><div class="line">total = money + money2 + money3;</div><div class="line"></div><div class="line">#写入rose的钱中</div><div class="line">c.execute(&quot;inset into user value (3, ?, ?)&quot;,(name,total));</div><div class="line"></div><div class="line">#or </div><div class="line">#c.execute(&quot;inset into user value (3, name, money)&quot;,(name,total));</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：这里的connect也可以执行带参数的语句，但是其实都是生成临时cursor执行，所以这两种方法本质是一样的，下文中遇到这两个，只会写一个作为示范。</p>
</blockquote>
<h4 id="处理多组数据"><a href="#处理多组数据" class="headerlink" title="处理多组数据"></a>处理多组数据</h4><p>如果我们希望针对一组数据，执行同样的sql呢？当然可以<code>for: in</code> 来挨个执行，也可以使用批量的数据处理方法：</p>
<ul>
<li><code>cursor.executemany(sql, seq_of_parameters)</code></li>
<li><code>connection.executemany(sql[, parameters])</code> 最终还是通过cursor执行</li>
</ul>
<p>比如刚才的例子，我们不用一条一条数据插入，而是直接插入一个数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">newUsers = [(1,&apos;jack&apos;,100),(2,&apos;rose&apos;,100)];</div><div class="line">newData.executemany(&quot;insert into user values(?,?,?)&quot;,newUsers);</div></pre></td></tr></table></figure>
<h4 id="处理多条语句"><a href="#处理多条语句" class="headerlink" title="处理多条语句"></a>处理多条语句</h4><p>如果是想连续执行多条语句如何呢？</p>
<ul>
<li>cursor.executescript(sql_script)</li>
<li>connection.executescript(sql_script)</li>
</ul>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sqlscript = &quot;&quot;&quot;insert into user values(1,&apos;jack&apos;,100);</div><div class="line">			   insert into user values(2,&apos;rose&apos;,200);&quot;&quot;&quot;</div><div class="line"></div><div class="line">newData.executescript(sqlscript);</div></pre></td></tr></table></figure>
<h1 id="操作cursor"><a href="#操作cursor" class="headerlink" title="操作cursor"></a>操作cursor</h1><p>这里的cursor可以理解为我们变成时候的光标，光标在哪里，我们当前的操作点和关注点就在哪里。而当我们多次操作的时候，可能想要获取当前光标所在的位置。</p>
<p>还是举个例子：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>money</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>jack</td>
<td>100</td>
</tr>
<tr>
<td>2</td>
<td>rose</td>
<td>200</td>
</tr>
<tr>
<td>3</td>
<td>john</td>
<td>200</td>
</tr>
</tbody>
</table>
<p>我希望查到谁的money是200，而且我想获得当前的光标坐在的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">c = newData.cursor();</div><div class="line">c.execute(&quot;select * from user where money = 200&quot;);</div><div class="line">#查第一条</div><div class="line">c.fetchone();//(2,rose,200)</div><div class="line"></div><div class="line"># 查前两条</div><div class="line">c.fetchmany(2);// (2,rose,200),(3,john,200)</div><div class="line"></div><div class="line"># 查所有的</div><div class="line">c.fetchall();//(2,rose,200),(3,john,200)</div><div class="line"></div><div class="line">#如果没有结果返回none</div><div class="line">c.execute(&quot;select * from user where money = 300&quot;);</div><div class="line">c.fetchone();//none</div></pre></td></tr></table></figure>
<p>说实话，刚开始看我是很疑惑的,看起来，这个光标的作用和我直接用一个数组赋值貌似没有什么区别，难道是这样比较方便来获取最后的结果么？</p>
<p>后来问了大神，发现原来光标是这样子的，fetch了一条，光标会下移，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">c.execute(&quot;select * from user where money = 200&quot;);</div><div class="line">print c.fetchone();//(2,rose, 200)</div><div class="line">print c.fetchone();//(3,john,200)</div><div class="line">print c.fetchone();//none</div></pre></td></tr></table></figure>
<p>再结合一些操作光标的操作，就可以实现一些比较复杂的用法了。</p>
<h1 id="操作相关"><a href="#操作相关" class="headerlink" title="操作相关"></a>操作相关</h1><p>数据库的操作和git还是有点相似的，都是有提交，回滚等，我们依次介绍下：</p>
<ul>
<li>connection.commit() 提交修改，否则不会保存</li>
<li>connection.rollback() 回滚上次的commit</li>
<li>connection.close() 关闭数据库连接</li>
<li>connection.total_changes() 查看修改的总行数</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注： 本文默认有基本的数据库和SQLite知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近在做SQLite数据库相关的自动化任务，所以学习了下&lt;code&gt;phthon&lt;/code&gt;中如何使用&lt;code&gt;SQLite&lt;/code&gt;，网上的教程如：
    
    </summary>
    
      <category term="数据库" scheme="https://github.com/njafei/njafei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="sqlite" scheme="https://github.com/njafei/njafei.github.io/tags/sqlite/"/>
    
      <category term="python" scheme="https://github.com/njafei/njafei.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>KVC详解</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/04/18/KVC/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/04/18/KVC/</id>
    <published>2017-04-18T09:58:01.000Z</published>
    <updated>2017-04-18T10:00:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><p>正常访问或者修改一个对象的属性，都是通过getter和setter方法，但是Cocoa仍然提供了一个间接访问属性的方法：KVC（Key-Value Coding）。 只要对象支持<code>NSKeyValueCoding</code>协议，我们就可以通过KVC来间接访问或者修改属性和属性中的更深层的属性。</p>
<p>KVC也是许多Cocoa技术的基础，比如：</p>
<ul>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i" target="_blank" rel="external">KVO</a></li>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CocoaBindings/Concepts/WhatAreBindings.html" target="_blank" rel="external">Cocoa bingdings</a></li>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/index.html#//apple_ref/doc/uid/TP40001075" target="_blank" rel="external">Core Data</a></li>
<li><a href="https://developer.apple.com/library/content/documentation/AppleScript/Conceptual/AppleScriptX/AppleScriptX.html#//apple_ref/doc/uid/10000156i" target="_blank" rel="external">AppleScript</a>。</li>
</ul>
<h3 id="使用KVC的对象"><a href="#使用KVC的对象" class="headerlink" title="使用KVC的对象"></a>使用KVC的对象</h3><p>所有继承<code>NSObject</code>的类都支持KVC，<code>NSObject</code>实现了<code>NSKeyValueCoding</code>和必要的方法。通过KVC，可以做到以下功能：</p>
<ul>
<li>获取对象属性 比如使用 <code>valueForKey</code> 和 <code>setValue:forkey:</code>来获取和修改属性</li>
<li>操作Collection类型的的属性，比如<code>NSArray</code>、<code>NSSet</code></li>
<li>使用Collection运算符</li>
<li>非对象的values</li>
<li>路径搜索的步骤（本文不会讲这个，请自己看文档）</li>
</ul>
<p>下面，我们来挨个看下上面的5种用法</p>
<h1 id="获取对象属性"><a href="#获取对象属性" class="headerlink" title="获取对象属性"></a>获取对象属性</h1><p>属性可以分为3个类型：</p>
<ul>
<li>Attributes（简单属性），比如string，int，bool等简单类型</li>
<li>To-one relationships（单一关系），比如一个<code>Person</code>类的实例</li>
<li>To-many relationships（多个关系），比如<code>NSArray</code>或者<code>NSSet</code></li>
</ul>
<p>来看下例子,这个一家人的类： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@interface Person : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *name;</div><div class="line">@property (nonatomic, assign) NSInteger age;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@interface Family : NSObject</div><div class="line"></div><div class="line">@property (nonatomic) NSNumber* numbers;              // An attribute</div><div class="line">@property (nonatomic) Person* boss;                         // A to-one relation</div><div class="line">@property (nonatomic) NSArray&lt; Person* &gt;* members; // A to-many relation</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="通过key与keyPath读取属性"><a href="#通过key与keyPath读取属性" class="headerlink" title="通过key与keyPath读取属性"></a>通过key与keyPath读取属性</h3><p>在介绍如何读取之前，我简单说下key和keyPath。<br>key可以简答理解为对象某个属性的名称，而keyPath是又<code>.</code>区分的一串string，用来读取更深层的value。举个列子：对于Family来说，他的key有几个：<code>numbers</code>、<code>boss</code>、<code>members</code>。我们可以通过这几个key来读取他对应的属性。但是如果我们想要读取<code>boss</code>的name，一种办法是先读取<code>boss</code>，然后读取<code>boss</code>的name，另一个办法就是我们通过keyPath,直接读取<code>family</code>的<code>boss.name</code>，这个<code>boss.name</code>就是keyPath。</p>
<p>通过key和keyPath读取属性，有以下几个方法：</p>
<ul>
<li><code>valueForKey:</code> 读取key</li>
<li><code>valueForKeyPath:</code> 读取keyPath </li>
<li><code>dictionaryWithValuesForKeys:</code> 批量读取</li>
</ul>
<p>还是通过例子来看，我们先初始化几个实例出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Person *father = [Person new];</div><div class="line">father.name = @&quot;Jack&quot;;</div><div class="line">father.age = 50;</div><div class="line"></div><div class="line">Person *mother = [Person new];</div><div class="line">mother.name = @&quot;rose&quot;;</div><div class="line">mother.age = 45;</div><div class="line"></div><div class="line"></div><div class="line">Family *family = [Family new];</div><div class="line">family.numbers = @(2);</div><div class="line">family.boss = father;</div><div class="line">family.members = @[father, mother];</div></pre></td></tr></table></figure>
<p>我们分别用上面的三个方法来读取属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSString *fatherName = [father valueForKey:@&quot;name&quot;];</div><div class="line">NSLog(@&quot;father name: %@,&quot;,fatherName);</div><div class="line"></div><div class="line">NSString *bossName = [family valueForKeyPath:@&quot;boss.name&quot;];</div><div class="line">NSLog(@&quot;boss name: %@,&quot;,bossName);</div><div class="line"></div><div class="line">NSDictionary *names = [family dictionaryWithValuesForKeys:@[@&quot;numbers&quot;,@&quot;members&quot;]];</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，如果是NSArray、NSSet等类型，不能包含nil，而是转皇城NSNull。系统会在使用的时候自动转换。</p>
</blockquote>
<h3 id="通过key和keyPath修改属性"><a href="#通过key和keyPath修改属性" class="headerlink" title="通过key和keyPath修改属性"></a>通过key和keyPath修改属性</h3><p>有以下几种方法：</p>
<ul>
<li>setValue:forkey:</li>
<li>setValue:forKeyPath:</li>
<li>setValuesForKeysWithDictionary:</li>
</ul>
<p>还是直接上例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[father setValue:@&quot;Jack is gone&quot; forKey:@&quot;name&quot;];</div><div class="line"></div><div class="line">[family setValue:@&quot;boss&apos;s name&quot; forKeyPath:@&quot;boss.name&quot;];</div><div class="line"></div><div class="line">[family setValuesForKeysWithDictionary:@&#123;@&quot;numbers&quot;:@(3),@&quot;boss&quot;:father&#125;];</div></pre></td></tr></table></figure>
<h3 id="使用KVC简化你的代码"><a href="#使用KVC简化你的代码" class="headerlink" title="使用KVC简化你的代码"></a>使用KVC简化你的代码</h3><p>讲了半天KVC的使用，那么我们什么时候用？怎么用比较适合呢？看个例子:</p>
<p>如果你有类column，identifier可能是name、age、favoriteColor，你要根据identifier的不同去展示不同的属性。正常写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (id)tableView:(NSTableView *)tableview objectValueForTableColumn:(id)column row:(NSInteger)row</div><div class="line">&#123;</div><div class="line">id result = nil;</div><div class="line">Person *person = [self.people objectAtIndex:row];</div><div class="line"></div><div class="line">if ([[column identifier] isEqualToString:@&quot;name&quot;]) &#123;</div><div class="line">result = [person name];</div><div class="line">&#125; else if ([[column identifier] isEqualToString:@&quot;age&quot;]) &#123;</div><div class="line">result = @([person age]);  // Wrap age, a scalar, as an NSNumber</div><div class="line">&#125; else if ([[column identifier] isEqualToString:@&quot;favoriteColor&quot;]) &#123;</div><div class="line">result = [person favoriteColor];</div><div class="line">&#125; // And so on...</div><div class="line"></div><div class="line">return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简化写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (id)tableView:(NSTableView *)tableview objectValueForTableColumn:(id)column row:(NSInteger)row</div><div class="line">&#123;</div><div class="line">return [[self.people objectAtIndex:row] valueForKey:[column identifier]];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="获取Collection对象属性"><a href="#获取Collection对象属性" class="headerlink" title="获取Collection对象属性"></a>获取Collection对象属性</h1><p>在上面我们看到，其实使用<code>valueForKey:</code>和<code>valueForKeyPath</code>是可以获取<code>NSArray</code>等类型的，但是我们获取的是一个不可变的类型，如果我们希望去修改<code>key</code>或者<code>keyPath</code>对应的数组的时候，怎么做呢？</p>
<p>使用：</p>
<ul>
<li>mutableArrayValueForKey: 和 mutableArrayValueForKeyPath:</li>
<li>mutableSetValueForKey: and mutableSetValueForKeyPath:</li>
<li>mutableOrderedSetValueForKey: and mutableOrderedSetValueForKeyPath:</li>
</ul>
<p>来个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *members = [family mutableArrayValueForKey:@&quot;members&quot;];</div><div class="line"></div><div class="line">Person *son = [Person new];</div><div class="line">father.name = @&quot;Jack&apos;s son&quot;;</div><div class="line">father.age = 15;</div><div class="line"></div><div class="line">[members addObject: son];</div></pre></td></tr></table></figure>
<h1 id="使用Collection运算符"><a href="#使用Collection运算符" class="headerlink" title="使用Collection运算符"></a>使用Collection运算符</h1><h3 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h3><p>我们在实际的使用时，会有很多类似于数组平均数、最大值等计算的需求，除了自己写算法计算之外，如果有类似于数据库的快捷操作符，那该多好啊！</p>
<p>现在，我们就来看下KVC提供的数组等的快捷计算符。</p>
<p>正常使用<code>keyPath</code>的时候，我们通常会使用类似<code>person.son.name</code>等来读取属性。<code>KVC</code>同样提供了<code>@</code>操作符和一些基本的操作，我们可以放到<code>keyPath</code>中，就可以在return之前执行这个操作，然后再返回值了，听起来有点变扭，我们先看下结构：</p>
<p><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/art/keypath.jpg" alt=""></p>
<p>操作符是由 <code>@</code>符号和操作函数名组成的</p>
<p>在操作符前面的都叫 <code>left key path</code>，这里指定接收消息的对象，为空的话，就是执行<code>keyPath</code>的对象</p>
<p>在操作符后面的都叫 <code>right key path</code>, 这里执行操作的对象，除了数组的<code>@count</code>之外，不能为空</p>
<h3 id="聚合运算"><a href="#聚合运算" class="headerlink" title="聚合运算"></a>聚合运算</h3><p>这样讲，还是有点虚，我们看个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@interface SaveRecond : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *name;</div><div class="line">@property (nonatomic, assign) NSInteger money;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@interface Bank : NSObject</div><div class="line"></div><div class="line">@property (nonatomic) NSArray&lt; SaveRecond* &gt;* reconds;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>初始化下数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">SaveRecond *save1 = [SaveRecond new];</div><div class="line">save1.name = @&quot;Jack&quot;;</div><div class="line">save1.money = 10;</div><div class="line"></div><div class="line">SaveRecond *save2 = [SaveRecond new];</div><div class="line">save2.name = @&quot;rose&quot;;</div><div class="line">save2.money = 20;</div><div class="line"></div><div class="line">SaveRecond *save3 = [SaveRecond new];</div><div class="line">save3.name = @&quot;Jack&quot;;</div><div class="line">save3.money = 30;</div><div class="line"></div><div class="line"></div><div class="line">Bank *bank = [Bank new];</div><div class="line">bank.reconds = @[save1, save2,save3];</div></pre></td></tr></table></figure>
<p>如果我们想计算这些储户的平均值，可以直接遍历bank的reconds，然后计算，那么，如果用KVC的operation，该如何做呢？一句话解决：</p>
<p><code>NSObject *count = [bank valueForKeyPath:@&quot;reconds.@count&quot;];</code></p>
<p>这句话的意思就是 我希望向bank的reconds属性，发送@count消息，执行@count运算。</p>
<p>我们再来看个有<code>right key path</code>的。这里我希望计算出所有记录的平均储蓄值。</p>
<p><code>NSObject *avg = [bank valueForKeyPath:@&quot;reconds.@avg.money&quot;];</code><br>这句话的意思是，我希望向bank的reconds属性，发送@avg消息，执行money的avg运算。</p>
<p>同理，计算符还有很多，我这里就不一一介绍了，简单列下，只要学过数据库的，应该没啥问题（没学过？感觉学习下呀0_0）</p>
<ul>
<li>@avg</li>
<li>@count</li>
<li>@max</li>
<li>@min</li>
<li>@sum</li>
</ul>
<h3 id="数组运算"><a href="#数组运算" class="headerlink" title="数组运算"></a>数组运算</h3><p>刚才用的都是聚合之后的计算，我们看下如何对数组进行计算。比如：我想要知道一共有个用户(去重)。</p>
<p><code>NSArray *array = [bank valueForKeyPath:@&quot;reconds.@distinctUnionOfObjects.name&quot;];</code></p>
<p>这句话的含义是 我希望向bank的reconds属性发送distinctUnionOfObjects消息，执行基于name的distinctUnionOfObjects操作。</p>
<p>这里的运算符有两个：</p>
<ul>
<li>distinctUnionOfObjects 去重</li>
<li>unionOfObjects 不去重</li>
</ul>
<h3 id="嵌套运算操作"><a href="#嵌套运算操作" class="headerlink" title="嵌套运算操作"></a>嵌套运算操作</h3><p>如果是想操作一个数组的数组(@[array,array,array])，要怎么样做呢？比如我有两个reconds数组，我想看一共有多少个用户(去重)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSArray *arrayOfArray = @[bank.reconds,bank.reconds];</div><div class="line">NSArray *array = [arrayOfArray valueForKeyPath:@&quot;@distinctUnionOfArrays.name&quot;];</div></pre></td></tr></table></figure>
<p>这里的运算符有三个：</p>
<ul>
<li>@distinctUnionOfArrays</li>
<li>@unionOfArrays</li>
<li>distinctUnionOfSets</li>
</ul>
<h3 id="非对象的values"><a href="#非对象的values" class="headerlink" title="非对象的values"></a>非对象的values</h3><p>当我们获取的是一个非对象的value，比如int、Bool等值，Cocoa会自动转换成NSNumber等对象<br>包括：<br>bool、char、double、float、int、long等等，这个自己去查文档吧</p>
<p>如果value是一个结构体该如何呢？ 比如NSPoint、NSRange、NSRect、NSSize等还是会返回本类，但是其他的结构体，会被返回一个NSValue</p>
<h1 id="检查属性"><a href="#检查属性" class="headerlink" title="检查属性"></a>检查属性</h1><p>当我要使用<code>setValueForKey</code>等方法去修改值时，怎么知道是不是合法呢？<br>KVC也提供了方法</p>
<ul>
<li>validateValue:forKey:error</li>
<li>validateValue:forKeyPath:error</li>
</ul>
<p>这个方法返回一个bool值，有三种情况：</p>
<ol>
<li>value合法，return YES</li>
<li>value不合法，但是可以给value重新赋值了一个新的object，return YES</li>
<li>value不合法，且不可以赋值挽救，return NO</li>
</ol>
<p>最坑人的是，这个方法要自己实现，否则默认返回YES。Are you kidding？ 那我干嘛要用你的这个方法。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h1&gt;&lt;h3 id=&quot;关于&quot;&gt;&lt;a href=&quot;#关于&quot; class=&quot;headerlink&quot; title=&quot;关于&quot;&gt;&lt;/a&gt;关于&lt;/h3&gt;&lt;p&gt;正常访
    
    </summary>
    
      <category term="iOS基础" scheme="https://github.com/njafei/njafei.github.io/categories/iOS%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Apple文档" scheme="https://github.com/njafei/njafei.github.io/tags/Apple%E6%96%87%E6%A1%A3/"/>
    
      <category term="基础知识" scheme="https://github.com/njafei/njafei.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>《ES6入门》读书笔记之let命令</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/04/17/ES6-%E5%85%A5%E9%97%A8-let%E5%91%BD%E4%BB%A4/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/04/17/ES6-入门-let命令/</id>
    <published>2017-04-17T07:37:38.000Z</published>
    <updated>2017-04-18T01:48:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>正在读阮一峰的<a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">《ECMAScript 6 入门》</a>,本系列博客都是读书笔记。</p>
<h1 id="ES6-PlayGround"><a href="#ES6-PlayGround" class="headerlink" title="ES6 PlayGround"></a>ES6 PlayGround</h1><p>在介绍具体的内容之前，想给大家介绍一个好玩的playgroud，尤其合适边看书，边敲代码的同学们。<a href="https://google.github.io/traceur-compiler/demo/repl.html#%7B%0A%20%20let%20a%20%3D%201%3B%0A%20%20var%20b%20%3D%200%3B%0A%20%20console.log(a" target="_blank" rel="external">Traceur</a>%3B%0A%7D%0A%0Aconsole.log(b)%3B%0A%0A)<br>这个工具会在你敲完每行代码之后帮你执行检查是否有错误，然后翻译成es5并执行，然后再配合JS控制台，就是很棒的playground了。<br>使用：</p>
<ol>
<li>打开网页</li>
<li>command + option + J打开javascript控制台</li>
<li>在最左边的框里面输入代码，</li>
</ol>
<p>效果如下：<br>左边：写代码的地方  中间：翻译之后的js代码，右边：控制台<br><img src="http://on0hv7n2x.bkt.clouddn.com/es6%20playground.png" alt=""></p>
<h1 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h1><h2 id="作用域和var不同"><a href="#作用域和var不同" class="headerlink" title="作用域和var不同"></a>作用域和var不同</h2><p>ES6中建议全部使用let来生命变量，let和var的作用用法类似，但是let声明的变量，作用域是在其所在的代码块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	var a = 0;</div><div class="line">  	let b = 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(a);</div><div class="line">console.log(b);//ReferenceError： b is not defined</div></pre></td></tr></table></figure>
<p>看起来很简单吧，那我们来看下道题目吧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var a = [];</div><div class="line">for(var i = 0; i&lt; 10 ; i++)&#123;</div><div class="line">  a[i] = ()=&gt;&#123;</div><div class="line">  	console.log(i)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">a[7]();</div></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let b = [];</div><div class="line">for(let i = 0; i&lt; 10 ; i++)&#123;</div><div class="line">  b[i] = ()=&gt;&#123;</div><div class="line">  	console.log(i)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">b[7]();</div></pre></td></tr></table></figure>
<p>答案是：<br>a(7)() : 10<br>b(7)() : 7</p>
<p>你猜对了吗？0_0<br>我第一次看其实是答错了的，然后我把a[7] 和 b[7]打印了出来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function () &#123;</div><div class="line">      console.log(i);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我理解是因为let和var的缘故，所以a[7]里面的i实际是就是一个static的变量，在i++之后变成了10，而b[7]里面的i就是7</p>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>let 不会出现变量提升的现象。<br>首先，我们把let抛一边,看下什么是变量提升。先看个代码，猜猜它的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var a = 5;</div><div class="line">function f()&#123;</div><div class="line">  if(!a)&#123;</div><div class="line">	  a = 100;</div><div class="line">	&#125;</div><div class="line">  console.log(a);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f();</div></pre></td></tr></table></figure>
<p>它的输出结果是多少？</p>
<p>答案： 5，很简单吧，好，我们再看一个相似的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var a = 5;</div><div class="line">function f()&#123;</div><div class="line">  if(!a)&#123;</div><div class="line">	 var a = 100;</div><div class="line">	&#125;</div><div class="line">  console.log(a);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f();</div></pre></td></tr></table></figure>
<p>结果是多少呢？<br>答案是：100</p>
<p>为什么会这样呢？</p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>作为一个一直在使用OC的程序员，想要弄懂JS的作用域，开始会很别扭，因为两者的作用域是基于不同的标准或者模式。在介绍之前，我们先看下两个C和JS的小例子：</p>
<p>C：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main() &#123;</div><div class="line">	int a = 1;</div><div class="line">	printf(&quot;%d&quot;,a); //1</div><div class="line">	&#123;</div><div class="line">		int a = 2;</div><div class="line">		printf(&quot;%d&quot;,a); //2</div><div class="line">	&#125;</div><div class="line">	printf(&quot;%d&quot;,a);/1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JS:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line">console.log(a); // 1</div><div class="line">&#123;</div><div class="line">    var a = 2;</div><div class="line">    console.log(a); // 2</div><div class="line">&#125;</div><div class="line">console.log(a); // 2</div></pre></td></tr></table></figure>
<p>结果不一样了，为什么呢？ 刚才提到C和Js的作用域的模式不一样，C是基于块级的作用域（block-level scope），每个大括号括起来的都可以理解为一个小的作用域，如果变量在小的作用域里声明，那么在小的作用域中是会忽略外部同名的变量。</p>
<p>而在JS中，则是基于函数的作用域，即每个函数都有自己的作用域（function-level scope），所以上述的列子最后的结果就不一致了，在JS的列子中，a的值其实被覆盖。</p>
<p>C,C++,Java都是块级作用域，那么JS中，如何实现类似的效果呢？答案是使用闭包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var a = 0;</div><div class="line">fucntion f()&#123;</div><div class="line">	var a = 1;//1</div><div class="line">	console.log(a);//1</div><div class="line">&#125;</div><div class="line">console.log(a);//0</div></pre></td></tr></table></figure>
<p>在f()这个函数中，会再次定义一个只能在f()中起作用的a,从而实现了类似块级作用域的效果。</p>
<h4 id="变量提升-1"><a href="#变量提升-1" class="headerlink" title="变量提升"></a>变量提升</h4><p>讲完了作用域，我们来看下什么是变量提升，还是先来个列子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a = 0;</div><div class="line">f();</div><div class="line">var b = 1;</div></pre></td></tr></table></figure>
<p>这三行代码在解释器中会变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a , b;</div><div class="line">a = 0;</div><div class="line">f();</div><div class="line">b = 1;</div></pre></td></tr></table></figure>
<p>所有var声明的变量的声明语句，都会被解释器给放到变量所在作用域的顶部。注意，只是把生命语句放到最上面，但是不会把赋值等位置提升，这就是所谓的变量提升。</p>
<p>函数也会有变量提升的现象，但是会根据声明方式的不同，有着不同的结果。创建函数的方法有两个： function f(){} 和 var f = function(){},他们会有什么不同呢？ 我们看下列子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">f1();// TypeError &quot;foo is not a function&quot;</div><div class="line">f2();// will run</div><div class="line"></div><div class="line">var f1 = function()&#123;</div><div class="line">	console.log(&apos;won&apos;t run&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function f2()&#123;</div><div class="line">	console.log(&apos;will run&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码在解释器中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var f1();</div><div class="line">function f2()&#123;</div><div class="line">	console.log(&apos;will run&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f1();// TypeError &quot;foo is not a function&quot;</div><div class="line">f2();// will run</div><div class="line"></div><div class="line">var f1 = function()&#123;</div><div class="line">	console.log(&apos;won&apos;t run&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数的变量提升，如果是<code>fucntion f()</code>的形式，怎会整个函数都提升到顶部，如果是<code>var f() = function(){}</code>的形式，则只会提升<code>var f()</code>到顶部。</p>
<p>如此，本节开头的两个例子就不难理解了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var a = 5;</div><div class="line">function f()&#123;</div><div class="line">  if(!a)&#123;</div><div class="line">	  a = 100;</div><div class="line">	&#125;</div><div class="line">  console.log(a);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f();</div></pre></td></tr></table></figure>
<p>在解释器中是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var a;</div><div class="line">function f()&#123;</div><div class="line">  if(!a)&#123;</div><div class="line">	  a = 100;</div><div class="line">	&#125;</div><div class="line">  console.log(a);</div><div class="line">&#125;</div><div class="line">a = 5;</div><div class="line"></div><div class="line">f();</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var a = 5;</div><div class="line">function f()&#123;</div><div class="line">  if(!a)&#123;</div><div class="line">	 var a = 100;</div><div class="line">	&#125;</div><div class="line">  console.log(a);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f();</div></pre></td></tr></table></figure>
<p>在解释器中是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var a;</div><div class="line">function f()&#123;</div><div class="line">  var a;	 </div><div class="line">  if(!a)&#123;</div><div class="line">	 a = 100;</div><div class="line">	&#125;</div><div class="line">  console.log(a);</div><div class="line">&#125;</div><div class="line">a = 5;</div><div class="line">f();</div></pre></td></tr></table></figure>
<p>而let 关键字是不具备变量提升的，所以它声明的变量，其实就是块级作用域。</p>
<p>最后一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var a = 0;</div><div class="line">let b = 0;</div><div class="line">&#123;</div><div class="line">	var a = 1;</div><div class="line">	let b = 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(a);//1</div><div class="line">console.log(b);//0</div></pre></td></tr></table></figure>
<p>而在ES5中不会报错的先使用再声明的模式，在ES6中用let的话，就会报错了。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">if (true) &#123;</div><div class="line">// TDZ开始</div><div class="line">tmp = &apos;abc&apos;; // ReferenceError</div><div class="line">console.log(tmp); // ReferenceError</div><div class="line">let tmp; // TDZ结束</div><div class="line">console.log(tmp); // undefined</div><div class="line">tmp = 123;</div><div class="line">console.log(tmp); // 123</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以建议如下：</p>
<ul>
<li>ES6中永远使用let</li>
<li>所有变量的声明，都写在函数的顶部</li>
</ul>
<p>这是我在看变量提升的时候，找到一篇质量很棒的blog，本篇的结构和内容也参考了很多<a href="https://segmentfault.com/a/1190000003114255" target="_blank" rel="external">Javascript作用域和变量提升</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正在读阮一峰的&lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《ECMAScript 6 入门》&lt;/a&gt;,本系列博客都是读书笔记。&lt;/p&gt;
&lt;h1 id=&quot;ES6-PlayGround&quot;
    
    </summary>
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/categories/React-Native/"/>
    
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/tags/React-Native/"/>
    
      <category term="读书笔记" scheme="https://github.com/njafei/njafei.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>RN 最容易crash的代码用法及应对措施（持续更新）</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/04/17/RN-Crash-Reasons/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/04/17/RN-Crash-Reasons/</id>
    <published>2017-04-17T02:37:55.000Z</published>
    <updated>2017-04-17T02:52:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量保护"><a href="#变量保护" class="headerlink" title="变量保护"></a>变量保护</h2><p>出现最多的就是在使用redux来做数据层，使用this.props的属性没有去查询时候为undefined，这种情况，基本是必crash</p>
<p>比如下例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//show user name</div><div class="line">&lt;Text&gt;&#123;this.props.userInfo.name&#125;&lt;/Text&gt;</div></pre></td></tr></table></figure>
<p>如果userInfo为undefined的话，就会崩溃，错误如下：</p>
<blockquote>
<p>TypeError: Cannot read property ‘name’ of undefined</p>
</blockquote>
<p>在这里name为undefined的时候反而没有问题，因为name是一个简单的属性，直接赋值给Text是没有问题的。</p>
<p>那如何避免这种问题呢？在赋值前加下判断会比较好：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let name = this.props.userInfo &amp;&amp; this.props.userInfo.name ? this.props.userInfo.name : &apos;&apos;;</div><div class="line"></div><div class="line">//show user name</div><div class="line">&lt;Text&gt;&#123;this.props.userInfo.name&#125;&lt;/Text&gt;</div></pre></td></tr></table></figure>
<p>这样基本可以避免崩溃的问题了。</p>
<p>但是如果都这样判断，实际是比较复杂的，所以如果你的业务比较简单，我建议可以直接在render做一个大的保护，即没有数据的时候，不去render这些业务内容.<br>思路如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">render()&#123;</div><div class="line">	if(!this.props.userInfo)&#123;</div><div class="line">		return (</div><div class="line">			&lt;EmptyView /&gt;</div><div class="line">		)</div><div class="line">	&#125; else &#123;</div><div class="line">		return (</div><div class="line">			//注意，如果name的层级更深，还是建议做保护</div><div class="line">			&lt;Text&gt;&#123;this.props.userInfo.name&#125;&lt;/Text&gt;</div><div class="line">		)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>定时器其实在iOS中也是一个非常容易出问题的地方，crash率会比较高。究其原因，我想是主要是因为定时器存在一个事件发生的延后性（废话嘛0_o）,但是很多时候会忘记，当定时任务真的发生的时候，语境变化了吗？如果语境都已经被dealloc了，定时任务仍然被激活，系统就会愤怒地罢工了。</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">componentDidMount() &#123;</div><div class="line">    setTimeout(</div><div class="line">      () =&gt; &#123; console.log(&apos;这就可能会崩溃&apos;); &#125;,</div><div class="line">      500</div><div class="line">    );</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>如果500ms之内，这个component就会Unmount了，那直接回崩溃。RN官方的建议如下：</p>
<h4 id="TimerMixin"><a href="#TimerMixin" class="headerlink" title="TimerMixin"></a>TimerMixin</h4><p>为了解决这个问题，我们引入了TimerMixin。如果你在组件中引入TimerMixin，就可以把你原本的setTimeout(fn, 500)改为this.setTimeout(fn, 500)(只需要在前面加上this.)，然后当你的组件卸载时，所有的计时器事件也会被正确的清除。</p>
<p>这个库并没有跟着React Native一起发布。你需要在项目文件夹下输入npm i react-timer-mixin –save来单独安装它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var TimerMixin = require(&apos;react-timer-mixin&apos;);</div><div class="line"></div><div class="line">var Component = React.createClass(&#123;</div><div class="line">  mixins: [TimerMixin],</div><div class="line">  componentDidMount: function() &#123;</div><div class="line">    this.setTimeout(</div><div class="line">      () =&gt; &#123; console.log(&apos;这样我就不会导致内存泄露!&apos;); &#125;,</div><div class="line">      500</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="代码保护（推荐）"><a href="#代码保护（推荐）" class="headerlink" title="代码保护（推荐）"></a>代码保护（推荐）</h4><p>Mixin属于ES5语法，对于ES6代码来说，无法直接使用Mixin。如果你的项目是用ES6代码编写，同时又使用了计时器，那么你只需铭记在unmount组件时清除（clearTimeout/clearInterval）所有用到的定时器，那么也可以实现和TimerMixin同样的效果。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import React,&#123;</div><div class="line">  Component</div><div class="line">&#125; from &apos;react&apos;;</div><div class="line"></div><div class="line">export default class Hello extends Component &#123;</div><div class="line">  componentDidMount() &#123;</div><div class="line">    this.timer = setTimeout(</div><div class="line">      () =&gt; &#123; console.log(&apos;把一个定时器的引用挂在this上&apos;); &#125;,</div><div class="line">      500</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">  componentWillUnmount() &#123;</div><div class="line">    // 如果存在this.timer，则使用clearTimeout清空。</div><div class="line">    // 如果你使用多个timer，那么用多个变量，或者用个数组来保存引用，然后逐个clear</div><div class="line">    this.timer &amp;&amp; clearTimeout(this.timer);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我今天看了我们项目的代码，发现几乎没有人做保护，代码copy的现象，真的是令人发指，可能很多人都没仔细看过官方的文档。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;变量保护&quot;&gt;&lt;a href=&quot;#变量保护&quot; class=&quot;headerlink&quot; title=&quot;变量保护&quot;&gt;&lt;/a&gt;变量保护&lt;/h2&gt;&lt;p&gt;出现最多的就是在使用redux来做数据层，使用this.props的属性没有去查询时候为undefined，这种情况，基本是
    
    </summary>
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/categories/React-Native/"/>
    
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>如何给同一个电脑上的不同git项目设置不同的name和email</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/04/11/settingNameAndEmailForEachProject/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/04/11/settingNameAndEmailForEachProject/</id>
    <published>2017-04-11T06:38:15.000Z</published>
    <updated>2017-04-24T06:31:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在自己的电脑上同时使用github和公司的git仓库，带来了一个问题就是之前只是设置了全局的name和email，但是两边的代码需要使用不同的user，每次都要手动去改，然后我搜索了下，发现其实我们可以给每个git项目，单独配置一个name和email的。规则如下：</p>
<blockquote>
<p>如果项目由独立配置，则使用独立配置，如果没有独立配置，则使用全局配置</p>
</blockquote>
<p>命令就很简单了：<br>全局name和email配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name gitaccount</div><div class="line">$ git config --global user.email gitaccount@example.com</div></pre></td></tr></table></figure>
<p>给单独的git项目设定配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cd gitFolder</div><div class="line">$ git config user.name gitaccount</div><div class="line">$ git config user.email gitaccount@example.com</div></pre></td></tr></table></figure>
<p>这样，如果本地有多个git user 或者多个项目的话，使用起来就比较方便了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在自己的电脑上同时使用github和公司的git仓库，带来了一个问题就是之前只是设置了全局的name和email，但是两边的代码需要使用不同的user，每次都要手动去改，然后我搜索了下，发现其实我们可以给每个git项目，单独配置一个name和email的。规则如下：&lt;/
    
    </summary>
    
      <category term="小知识" scheme="https://github.com/njafei/njafei.github.io/categories/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="git" scheme="https://github.com/njafei/njafei.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>React_Native拆分bundle之patch拆包</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/04/06/React-Native-Seperate-Bundle/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/04/06/React-Native-Seperate-Bundle/</id>
    <published>2017-04-06T02:26:41.000Z</published>
    <updated>2017-04-06T08:23:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要拆包"><a href="#为什么要拆包" class="headerlink" title="为什么要拆包"></a>为什么要拆包</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>随着RN的包越来越大，第一次载入RN包的时长越来越长，用户需要等待的时间也就越长，体验较差。另外多个团队开发的话，互相之间的依赖也是个大问题，出现编译不过的话，就会出现水桶效应，所有的团队都要等待这个有问题的团队，从而拉低了整体的效率。</p>
<p>另外我一直希望，能够将React-Native的业务功能，做成类似小程序一样：即用即载入，随时可以更新。想想我们的app里面包含了多少个用户也许永远用不到的功能，还有当我们希望上一个新功能的时候，一定要等待新的版本的审核，这给运营等带来了巨大的麻烦和风险。如果用户点击某个功能，然后马上载入线上的webBundle，用户之后就可以直接使用我们的最新功能了，以后再次进入的时候，也无需等待，那该多好。</p>
<h2 id="拆包目标"><a href="#拆包目标" class="headerlink" title="拆包目标"></a>拆包目标</h2><p>所以我们拆包的目标就很明确了：</p>
<pre><code>1. 优化载入时间，提高用户体验
2. 解开依赖关系，提高开发效率
3. 实现webBundle，即用即载入
</code></pre><p>示意图如下：<br><img src="http://on0hv7n2x.bkt.clouddn.com/React-Native%E6%8B%86%E5%8C%85%E6%96%B9%E6%A1%88%E7%BB%93%E6%9E%84%E5%9B%BE.jpeg" alt=""></p>
<h2 id="国外国内app拆包情况"><a href="#国外国内app拆包情况" class="headerlink" title="国外国内app拆包情况"></a>国外国内app拆包情况</h2><p>上面啰嗦了为什么想要去拆包，好像是蛮有必要的O_o。但是当我去看国内外著名的app使用React-Native的情况时，发现真的是泾渭分明：国内基本都拆包了，包括携程、QQ音乐等，而国外没有拆包的，比如React-Native的创造者FaceBook，虽然他们的包大小已经到了10M。</p>
<p>不禁让我很疑惑，难道国外没有这个需求么？为什么拆包和热更新等几乎国内的硬需求，他们却好像完全没有这方面的需求。希望有读者知道的话可以告知我~</p>
<h1 id="拆包的几种方案"><a href="#拆包的几种方案" class="headerlink" title="拆包的几种方案"></a>拆包的几种方案</h1><p>在讲具体的方案之前，我们先看下，React-Native的包，究竟是如何打出来，然后是怎么载入到native中的。</p>
<h2 id="如何打包"><a href="#如何打包" class="headerlink" title="如何打包"></a>如何打包</h2><p>这里我直接使用QQ技术团队的一张图：<br><img src="http://on0hv7n2x.bkt.clouddn.com/React-NativeJsBundle%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B" alt=""></p>
<h2 id="如何载入"><a href="#如何载入" class="headerlink" title="如何载入"></a>如何载入</h2><p>这里主要讲下iOS React-Native0.39版本的情况。<br>RN提供了两种形式来载入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1. - (NSURL *)sourceURLForBridge:(RCTBridge *)bridge</div><div class="line">2. - (void)loadSourceForBridge:(RCTBridge *)bridge</div><div class="line">                 onProgress:(RCTSourceLoadProgressBlock)onProgress</div><div class="line">                 onComplete:(RCTSourceLoadBlock)loadCallback;</div></pre></td></tr></table></figure>
<p>第一种数据是默认模式，第二种是可以控制载入中的各个步骤。这块可以看下RCTBridgeDelegate。</p>
<h2 id="主流方案"><a href="#主流方案" class="headerlink" title="主流方案"></a>主流方案</h2><p>在网上查了相关的资料，主流的方案基本都是把Main.jsbundl拆分成基础包common.jsbundle+业务包bundle，和上面拆包目标基本一样，不赘述。</p>
<p>具体的拆分思路就很不一样了：</p>
<pre><code>1. 侵入RN代码，修改打包流程，使得打出来的包就是基础+业务包，如QQ音乐
2. 在RN打包的基础上，实现新的打包方案，如携程 moles-Packer
3. Patch方案，打包流程不变，生成基础包后，根据diff来生成每个业务不同的patch包
</code></pre><h1 id="patch方案"><a href="#patch方案" class="headerlink" title="patch方案"></a>patch方案</h1><p>因为方案1和方案要随着RN的升级，不断调整，成本比较高，而且要投入较多的人力，所以我们先看下方案3。</p>
<p>先说下patch，patch就是根据特定算法，讲两个不同的事物diff比较，然后生成的包含两个事物差别的包。我们这里使用的是google的<code>diffAndPatch</code>算法。</p>
<p><img src="http://on0hv7n2x.bkt.clouddn.com/React-Native%E7%94%9F%E6%88%90%E5%8C%85.png" alt=""></p>
<h2 id="基础包common-jsbundle"><a href="#基础包common-jsbundle" class="headerlink" title="基础包common.jsbundle"></a>基础包common.jsbundle</h2><p>首先我们先生成基础包common.jsbundle.这里我们写一个空的js文件，只包含react-native头文件common.ios.js：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import React from &apos;react&apos;; </div><div class="line">import &#123;&#125; from &apos;react-native&apos;;</div></pre></td></tr></table></figure>
<p>然后我们基于这单个文件打包，打出来的包就是只包含react-native基础框架的bundle，我们成为common.jsbundle.</p>
<p>注：</p>
<p>RN打包过程中会做混淆，所有的类最终都变成了代号为数字的function，所以这里顺序就非常重要，而对基础包的引用顺序就要严格和common.ios.js一样了，这里建议所有的业务代码直接引用common.ios.js文件。另外如果有公共组件等，也都可以放到common.ios.js文件中，这样就会被包含在基础包中了。</p>
<h2 id="业务包-business-patch"><a href="#业务包-business-patch" class="headerlink" title="业务包 business.patch"></a>业务包 business.patch</h2><p>每条业务线的代码，都需要单独维护自己的indexBisiness.js,打包的时候，入口文件就是这个index，这样就打出来了一个业务business.bundle。<br>然后使用diff，计算出业务patch。这样就算出了patch，我们叫做business.patch</p>
<h2 id="native方案"><a href="#native方案" class="headerlink" title="native方案"></a>native方案</h2><p>现在我们已经有了common.jsbundle + bisiness1.patch + business2.patch + …<br>如果打开了bisiness1中的home.js，我们首先要将common.jsbundle和bisiness1.patch使用算法合并，计算出最终bisiness1.jsbundle.然后通过上面讲到的native载入方案载入具体的bundle。</p>
<p>根据当前的bridgeName生成bisiness bundle</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">- (NSString *)getNewBundle</div><div class="line">&#123;</div><div class="line">  </div><div class="line">  NSString *commonBundlePath = [[NSBundle mainBundle] pathForResource:@&quot;common&quot; ofType:@&quot;jsbundle&quot;];</div><div class="line">  NSString *commonBundleJSCode = [[NSString alloc] initWithContentsOfFile:commonBundlePath encoding:NSUTF8StringEncoding error:nil];</div><div class="line">  </div><div class="line">  NSString *patch1Path = [[NSBundle mainBundle] pathForResource:self.bridgeName ofType:@&quot;patch&quot;];</div><div class="line">  NSString *patch1JSCode = [[NSString alloc] initWithContentsOfFile:patch1Path encoding:NSUTF8StringEncoding error:nil];</div><div class="line">  </div><div class="line">  </div><div class="line">  DiffMatchPatch *diffMatchPatch = [[DiffMatchPatch alloc] init];</div><div class="line">  NSArray *convertedPatches = [diffMatchPatch patch_fromText:patch1JSCode error:nil];</div><div class="line">  </div><div class="line">  NSArray *resultsArray = [diffMatchPatch patch_apply:convertedPatches toString:commonBundleJSCode];</div><div class="line">  NSString *resultJSCode = resultsArray[0]; //patch合并后的js</div><div class="line">  </div><div class="line">  </div><div class="line">  NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</div><div class="line">  NSString *docDir = [paths objectAtIndex:0];</div><div class="line">  NSString *newPath = [NSString stringWithFormat:@&quot;%@/%@.jsbundle&quot;,docDir,self.bridgeName];</div><div class="line">  </div><div class="line">  if (resultsArray.count &gt; 1) &#123;</div><div class="line">    [resultJSCode writeToFile:newPath atomically:NO encoding:NSUTF8StringEncoding error:nil];</div><div class="line">    return newPath;</div><div class="line">  &#125;</div><div class="line">  else &#123;</div><div class="line">    return @&quot;&quot;;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>加载bisiness bundle：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge</div><div class="line">&#123;</div><div class="line">    NSString *path = [[NSBundle mainBundle] pathForResource:self.bridgeName ofType:@&quot;jsbundle&quot;];</div><div class="line">    NSURL *jsBundleURL = [NSURL URLWithString:path];</div><div class="line">  </div><div class="line">  return jsBundleURL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，code就基本完成了。如果想看所有的代码，请看底部的githubDemo</p>
<h2 id="方案优缺点"><a href="#方案优缺点" class="headerlink" title="方案优缺点"></a>方案优缺点</h2><p>优点：</p>
<pre><code>1. 技术方案简单，实现快
2. 稳定、不用担心RN升级问题
3. 业务互相独立
4. 方便后面做web bundle
</code></pre><p>缺点：</p>
<pre><code>1. 内存占用大
2. 打包会变大
3. 业务之间资源和代码没法互相引用
</code></pre><h2 id="优化和拓展计划"><a href="#优化和拓展计划" class="headerlink" title="优化和拓展计划"></a>优化和拓展计划</h2><pre><code>1. 打包可以不用patch的方案，采用脚本逐行写入
2.web bundle 可以直接基于这个方案做
3.如果解决了函数命名和依赖的问题，就可以采用一个bundle策略
</code></pre><h2 id="Demo-in-github"><a href="#Demo-in-github" class="headerlink" title="Demo in github"></a>Demo in github</h2><p><a href="https://github.com/njafei/ReactNativeSeperateBundle">ReactNativeSeperateBundle</a></p>
<ol>
<li>cd ReactNativeSeperateBundle</li>
<li>npm install</li>
<li>run project</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;为什么要拆包&quot;&gt;&lt;a href=&quot;#为什么要拆包&quot; class=&quot;headerlink&quot; title=&quot;为什么要拆包&quot;&gt;&lt;/a&gt;为什么要拆包&lt;/h1&gt;&lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背
    
    </summary>
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/categories/React-Native/"/>
    
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>iOS 响应链 Responder Chain</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/03/29/Responder-chain/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/03/29/Responder-chain/</id>
    <published>2017-03-29T07:12:33.000Z</published>
    <updated>2017-03-29T09:21:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h1><p>iOS设备和用户的交互其实有很多种方式，包括触摸屏幕，摇晃设备，多媒体控制（音量等）等。当设备检测到这三种事件中的一种的时候，iOS就会捕获当前事件的时间和内容，然后发出消息，通知App发生了事件，这个就是<code>Event</code>。<br><img src="http://on0hv7n2x.bkt.clouddn.com/UIEvent_Type.png" alt="UIEvent category"></p>
<h1 id="Responder"><a href="#Responder" class="headerlink" title="Responder"></a>Responder</h1><p>有了<code>Event</code>之后，系统需要找到能够处理这个<code>event</code>的对象，而能够处理event的对象，就是<code>UIResponder</code>.我们常用的<code>UIApplication</code>、<code>UIView</code>、<code>UIViewController</code>，其实都是<code>UIResponder</code>的实例。<code>UIResponder</code>为了要处理特定的事件，要实现<code>corresponding</code>方法。比如touch事件，那么<code>Responder</code>就要实现<code>touchesBegan：withEvent</code>,<code>touchedMoved:withEvent:</code>等方法。</p>
<p><img src="http://on0hv7n2x.bkt.clouddn.com/UIResponder.png" alt="UIResponder"></p>
<h1 id="Responder-Chain"><a href="#Responder-Chain" class="headerlink" title="Responder Chain"></a>Responder Chain</h1><p>如果有当前的界面有多个Responder的时候，到底是谁来响应呢？这里其实是根据特定的一个顺序，依次寻找响应的对象，这个就叫响应链（<code>Responder Chain</code>）机制了。在<code>Responder Chain</code>中，系统首先<code>UIkit</code>会按照一定的规则（下节会讲到）来找到当前的<code>first responder</code>，通常是事件发生的<code>view</code>，我们叫做<code>initial view</code>,然后根据这个view是否有处理的能力（比如touch事件就是看是否实现了上述的<code>touchesBegan：withEvent</code>等方法），如果当前的<code>responder</code>无法处理该事件，那么会响应链的顺序来查找下个响应者，通常的顺序是： view -&gt; super view -&gt; viewController -&gt; window -&gt; UIApplicaiton，如下图：<br><img src="http://on0hv7n2x.bkt.clouddn.com/ResponderChain.png" alt="ResponderChain"></p>
<p>如果到了响应链的最后一个节点，还是没有找到响应者，那么系统就会抛弃这条event。</p>
<h1 id="Hit-Test-View，Hit-Testing"><a href="#Hit-Test-View，Hit-Testing" class="headerlink" title="Hit-Test View，Hit-Testing"></a>Hit-Test View，Hit-Testing</h1><p>那么系统是如何找到<code>first responder</code>的呢？答：使用<code>Hit-Testing</code>。<br>当触摸事件发生时，iOS会使用<code>Hit-Testing</code>超找当前事件所在的<code>view</code>，它会从<code>UIApplication</code>开始，依次往下寻找事件发生的<code>view</code>，直到找到这个<code>view</code>，顺序和上述的响应链，其实是相反的，我怀疑可能响应链就是在<code>Hit-Testing</code>的过程中建立的，但是没有查到相关的资料。</p>
<p>我们看个苹果的官方列子：<br><img src="http://on0hv7n2x.bkt.clouddn.com/Hit-Testing.png" alt=""></p>
<p>如果触摸事件发生在D中，那么系统会依次检查：</p>
<ol>
<li>触摸区域在A中，遍历它的所有subViews</li>
<li>触摸区域在C中，遍历它的所有subViews</li>
<li>触摸事件在D中</li>
</ol>
<p>D就是所谓的<code>Hit-Test View</code>，也是上述的响应链中的<code>first responder</code></p>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><ul>
<li><a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html" target="_blank" rel="external">EventHandlingiPhoneOS 官方文档忽然实效了</a></li>
<li><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/Responder.html#//apple_ref/doc/uid/TP40009071-CH1-SW2" target="_blank" rel="external">Responder object</a></li>
<li><a href="https://www.zybuluo.com/MicroCai/note/66142" target="_blank" rel="external">iOS Events and Responder Chain</a></li>
<li><a href="http://www.jianshu.com/p/05cbcd774f45" target="_blank" rel="external">iOS中的响应链（The Responder Chain）</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Event&quot;&gt;&lt;a href=&quot;#Event&quot; class=&quot;headerlink&quot; title=&quot;Event&quot;&gt;&lt;/a&gt;Event&lt;/h1&gt;&lt;p&gt;iOS设备和用户的交互其实有很多种方式，包括触摸屏幕，摇晃设备，多媒体控制（音量等）等。当设备检测到这三种事件中的一
    
    </summary>
    
      <category term="iOS基础" scheme="https://github.com/njafei/njafei.github.io/categories/iOS%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础知识" scheme="https://github.com/njafei/njafei.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Apple文档翻译之Event-Handing-Guide-for-iOS</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/03/27/Event-Handing-Guide-for-iOS/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/03/27/Event-Handing-Guide-for-iOS/</id>
    <published>2017-03-27T07:38:29.000Z</published>
    <updated>2017-03-28T08:33:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="About-Events-in-iOS"><a href="#About-Events-in-iOS" class="headerlink" title="About Events in iOS"></a>About Events in iOS</h1><p>用户会使用很多的方式来操作他们的iOS设备，比如点击屏幕或者摇晃屏幕。当用户正在操作硬件或者向App传递信息时，iOS会获取时间和方式。你的App给用户的反馈越自然、越直接，用户就会越有兴趣。</p>
<p><img src="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/events_to_app_2x.png" alt=""></p>
<h4 id="AT-a-Glance"><a href="#AT-a-Glance" class="headerlink" title="AT a Glance"></a>AT a Glance</h4><p>Event是当用户有动作时，（<code>UIKit</code>）向App发出的通知。在iOS中，有很多形式的event：多点触摸，滑动、多媒体控制。最后一个事件被熟知为远程控制事件，因为它可以从一个附件中发出。</p>
<h4 id="UIKit让你的App处理手势更轻松"><a href="#UIKit让你的App处理手势更轻松" class="headerlink" title="UIKit让你的App处理手势更轻松"></a>UIKit让你的App处理手势更轻松</h4><p>iOS应用可以识别组合的触摸，然后直接以特定方式反馈，比如收缩的触摸会缩小内容，间隔触摸划过内容等。实际上，很多的手势太常见了，所以他们被内置在<code>UIKit</code>中。比如<a href="https://developer.apple.com/reference/uikit/uicontrol" target="_blank" rel="external">UIControl</a>子类，比如<a href="https://developer.apple.com/reference/uikit/uibutton" target="_blank" rel="external">UIButton</a>和<a href="https://developer.apple.com/reference/uikit/uislider" target="_blank" rel="external">UISlider</a>，回应特殊的手势-button的点击和slider的拖动。当你配置这些control，他们会在触摸发生时，发出一个message给目标。你也可以通过使用gesture recognizers在view上实现这个目标动作。当你给一个view添加一个getsture recognizer，这个view会像一个control一样给你指定的触摸回应。</p>
<p>Gesture recognizer提供了一个高度抽象的复杂事件处理逻辑。当使用触摸事件时，请优选gesture recognizer，因为它们很强大，可复用，适用性强。你也可以使用内置的getsure recognizer然后个性化它的行为。或者你可以创造一个新的gesture recognizer来识别一个新的触摸事件。</p>
<blockquote>
<p>相关章节：<a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/GestureRecognizer_basics/GestureRecognizer_basics.html#//apple_ref/doc/uid/TP40009541-CH2-SW2" target="_blank" rel="external">Gesture Recognizers</a></p>
</blockquote>
<h5 id="一个事件为了找到处理它的对象，要遍历一个特定的路径"><a href="#一个事件为了找到处理它的对象，要遍历一个特定的路径" class="headerlink" title="一个事件为了找到处理它的对象，要遍历一个特定的路径"></a>一个事件为了找到处理它的对象，要遍历一个特定的路径</h5><p>当iOS recognizer是事件时，它首先会将事件传递给初始的看起来最相关的对象，比如touch发生的view。如果初始的对象不能处理事件，<code>iOS</code>会继续传递事件给更大范围的对象，直接它找到了一个对象有足够的上下文处理这个事件。这些对象的序列，就是被熟知的响应链（responder chain），iOS会顺着响应链传递事件，同时它也传递回应事件的责任。这种设计模式让事件处理更加动态和合作性高。</p>
<blockquote>
<p>相关章节 <a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW2" target="_blank" rel="external">响应链 Responder Chain</a></p>
</blockquote>
<h4 id="UIEvent封装了触摸，摇晃，远程控制事件"><a href="#UIEvent封装了触摸，摇晃，远程控制事件" class="headerlink" title="UIEvent封装了触摸，摇晃，远程控制事件"></a>UIEvent封装了触摸，摇晃，远程控制事件</h4><p>许多<code>UIEvent</code>是UIKit <a href="https://developer.apple.com/reference/uikit/uievent" target="_blank" rel="external">UIEvent</a>的实例。一个<code>UIEvent</code>包括了关于事件app需要使用的信息，以决定如何回应这个事件。比如当一个用户事件发生时，手指触摸屏幕或者滑动它的表面，iOS持续的发送event对象给app。每个event对象都有一个type-触摸、摇晃、远程控制来作为它的子类型。</p>
<blockquote>
<p>相关章节： <a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/multitouch_background/multitouch_background.html#//apple_ref/doc/uid/TP40009541-CH5-SW9" target="_blank" rel="external">多点触摸</a>、<a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/motion_event_basics/motion_event_basics.html#//apple_ref/doc/uid/TP40009541-CH6-SW14" target="_blank" rel="external">手势</a>、<a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Remote-ControlEvents/Remote-ControlEvents.html#//apple_ref/doc/uid/TP40009541-CH7-SW3" target="_blank" rel="external">远程控制</a></p>
</blockquote>
<h4 id="当用户触摸界面时，App接收多点触摸事件"><a href="#当用户触摸界面时，App接收多点触摸事件" class="headerlink" title="当用户触摸界面时，App接收多点触摸事件"></a>当用户触摸界面时，App接收多点触摸事件</h4><p>在你的App上，UIKit controls和gesture recognizers 也行足够你来应对触摸事件了。甚至你可以使用Gesture recognizer来定制你的view。根据经验，你会使用触摸事件当你的app回应和view本身绑定的事件，比如摸出画东西。在这些列子中，你只负责低优先级的触摸事件，事件touch method，在method中，你分析未经加工的触摸事件，然后适当回应。</p>
<blockquote>
<p>相关章节 <a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/multitouch_background/multitouch_background.html#//apple_ref/doc/uid/TP40009541-CH5-SW9" target="_blank" rel="external">多点触摸 multitouch Event</a></p>
</blockquote>
<h4 id="当用户移动设备时，App接收到移动事件（Motion-Event）"><a href="#当用户移动设备时，App接收到移动事件（Motion-Event）" class="headerlink" title="当用户移动设备时，App接收到移动事件（Motion Event）"></a>当用户移动设备时，App接收到移动事件（Motion Event）</h4><p>Motion事件提供了关于设备的地点、方向和移动的信息。通过回应Motion事件，你可以提供微量却强大的功能。加速器和陀螺仪数据能让你判断是倾斜、旋转，还是摇晃。</p>
<p>Motion事件有许多形式，你可以通过不同的framework来处理他们。当用户摇晃设备时，<code>UIKit</code>传递<code>UIEvent</code>对象给app。如果你想要app能接收高速、持续的加速器和陀螺仪数据，请使用<code>Core Motion framework</code>。</p>
<blockquote>
<p>相关章节 <a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/motion_event_basics/motion_event_basics.html#//apple_ref/doc/uid/TP40009541-CH6-SW14" target="_blank" rel="external">Motion Event</a></p>
</blockquote>
<h4 id="当用户操作多媒体控制，用户收到远程控制事件"><a href="#当用户操作多媒体控制，用户收到远程控制事件" class="headerlink" title="当用户操作多媒体控制，用户收到远程控制事件"></a>当用户操作多媒体控制，用户收到远程控制事件</h4><p>iOS controls 和外部附件可以给app发送远程控制事件。这些事件允许用户去控制音频和视频，比如通过耳机调整音量。</p>
<blockquote>
<p>相关章节： <a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Remote-ControlEvents/Remote-ControlEvents.html#//apple_ref/doc/uid/TP40009541-CH7-SW3" target="_blank" rel="external">Remote Control Event</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;About-Events-in-iOS&quot;&gt;&lt;a href=&quot;#About-Events-in-iOS&quot; class=&quot;headerlink&quot; title=&quot;About Events in iOS&quot;&gt;&lt;/a&gt;About Events in iOS&lt;/h1&gt;&lt;p&gt;用户
    
    </summary>
    
      <category term="文档翻译" scheme="https://github.com/njafei/njafei.github.io/categories/%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Apple文档" scheme="https://github.com/njafei/njafei.github.io/tags/Apple%E6%96%87%E6%A1%A3/"/>
    
      <category term="基础知识" scheme="https://github.com/njafei/njafei.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Apple文档翻译之UIResponder</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/03/21/UIResponder/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/03/21/UIResponder/</id>
    <published>2017-03-21T07:20:54.000Z</published>
    <updated>2017-03-28T08:34:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>UIResponder</code>是回应和处理事件的抽象接口,<code>UIResponder</code>的实例，包括：<code>UIApplication</code>、<code>UIViewController</code>、<code>UIView</code>（包含<code>UIWindow</code>），组成了<code>UIKit</code>处理事件的核心。当事件发生时，<code>UIKit</code>会把事件派发给<code>UIResponder</code>去处理。</p>
<p>有许多种事件，包括触摸、手势、遥控和点击事件。为了处理特定的事件，一个<code>responder</code>（响应）必须重写<code>corresponding</code>方法。比如，要想处理<code>touch</code>事件，一个<code>responder</code>要实现<code>touchesBegan：withEvent</code>,<code>touchedMoved:withEvent:</code>等方法。在触摸事件的列子中，<code>responder</code>使用UIKit提供的事件信息来追踪触摸的改变，然后适时地更新界面。</p>
<p>除了处理事件，<code>UIKit responder</code>还负责转发那边没有被处理的事件给app的其他部分。如果一个指定的<code>responder</code>没有处理事件，它就会转发这个事件到响应链的下一个<code>responder</code>。UIKit动态地管理响应链，使用预定的规则来决定下一个收到事件的对象。比如：一个<code>view</code>转发事件到它的<code>superView</code>，或者<code>Rootview</code>转发事件给它的v<code>iew controller</code>。</p>
<p><code>Responder</code>处理<code>UIEvent</code>和其他通过输入界面的自定义输入，最典型的就是系统的键盘。当用户点击<code>UITextField</code>和<code>UITextView</code>，这个view变成了第一个<code>responder</code>，然后展示它的输入界面：键盘。同样的，你可以创造一个自定义的输入界面，然后在其他<code>responders</code>活跃的时候展示它。为了把输入界面和<code>responder</code>联系在一起，要把<code>view</code>赋值给<code>responder</code>的属性。</p>
<p>原文链接  <a href="https://developer.apple.com/reference/uikit/uiresponder#//apple_ref/occ/cl/UIResponder" target="_blank" rel="external">UIResponder</a></p>
<p>如果有任何建议和优化的地方，欢迎给我留言。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;UIResponder&lt;/code&gt;是回应和处理事件的抽象接口,&lt;code&gt;UIResponder&lt;/code&gt;的实例，包括：&lt;code&gt;UIApplication&lt;/code&gt;、&lt;code&gt;UIViewController&lt;/code&gt;、&lt;code&gt;UIVie
    
    </summary>
    
      <category term="文档翻译" scheme="https://github.com/njafei/njafei.github.io/categories/%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Apple文档" scheme="https://github.com/njafei/njafei.github.io/tags/Apple%E6%96%87%E6%A1%A3/"/>
    
      <category term="基础知识" scheme="https://github.com/njafei/njafei.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>github pages + hexo 原理探究</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/03/18/githubPagesStudy/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/03/18/githubPagesStudy/</id>
    <published>2017-03-18T13:07:15.000Z</published>
    <updated>2017-03-28T08:29:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>利用一个下午搭建起了github pages + hexo 的静态博客，试用了下效果，还是挺满意的，至少比csdn的页面好看多了，哈哈。<br>搭建的过程中，也遇到了很多的问题，尤其是中间如何把hexo 和github连在一起，又是如何更新博客这块，有很多疑问，我自己尝试，还不小心把本地的hexo的文件删除了，不得不重新init了一个，配置都要重新来一遍，所以这篇文章着重探讨，github pages的流程到底是如何展开的。</p>
<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>先说下<a href="https://pages.github.com/" target="_blank" rel="external">github pages</a>,github pages 是github提供给用户用来展示个人或者项目主页的静态网页系统。每个用户都可以使用自己的github项目创建，上传静态页面的html文件，github会帮你自动更新你的页面。</p>
<p><a href="https://hexo.io/zh-cn/" target="_blank" rel="external">hexo</a>是一个用来生成静态界面的框架，使用hexo，你就可以直接使用mark down 来写文章，而不用关心前端样式的展现。</p>
<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>我们来看下流程图：<br><img src="http://on0hv7n2x.bkt.clouddn.com/github%20pages%20%E6%95%B0%E6%8D%AE%E6%B5%81.png" alt="数据流程图"></p>
<p>这样看就很简单了，我们本地使用markDown语法写好文件，然后执行hexo或者其他静态网页生成工具，生成好静态文件，然后使用hexo等工具的发布功能，就会使用ssh来更新github项目的文件，即生成一个新的commit然后push。github检测到这个项目更新，就会更新你的网站的内容（会有缓存）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;利用一个下午搭建起了github pages + hexo 的静态博客，试用了下效果，还是挺满意的，至少比csdn的页面好看多了，哈哈。&lt;b
    
    </summary>
    
      <category term="闲来研究" scheme="https://github.com/njafei/njafei.github.io/categories/%E9%97%B2%E6%9D%A5%E7%A0%94%E7%A9%B6/"/>
    
    
  </entry>
  
</feed>
