<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>njafei&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/njafei/njafei.github.io/"/>
  <updated>2018-02-23T09:37:34.039Z</updated>
  <id>https://github.com/njafei/njafei.github.io/</id>
  
  <author>
    <name>njafei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES6-Proxy</title>
    <link href="https://github.com/njafei/njafei.github.io/2018/02/23/ES6-Proxy/"/>
    <id>https://github.com/njafei/njafei.github.io/2018/02/23/ES6-Proxy/</id>
    <published>2018-02-23T09:37:04.000Z</published>
    <updated>2018-02-23T09:37:34.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>proxy的作用是代理对象的某些行为，其 实质 是重载对象的方法。</p>
<p>举个例子,我们想要读取一个对象的某个属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;a: &apos;a&apos; , b: &apos;b&apos;&#125;;</div><div class="line">console.log(obj.a); // &apos;a&apos;</div></pre></td></tr></table></figure>
<p>而使用了proxy之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;a: &apos;a&apos;, b: &apos;b&apos;&#125;;</div><div class="line">let handler = &#123;</div><div class="line">	get: fucntion(target, propoty)&#123;</div><div class="line">		return 35;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var proxy = new Proxy(obj, handler);</div><div class="line">console.log(proxy.a);// 35</div></pre></td></tr></table></figure>
<p>相当于 proxy通过handler里面的指令，代理了obj的行为。</p>
<p>proxy能代理的，并不仅仅是get函数，还有如下列表，具体的可以网上查阅下文档。</p>
<ul>
<li>get</li>
<li>set</li>
<li>has</li>
<li>deleteProperty</li>
<li>enumerate</li>
<li>hasOwn</li>
<li>ownKeys</li>
<li>getOwnPropertyDescritor</li>
<li>defineProperty</li>
<li>preventExtensions</li>
<li>getPrototypeOf</li>
<li>isExtensible</li>
<li>setPrototypeOf</li>
<li>apply</li>
<li>construct</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>看完了proxy的文档，感觉模模糊糊有了印象，但是还是对它的使用场景没有概念，网上搜索了下，发下一篇非常好的介绍使用场景的文章，地址如下： <a href="https://segmentfault.com/a/1190000006035363" target="_blank" rel="noopener">[译] 实例解析 ES6 Proxy 使用场景</a>，下面我也会使用这篇文章的例子，来介绍proxy到底怎么用。</p>
<h4 id="校验模块"><a href="#校验模块" class="headerlink" title="校验模块"></a>校验模块</h4><p>这里是重写set函数，实现校验功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">let numericDataStore = &#123;  </div><div class="line">    count: 0,</div><div class="line">    amount: 1234,</div><div class="line">    total: 14</div><div class="line">&#125;;</div><div class="line"></div><div class="line">numericDataStore = new Proxy(numericDataStore, &#123;  </div><div class="line">    set(target, key, value, proxy) &#123;</div><div class="line">        if (typeof value !== &apos;number&apos;) &#123;</div><div class="line">            throw Error(&quot;Properties in numericDataStore can only be numbers&quot;);</div><div class="line">        &#125;</div><div class="line">        return Reflect.set(target, key, value, proxy);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 抛出错误，因为 &quot;foo&quot; 不是数值</div><div class="line">numericDataStore.count = &quot;foo&quot;;</div><div class="line"></div><div class="line">// 赋值成功</div><div class="line">numericDataStore.count = 333;</div></pre></td></tr></table></figure>
<h4 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h4><p>js中的私有属性，约定俗成是通过前面加下划线的方式来实现，这里可以用proxy来实现，并且做到了强制私有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var api = &#123;  </div><div class="line">    _apiKey: &apos;123abc456def&apos;,</div><div class="line">    /* mock methods that use this._apiKey */</div><div class="line">    getUsers: function()&#123;&#125;, </div><div class="line">    getUser: function(userId)&#123;&#125;, </div><div class="line">    setUser: function(userId, config)&#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// logs &apos;123abc456def&apos;;</div><div class="line">console.log(&quot;An apiKey we want to keep private&quot;, api._apiKey);</div><div class="line"></div><div class="line">// get and mutate _apiKeys as desired</div><div class="line">var apiKey = api._apiKey;  </div><div class="line">api._apiKey = &apos;987654321&apos;;</div></pre></td></tr></table></figure>
<h4 id="访问日志"><a href="#访问日志" class="headerlink" title="访问日志"></a>访问日志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">let api = &#123;  </div><div class="line">    _apiKey: &apos;123abc456def&apos;,</div><div class="line">    getUsers: function() &#123; /* ... */ &#125;,</div><div class="line">    getUser: function(userId) &#123; /* ... */ &#125;,</div><div class="line">    setUser: function(userId, config) &#123; /* ... */ &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function logMethodAsync(timestamp, method) &#123;  </div><div class="line">    setTimeout(function() &#123;</div><div class="line">        console.log(`$&#123;timestamp&#125; - Logging $&#123;method&#125; request asynchronously.`);</div><div class="line">    &#125;, 0)</div><div class="line">&#125;</div><div class="line"></div><div class="line">api = new Proxy(api, &#123;  </div><div class="line">    get: function(target, key, proxy) &#123;</div><div class="line">        var value = target[key];</div><div class="line">        return function(...arguments) &#123;</div><div class="line">            logMethodAsync(new Date(), key);</div><div class="line">            return Reflect.apply(value, target, arguments);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">api.getUsers();</div></pre></td></tr></table></figure>
<h4 id="预警和拦截"><a href="#预警和拦截" class="headerlink" title="预警和拦截"></a>预警和拦截</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">let dataStore = &#123;  </div><div class="line">    noDelete: 1235,</div><div class="line">    oldMethod: function() &#123;/*...*/ &#125;,</div><div class="line">    doNotChange: &quot;tried and true&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">const NODELETE = [&apos;noDelete&apos;];  </div><div class="line">const NOCHANGE = [&apos;doNotChange&apos;];</div><div class="line">const DEPRECATED = [&apos;oldMethod&apos;];  </div><div class="line"></div><div class="line">dataStore = new Proxy(dataStore, &#123;  </div><div class="line">    set(target, key, value, proxy) &#123;</div><div class="line">        if (NOCHANGE.includes(key)) &#123;</div><div class="line">            throw Error(`Error! $&#123;key&#125; is immutable.`);</div><div class="line">        &#125;</div><div class="line">        return Reflect.set(target, key, value, proxy);</div><div class="line">    &#125;,</div><div class="line">    deleteProperty(target, key) &#123;</div><div class="line">        if (NODELETE.includes(key)) &#123;</div><div class="line">            throw Error(`Error! $&#123;key&#125; cannot be deleted.`);</div><div class="line">        &#125;</div><div class="line">        return Reflect.deleteProperty(target, key);</div><div class="line"></div><div class="line">    &#125;,</div><div class="line">    get(target, key, proxy) &#123;</div><div class="line">        if (DEPRECATED.includes(key)) &#123;</div><div class="line">            console.warn(`Warning! $&#123;key&#125; is deprecated.`);</div><div class="line">        &#125;</div><div class="line">        var val = target[key];</div><div class="line"></div><div class="line">        return typeof val === &apos;function&apos; ?</div><div class="line">            function(...args) &#123;</div><div class="line">                Reflect.apply(target[key], target, args);</div><div class="line">            &#125; :</div><div class="line">            val;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// these will throw errors or log warnings, respectively</div><div class="line">dataStore.doNotChange = &quot;foo&quot;;  </div><div class="line">delete dataStore.noDelete;  </div><div class="line">dataStore.oldMethod();</div></pre></td></tr></table></figure>
<h4 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h4><p>通过特征来过滤不必要的操作，例如下载中，解析中等中间过程，减少响应的压力</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;  </div><div class="line">    getGiantFile: function(fileId) &#123;/*...*/ &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj = new Proxy(obj, &#123;  </div><div class="line">    get(target, key, proxy) &#123;</div><div class="line">        return function(...args) &#123;</div><div class="line">            const id = args[0];</div><div class="line">            let isEnroute = checkEnroute(id);</div><div class="line">            let isDownloading = checkStatus(id);      </div><div class="line">            let cached = getCached(id);</div><div class="line"></div><div class="line">            if (isEnroute || isDownloading) &#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">            if (cached) &#123;</div><div class="line">                return cached;</div><div class="line">            &#125;</div><div class="line">            return Reflect.apply(target[key], target, args);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;p&gt;proxy的作用是代理对象的某些行为，其 实质 是重载对象的方法。&lt;/p&gt;
&lt;p&gt;举个例子,我们想要读取一个对象的某个属性&lt;/p&gt;
&lt;fig
    
    </summary>
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6-Symbols</title>
    <link href="https://github.com/njafei/njafei.github.io/2018/02/22/ES6-Symbols/"/>
    <id>https://github.com/njafei/njafei.github.io/2018/02/22/ES6-Symbols/</id>
    <published>2018-02-22T05:57:42.000Z</published>
    <updated>2018-02-22T06:00:11.628Z</updated>
    
    <content type="html"><![CDATA[<p>#背景<br>ES5中，属性都可以通过点方法来获取和赋值。这也带来了一个问题，当我想给一个类增加属性的时候，除非我看完这个类的所有细节，否则我很难知道一个属性名是否已经被占用。而ES6为了解决这个问题，引入了一个新的原始类型Symbol，它表示独一无二的值，来避免重复的命名。</p>
<p>加入Symbol之后，JS中的基础类型共有：</p>
<ul>
<li>undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>String</li>
<li>Number</li>
<li>Object</li>
<li>Symbol</li>
</ul>
<p>#使用</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>Symbol的初始化方法很简单，但是要注意，它不是对象（Object），所以不能用new初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let s = Symbol();</div></pre></td></tr></table></figure>
<p>Symbol没有属性，是一个类似于string的数据类型，我的理解，Symbol其实就是独一无二的string。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s.name = &apos;symbol&apos;; //error</div></pre></td></tr></table></figure>
<p>Symbol可以通过加参数的形式来区分不同的Symbol，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let s = Symbol(&apos;foo&apos;);</div></pre></td></tr></table></figure>
<p>注意，即使使用相同的参数来初始化，得到的实例也是不同的，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let a = Symbol(&apos;foo&apos;);</div><div class="line">let b = Symbol(&apos;foo&apos;);</div><div class="line"></div><div class="line">let same = a === b;</div><div class="line"></div><div class="line">console.log(same); //false</div></pre></td></tr></table></figure>
<p>如果想要获取以某个string为参数的Symbol，在之后会讲到Symbol.for()函数。</p>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>使用Symbol给属性赋值，用法和string属性赋值基本相似，但是不可以用<code>.</code>,要用<code>[]</code>。以下是三种赋值方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">let s = Symbol();</div><div class="line"></div><div class="line"></div><div class="line">let a = &#123;&#125;;</div><div class="line"></div><div class="line">// method 1</div><div class="line">a[s] = &apos;hello&apos;;</div><div class="line"></div><div class="line">//method 2</div><div class="line">a = &#123;</div><div class="line">	[s] = &apos;hello&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//method 3</div><div class="line"></div><div class="line">Object.defineProperty(a, s, &#123;value: &apos;hello&apos;&#125;);</div></pre></td></tr></table></figure>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>Symbol的一个场景是上述提到的，给一个类增加属性，而避免属性重复。</p>
<p>第二是使用在常量中，<code>switch case</code>来保证唯一性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let CASE1 = Symbol();</div><div class="line">let CASE2 = Symbol();</div><div class="line"></div><div class="line">switch (case) &#123;</div><div class="line">	case CASE1 :&#123;</div><div class="line">		return 1;</div><div class="line">	&#125;</div><div class="line">	case CASE2 :&#123;</div><div class="line">		return 2;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="注意事项（和string属性不同的地方）"><a href="#注意事项（和string属性不同的地方）" class="headerlink" title="注意事项（和string属性不同的地方）"></a>注意事项（和string属性不同的地方）</h1><p>最主要的区别，使用 <code>for ... in</code>、 <code>for ... of</code> 或者<code>Object.keys()</code>、 <code>Object.getOwnPropertyNames()</code>不会返回Symbol</p>
<p>如果想获取对象的所有Symbols，使用函数<code>getOwnPropertySymbols</code></p>
<p>有个新的API，<code>Reflect.ownKyes</code>，会返回所有的String属性和Symbol属性</p>
<h1 id="Symbol-keyFor和Symbol-for"><a href="#Symbol-keyFor和Symbol-for" class="headerlink" title="Symbol.keyFor和Symbol.for"></a>Symbol.keyFor和Symbol.for</h1><h3 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for"></a>Symbol.for</h3><p>Symbol会返回一个新的实例，无论参数是什么，上面已经将到了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let a = Symbol(&apos;foo&apos;);</div><div class="line">let b = Symbol(&apos;foo&apos;);</div><div class="line"></div><div class="line">let same = a === b; //false</div></pre></td></tr></table></figure>
<p>而Symbol.for则会先搜索是否有以这个参数初始化的Symbol，如果有则放回这个Symbol，否则初始化一个新的,实现逻辑如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Symbol.for(params) = &#123;</div><div class="line">	if (searchSymbolInitWithParams)&#123;</div><div class="line">		return found_symbol;</div><div class="line">	&#125; else &#123;</div><div class="line">		return Symbol(params);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和第一个例子对比看下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let a = Symbol.for(&apos;foo&apos;);</div><div class="line">let b = Symbol.for(&apos;foo&apos;);</div><div class="line"></div><div class="line">let same = a === b; //true</div></pre></td></tr></table></figure>
<p>如果Symbol和Symbol.for混用呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let a = Symbol(&apos;foo&apos;);</div><div class="line">let b = Symbol.for(&apos;foo&apos;);</div><div class="line"></div><div class="line">console.log(a===b); //false</div></pre></td></tr></table></figure>
<p>这说明两者是没有打通的，即Symbol初始化的实例无法被Symbol.for找到</p>
<h3 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor"></a>Symbol.keyFor</h3><p>用Symbol.for来初始化的Symbol，如何知道它的初始化参数呢，这里提供了一个方法： Symbol.keyFor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let a = Symbol.for(&apos;foo&apos;);</div><div class="line">let b = Symbol.Keyfor(a);// &apos;foo&apos;</div></pre></td></tr></table></figure>
<p>注意，Symbol初始化不能用这个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let a = Symbol(&apos;foo&apos;);</div><div class="line">let b = Symbol.Keyfor(a);// undefined</div></pre></td></tr></table></figure>
<p>注意：Symbol.for 为Symbol值登记的是全局的，这意味着在不同的iframe都可以取到同一个值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#背景&lt;br&gt;ES5中，属性都可以通过点方法来获取和赋值。这也带来了一个问题，当我想给一个类增加属性的时候，除非我看完这个类的所有细节，否则我很难知道一个属性名是否已经被占用。而ES6为了解决这个问题，引入了一个新的原始类型Symbol，它表示独一无二的值，来避免重复的命名
    
    </summary>
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>React Native性能优化</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/10/25/RNpreformance/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/10/25/RNpreformance/</id>
    <published>2017-10-25T03:00:45.000Z</published>
    <updated>2017-10-25T03:03:48.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于帧"><a href="#关于帧" class="headerlink" title="关于帧"></a>关于帧</h2><p>在讲述如何优化性能之前，我们要先了解一下性能的概念。对一个从未接触过相关概念的人来说，所谓的性能就是当你去使用App的时候很流畅，点击、跳转等交互效果反应很快，而且很顺滑。这是感性的角度，那么理性的角度或者数据的角度看待呢？</p>
<p>这里要介绍一个概念： 帧率。我们知道，所谓的动画或者电影，其实归根结底就是在一秒内快速闪过多张不同的图片，如果快到一定的程度，肉眼会误以为里面的动画都是连贯的。在iOS等设备，标准是每秒60帧（即每秒连续展示60张图片），这个标准足以保证用户的体验。</p>
<p><img src="https://gss0.baidu.com/94o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/d1160924ab18972be457999ee2cd7b899e510a70.jpg" alt="动画示意"></p>
<p>系统会每16.6毫秒询问你下一帧的数据，如果你正在处理比较复杂的任务，则系统会默认这一帧内容保持不变，即出现了丢帧的现象。如果丢的帧比较多，则界面会看起来卡顿，比如用户点击了按钮，但是没有反馈。</p>
<p>对<code>React Native</code>来说，帧分为两种： <code>JavaScript</code>帧和主线程帧（<code>UI</code>帧）</p>
<h3 id="JavaScript帧"><a href="#JavaScript帧" class="headerlink" title="JavaScript帧"></a>JavaScript帧</h3><p><code>React Native</code>大部分的业务处理，都是在<code>JavaScript</code>帧中进行，包括API调用和触摸等交互的处理。那么当处理比较复杂的任务，比如<code>setState</code>然后<code>render</code>，则很可能会丢帧。或者做由JS处理的动画时，也极容易出现丢帧卡顿。</p>
<h3 id="主线程帧（UI帧）"><a href="#主线程帧（UI帧）" class="headerlink" title="主线程帧（UI帧）"></a>主线程帧（<code>UI</code>帧）</h3><p>iOS的主线程是UI线程，所以在iOS的UI效果基本是非常出色的，这也是为什么<code>NavigatorIOS</code>比<code>Navigator</code>的性能好很多的原因（<code>NavigatorIOS</code>是主线程处理，而<code>Navigator</code>是JS线程处理）</p>
<h3 id="如何查看帧数据"><a href="#如何查看帧数据" class="headerlink" title="如何查看帧数据"></a>如何查看帧数据</h3><p>我们可以通过打开<code>RN</code>的<code>Debug</code>菜单，然后选择<code>Show Perf Monitor</code>来查看当前页面的<code>JS</code>帧和主线程帧。</p>
<p>好了，性能的定义和我们评估性能标准已经知道了，下面我们来看下影响性能的因素。</p>
<h2 id="影响性能的因素和提升方案"><a href="#影响性能的因素和提升方案" class="headerlink" title="影响性能的因素和提升方案"></a>影响性能的因素和提升方案</h2><h3 id="宽泛的原因"><a href="#宽泛的原因" class="headerlink" title="宽泛的原因"></a>宽泛的原因</h3><p>我们先抛开RN或者iOS的前端框架，看下对一台带屏幕的设备来说，影响性能的原因有哪些。</p>
<p>我们用金字塔模式来看，首先最明显的有两个</p>
<ul>
<li>设备性能</li>
<li>程序设计</li>
</ul>
<p>从根本上来说，设备性能是最大的瓶颈，不过这个我们程序员暂时无能为力。而程序设计可能引起性能差的有哪些呢？判断程序设计的一个标准就是复杂度， 而复杂度又分为两个：</p>
<ul>
<li>时间复杂度</li>
<li>空间复杂度</li>
</ul>
<p>这时我们的性能因素树是：</p>
<ul>
<li>设备性能</li>
<li>程序设计<ul>
<li>时间复杂度</li>
<li>空间复杂度</li>
</ul>
</li>
</ul>
<p>在设备空间充足的情况下，主要的影响就是时间复杂度，而时间复杂度高的原因有几个：</p>
<ul>
<li>前端方案不合理，UI层次或者顺序设计不合理，浪费性能</li>
<li>使用的算法过于复杂</li>
</ul>
<p>我们挨个说下这两个个问题，前端方案是最容易造成性能不好的原因，比如我们有屏幕上有几个区域，互相之间没有影响，而由于不合理的设计，在一个区域变化的时候，要刷新这个界面，就会出现卡顿。一个合理的前端方案，应该是尽可能减少页面的刷新频率和刷新范围，保证每帧的计算是相对小的。</p>
<p>而算法过于复杂，则是算法消耗的时间太长，影响了UI的渲染。比如使用了圈复杂度非常高的算法，或者有大量的数据要不停地计算。</p>
<p>这样我们的性能因素树变成了：</p>
<ul>
<li>设备性能</li>
<li>程序设计<ul>
<li>空间复杂度</li>
<li>时间复杂度<ul>
<li>前端方案不合理，UI层次或者顺序设计不合理，浪费性能<ul>
<li>使用的算法过于复杂</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>可能还会有人觉得网络等原因会造成卡顿，但是我觉得如果交互设计良好，网络状况不好的话，只会影响数据出现的时间长，而不会造成页面的卡顿。</p>
<p>看完了比较普遍宽泛的原因，我们看下针对RN的</p>
<h3 id="RN的特有原因"><a href="#RN的特有原因" class="headerlink" title="RN的特有原因"></a>RN的特有原因</h3><h4 id="JS-Bridge的效率"><a href="#JS-Bridge的效率" class="headerlink" title="JS Bridge的效率"></a>JS Bridge的效率</h4><p>虽然官方的文章里没有写，但是从我测试看到的数据来看，虽然RN的性能比较接近Native，但是因为JS是运行在子线程中的，所以处理大量数据或者动画的时候，JS的帧数会比较少。</p>
<p>这个我们暂时无能为力</p>
<h4 id="动画和Touchable组件在JS线程中运行"><a href="#动画和Touchable组件在JS线程中运行" class="headerlink" title="动画和Touchable组件在JS线程中运行"></a>动画和Touchable组件在JS线程中运行</h4><p>Animated和Touchable系列组件都是在JS中运行，所以在处理复杂动画或者复杂操作的时候，会出现卡顿。</p>
<p>这里给几个建议：</p>
<ul>
<li><p>关于导航</p>
<ol>
<li>iOS上使用<code>NavigatorIOS</code>替换<code>Navigator</code>，同时，react也推出了新的<a href="https://reactnavigation.org/" target="_blank" rel="noopener">Navigation库</a>希望解决导航卡顿的问题</li>
<li>push的新界面的动画，使用<code>InteractionManager</code>，就是在导航动画结束后执行新的动画，而不是同时执行</li>
</ol>
</li>
<li><p>关于动画</p>
<ol>
<li>如果<code>Animated</code>的效果不能接受，使用<code>LayoutAnimation</code>，它是基于<code>Core Animation</code></li>
<li>android上面尽量少用动画（真的很卡0_0）</li>
</ol>
</li>
</ul>
<h4 id="其他建议"><a href="#其他建议" class="headerlink" title="其他建议"></a>其他建议</h4><ul>
<li>使用<a href="">PureComponent</a></li>
<li>使用 <code>shouldComponentUpdate</code>函数，这个函数默认返回true，但是我们可以通过自定义来优化重新绘制的逻辑</li>
<li>release 去除console.log()</li>
</ul>
<figure class="highlight plain"><figcaption><span>(!__DEV__) &#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  global.console = &#123;</div><div class="line">    info: () =&gt; &#123;&#125;,</div><div class="line">    log: () =&gt; &#123;&#125;,</div><div class="line">    warn: () =&gt; &#123;&#125;,</div><div class="line">    debug: () =&gt; &#123;&#125;,</div><div class="line">    error: () =&gt; &#123;&#125;,</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="最重要的建议"><a href="#最重要的建议" class="headerlink" title="最重要的建议"></a>最重要的建议</h4><ol>
<li>仔细考虑UI的设计</li>
<li>仔细考虑UI的设计</li>
<li>仔细考虑UI的设计</li>
</ol>
<p>一个好的UI设计方案，是可以抵过上面所有的建议加起来的效果的，所以一定要仔细考虑再动手。</p>
<p>参考：</p>
<ul>
<li><a href="http://reactnative.cn/docs/0.49/performance.html#content" target="_blank" rel="noopener">官方文档：性能</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于帧&quot;&gt;&lt;a href=&quot;#关于帧&quot; class=&quot;headerlink&quot; title=&quot;关于帧&quot;&gt;&lt;/a&gt;关于帧&lt;/h2&gt;&lt;p&gt;在讲述如何优化性能之前，我们要先了解一下性能的概念。对一个从未接触过相关概念的人来说，所谓的性能就是当你去使用App的时候很流畅，点
    
    </summary>
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/categories/React-Native/"/>
    
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/tags/React-Native/"/>
    
      <category term="performance" scheme="https://github.com/njafei/njafei.github.io/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>Next增加搜索localSearch</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/10/19/Next-add-localSearch/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/10/19/Next-add-localSearch/</id>
    <published>2017-10-19T08:06:51.000Z</published>
    <updated>2017-10-19T08:12:28.931Z</updated>
    
    <content type="html"><![CDATA[<p>Next本身增加localSearch很简单，三步即可：</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-generator-searchdb --save</div></pre></td></tr></table></figure>
<p>编辑 站点配置文件，新增以下内容到任意位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">search:</div><div class="line">  path: search.xml</div><div class="line">  field: post</div><div class="line">  format: html</div><div class="line">  limit: 10000</div></pre></td></tr></table></figure>
<p>编辑 主题配置文件，启用本地搜索功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># Local search</div><div class="line">local_search:</div><div class="line">  enable: true</div></pre></td></tr></table></figure>
<h2 id="遇到问题，一直loading"><a href="#遇到问题，一直loading" class="headerlink" title="遇到问题，一直loading"></a>遇到问题，一直loading</h2><p>发布了之后，点击搜索一直在loading，查了其他人的文章<a href="https://www.v2ex.com/amp/t/298727" target="_blank" rel="noopener">Hexo next 主题的 local search 功能失效，点击搜索链接无法弹出叠加层
</a>，发现是<code>search.xml</code>出现了问题。</p>
<p>排查问题步骤：</p>
<ol>
<li>command + option + J 打开调试器</li>
<li>点击NetWork，发现卡在了<code>search.xml</code>上面</li>
<li>尝试debug <code>serach.xml</code>文件，打开 <a href="https://njafei.github.io/search.xml" target="_blank" rel="noopener">https://njafei.github.io/search.xml</a></li>
<li>看到警告： <code>error on line 92 at column 35: Input is not proper UTF-8, indicate encoding ! 0x10 0xE6 0x88 0x96</code></li>
<li>编码问题，找到对应的文章，先对其进行<code>utf-8</code>编码，然后放到sublimeText中，我发现中间多了一个类似于<code>DEL</code>的乱码，删除即可</li>
<li>重新发布，搜索可用</li>
</ol>
<h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><p>search有时候会有缓存，这时候，可以打开对应的<code>search.xml</code>文件<a href="https://njafei.github.io/search.xml" target="_blank" rel="noopener">https://njafei.github.io/search.xml</a>，刷新几下即可</p>
<blockquote>
<p>PS： 如果你想刷新你的文件，把前面的链接替换即可。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Next本身增加localSearch很简单，三步即可：&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;安装 hexo-generator-searchdb，在站点的根目录
    
    </summary>
    
    
      <category term="博客搭建和功能增强" scheme="https://github.com/njafei/njafei.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E5%8A%9F%E8%83%BD%E5%A2%9E%E5%BC%BA/"/>
    
  </entry>
  
  <entry>
    <title>ImageOptm 自动化无损优化图片</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/09/26/ImageOptm/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/09/26/ImageOptm/</id>
    <published>2017-09-26T03:01:58.000Z</published>
    <updated>2017-10-19T03:37:16.720Z</updated>
    
    <content type="html"><![CDATA[<p>iOS控制包的大小对于公司来说，是个非常重要的事情。因为苹果公司对于包的大小超过100M的，不会允许用户使用移动网络来下载，这很可能造成商业上的损失。</p>
<p>而在控制包的大小中，一个很重要的原则就是禁止大图片。之前研究其他公司的ipa包的时候，就出现过一个icon高达1M的事故。而平时，虽然程序员们百般小心，难免被设计师暗算给张大图（玩笑），所以靠人终究不是一个可持续的保证质量的方法。</p>
<p>平时用的无损压缩最多的工具是<code>ImageOptm</code>，它可以无损压缩图片（即用户看起来感官无变化，而图片尽可能小），而且它是提供命令行的，<a href="https://imageoptim.com/command-line.html" target="_blank" rel="noopener">ImageOptm command line</a>.</p>
<p>我们就可以通过Jenkins的定时任务，每天凌晨去优化所有的图片，然后再自动commit上传。</p>
<p>具体任务就很简单了，大概几个步骤：</p>
<p>1、Jenkins开个定时任务，更新代码</p>
<p>2、执行ImageOptm脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/Applications/ImageOptim.app/Contents/MacOS/ImageOptim  $WORKSPACE/</div></pre></td></tr></table></figure>
<p>3、上传代码</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS控制包的大小对于公司来说，是个非常重要的事情。因为苹果公司对于包的大小超过100M的，不会允许用户使用移动网络来下载，这很可能造成商业上的损失。&lt;/p&gt;
&lt;p&gt;而在控制包的大小中，一个很重要的原则就是禁止大图片。之前研究其他公司的ipa包的时候，就出现过一个icon高
    
    </summary>
    
    
      <category term="自动化" scheme="https://github.com/njafei/njafei.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Java对空格的encode格式问题</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/09/22/Java-space-encode/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/09/22/Java-space-encode/</id>
    <published>2017-09-22T08:57:41.000Z</published>
    <updated>2017-10-19T03:37:16.721Z</updated>
    
    <content type="html"><![CDATA[<p>今天发现了一个非常奇怪的问题，服务端给了一个encode的url，内容是位“1 1”：</p>
<p>encode之后是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1+1</div></pre></td></tr></table></figure>
<p>前端decode之后是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1+1</div></pre></td></tr></table></figure>
<p>可是在其他的浏览器等decode之后的结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 1</div></pre></td></tr></table></figure>
<p>发现java的encode有个坑，在java中，encode遵循的标准是<a href="http://www.faqs.org/rfcs/rfc1738.html" target="_blank" rel="noopener">rfc1738</a>，而在iOS中，encode遵循的标准是<a href="http://www.faqs.org/rfcs/rfc2396.html" target="_blank" rel="noopener">rfc2396</a>，两者对于空格的encode不同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rfc1738 =&gt; +</div><div class="line">rfc2396 =&gt; %20</div></pre></td></tr></table></figure>
<p>所以今后和Java服务端合作的时候，如果encode之后的文案出现了+号这种莫名奇妙的bug，记得让他们检查下encode的代码，可以通过替换来解决这个问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天发现了一个非常奇怪的问题，服务端给了一个encode的url，内容是位“1 1”：&lt;/p&gt;
&lt;p&gt;encode之后是&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div 
    
    </summary>
    
    
      <category term="小知识" scheme="https://github.com/njafei/njafei.github.io/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>React-Native优化之PureComponent</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/07/27/pureComponent/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/07/27/pureComponent/</id>
    <published>2017-07-27T10:56:18.000Z</published>
    <updated>2017-10-19T03:37:16.729Z</updated>
    
    <content type="html"><![CDATA[<p>React15.3的发布中包含了PureComponent，这个类最重要的用法是为了优化React的性能，下面我们将看下它是如何优化的。</p>
<h1 id="Component-VS-PureComponent"><a href="#Component-VS-PureComponent" class="headerlink" title="Component VS PureComponent"></a>Component VS PureComponent</h1><p>首先要看Component的生命周期：<br><img src="http://on0hv7n2x.bkt.clouddn.com/component-lifecycle.jpg" alt=""></p>
<p>当props或者state改变的时候，会执行<code>shouldComponentUpdate</code>方法来判断是否需要重新render组建，我们平时在做页面的性能优化的时候，往往也是通过这一步来判断的。Component默认的<code>shouldComponentUpdate</code>返回的是true，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">shouldComponentUpdate(nextProps, nextState) &#123;</div><div class="line">  return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而PureComponent的<code>shouldComponentUpdate</code>是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (this._compositeType === CompositeTypes.PureClass) &#123;</div><div class="line">  shouldUpdate = !shallowEqual(prevProps, nextProps) || ! shallowEqual(inst.state, nextState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的比较，只会做潜比较，即比较两者的内存地址是否相同，而对于其值是否发生变化，则不会理会。我们通过以下的例子来看下：</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Sample React Native App</div><div class="line"> * https://github.com/facebook/react-native</div><div class="line"> * @flow</div><div class="line"> */</div><div class="line"></div><div class="line">import React, &#123; PureComponent,Component &#125; from &apos;react&apos;;</div><div class="line">import &#123;</div><div class="line">  AppRegistry,</div><div class="line">  StyleSheet,</div><div class="line">  Text,</div><div class="line">  View,</div><div class="line">  Button</div><div class="line">&#125; from &apos;react-native&apos;;</div><div class="line"></div><div class="line">export default class test extends PureComponent &#123;</div><div class="line">  constructor(props)&#123;</div><div class="line">    super(props);</div><div class="line">    this.state = &#123;</div><div class="line">       number : 1,</div><div class="line">       numbers: [],</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">        &lt;Button title=&#123;&apos;number + 1&apos;&#125; onPress=&#123;this.numberAdd.bind(this)&#125; /&gt;</div><div class="line">        &lt;Text&gt;number value: &#123;this.state.number&#125;&lt;/Text&gt;</div><div class="line">        &lt;Button title=&#123;&apos;numbers + 1&apos;&#125; onPress=&#123;this.numbersAdd.bind(this)&#125; /&gt;</div><div class="line">        &lt;Text&gt;numbers length: &#123;this.state.numbers.length&#125;&lt;/Text&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  numberAdd()&#123;</div><div class="line">      this.setState(&#123;number: ++this.state.number &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  numbersAdd()&#123;</div><div class="line">    let numbers = this.state.numbers;</div><div class="line">    numbers.push(1);</div><div class="line">    this.setState(&#123;numbers: numbers&#125;);</div><div class="line">    console.log(this.state.numbers);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line">  container: &#123;</div><div class="line">    flex: 1,</div><div class="line">    justifyContent: &apos;center&apos;,</div><div class="line">    alignItems: &apos;center&apos;,</div><div class="line">    backgroundColor: &apos;#F5FCFF&apos;,</div><div class="line">  &#125;,</div><div class="line">  welcome: &#123;</div><div class="line">    fontSize: 20,</div><div class="line">    textAlign: &apos;center&apos;,</div><div class="line">    margin: 10,</div><div class="line">  &#125;,</div><div class="line">  instructions: &#123;</div><div class="line">    textAlign: &apos;center&apos;,</div><div class="line">    color: &apos;#333333&apos;,</div><div class="line">    marginBottom: 5,</div><div class="line">  &#125;,</div><div class="line">&#125;);</div><div class="line"></div><div class="line">AppRegistry.registerComponent(&apos;test&apos;, () =&gt; test);</div></pre></td></tr></table></figure>
<p>界面如下：</p>
<p><img src="http://on0hv7n2x.bkt.clouddn.com/screenShotSimulator%20Screen%20Shot%202017%E5%B9%B47%E6%9C%8827%E6%97%A5%20%E4%B8%8B%E5%8D%886.48.31.png" alt=""></p>
<p>这里去点击number+1 和 numbers+1都不会有任何页面的变化。</p>
<h1 id="如何让PureComponent重绘"><a href="#如何让PureComponent重绘" class="headerlink" title="如何让PureComponent重绘"></a>如何让PureComponent重绘</h1><p>那如果PureComponent变化的时候(这其实不符合我们的初衷)，我们要怎么做呢？这里有两个办法：</p>
<ol>
<li>重写shouldUpdateComponent方法</li>
<li>props或者state增减参数</li>
</ol>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">numbersAdd()&#123;</div><div class="line">    let numbers = this.state.numbers;</div><div class="line">    numbers.push(1);</div><div class="line">    this.setState(&#123;numbers: numbers&#125;);</div><div class="line">    console.log(this.state.numbers);</div><div class="line"></div><div class="line">    this.setState(&#123;newState: 1&#125;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这样，shouldComponentUpdate的返回值也会是true。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综上，PureComponent非常适合于不变的组件，尤其是和数据、业务无关的纯展示组件，因为它的节省了大量比较的工作。但是对于大部分的业务来说，界面很少会有不变的组件，所以使用的场景会比较少，但是如果遇到，请尽情使用！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React15.3的发布中包含了PureComponent，这个类最重要的用法是为了优化React的性能，下面我们将看下它是如何优化的。&lt;/p&gt;
&lt;h1 id=&quot;Component-VS-PureComponent&quot;&gt;&lt;a href=&quot;#Component-VS-PureC
    
    </summary>
    
      <category term="react-native" scheme="https://github.com/njafei/njafei.github.io/categories/react-native/"/>
    
    
      <category term="react-native" scheme="https://github.com/njafei/njafei.github.io/tags/react-native/"/>
    
      <category term="component" scheme="https://github.com/njafei/njafei.github.io/tags/component/"/>
    
  </entry>
  
  <entry>
    <title>react-native time定时器 防止内存泄露的注意点</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/07/27/react-native-time-attations/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/07/27/react-native-time-attations/</id>
    <published>2017-07-27T07:50:21.000Z</published>
    <updated>2017-10-19T03:37:16.730Z</updated>
    
    <content type="html"><![CDATA[<p><code>time</code>是<code>react-native</code>提供的一个定时器，在实际使用中，经常会有使用不对，造成内存泄露的情况。很多<code>React Native</code>应用发生致命错误（闪退）是与计时器有关。具体来说，是在某个组件被卸载<code>（unmount）</code>之后，计时器却仍然在运行。</p>
<p>防止出问题的办法也很简单，在<code>unmount</code>的时候，增加卸载定时器的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">componentDidMount() &#123;</div><div class="line">    this.timer = setTimeout(</div><div class="line">      () =&gt; &#123; console.log(&apos;把一个定时器的引用挂在this上&apos;); &#125;,</div><div class="line">      500</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">componentWillUnmount() &#123;</div><div class="line">    // 请注意Un&quot;m&quot;ount的m是小写</div><div class="line">    // 如果存在this.timer，则使用clearTimeout清空。</div><div class="line">    // 如果你使用多个timer，那么用多个变量，或者用个数组来保存引用，然后逐个clear</div><div class="line">    this.timer &amp;&amp; clearTimeout(this.timer);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里的timer是在<code>DidMount</code>中赋值的，如果是多次赋值呢？比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">export default class test extends Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">        &lt;Button title=&#123;&apos;click5000&apos;&#125; onPress=&#123;this.alertInfo.bind(this,5000)&#125; /&gt;</div><div class="line">        &lt;Button title=&#123;&apos;click2000&apos;&#125; onPress=&#123;this.alertInfo.bind(this,2000)&#125; /&gt;</div><div class="line">        &lt;Button title=&#123;&apos;clean timer&apos;&#125; onPress=&#123;this.cleanTimer.bind(this)&#125; /&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  alertInfo(time)&#123;</div><div class="line">      this.timer = setTimeout(</div><div class="line">          ()=&gt;&#123;</div><div class="line">            alert(&apos;hah&apos;);</div><div class="line">          &#125;,</div><div class="line">          time,</div><div class="line">      );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  cleanTimer()&#123;</div><div class="line">    this.timer &amp;&amp; clearTimeout(this.timer);</div><div class="line">    console.log(&apos;timer cleared&apos;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">AppRegistry.registerComponent(&apos;test&apos;, () =&gt; test);</div></pre></td></tr></table></figure>
<p>这里要介绍下<code>setTimeout</code>的返回值，我们打断点可以看到，<code>this.timer</code>是一个number。根据stack上面的其他网友的回答<a href="https://stackoverflow.com/questions/10068981/what-does-settimeout-return" target="_blank" rel="noopener">what-does-settimeout-return</a>，setTimer会返回一个id，代表你已经向js的runtime系统中成功注册了一个定时器任务，这个id就是系统返回的id。</p>
<p>那如果是需要多次赋值，就一定要先将time clear掉，然后再赋值，或者使用多个参数来标志，否则之后就找不到上次的id，也就没办法clear了，同样可能造成内存泄露的情况。</p>
<p>例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Sample React Native App</div><div class="line"> * https://github.com/facebook/react-native</div><div class="line"> * @flow</div><div class="line"> */</div><div class="line"></div><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">import &#123;</div><div class="line">  AppRegistry,</div><div class="line">  StyleSheet,</div><div class="line">  Text,</div><div class="line">  View,</div><div class="line">  Button</div><div class="line">&#125; from &apos;react-native&apos;;</div><div class="line"></div><div class="line">export default class test extends Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">        &lt;Button title=&#123;&apos;click5000&apos;&#125; onPress=&#123;this.alertInfo.bind(this,5000)&#125; /&gt;</div><div class="line">        &lt;Button title=&#123;&apos;click2000&apos;&#125; onPress=&#123;this.alertInfo.bind(this,2000)&#125; /&gt;</div><div class="line">        &lt;Button title=&#123;&apos;clean timer&apos;&#125; onPress=&#123;this.cleanTimer.bind(this)&#125; /&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  alertInfo(time)&#123;</div><div class="line">      this.timer = setTimeout(</div><div class="line">          ()=&gt;&#123;</div><div class="line">            alert(&apos;hah&apos;);</div><div class="line">          &#125;,</div><div class="line">          time,</div><div class="line">      );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  cleanTimer()&#123;</div><div class="line">    this.timer &amp;&amp; clearTimeout(this.timer);</div><div class="line">    console.log(&apos;timer cleared&apos;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line">  container: &#123;</div><div class="line">    flex: 1,</div><div class="line">    justifyContent: &apos;center&apos;,</div><div class="line">    alignItems: &apos;center&apos;,</div><div class="line">    backgroundColor: &apos;#F5FCFF&apos;,</div><div class="line">  &#125;,</div><div class="line">  welcome: &#123;</div><div class="line">    fontSize: 20,</div><div class="line">    textAlign: &apos;center&apos;,</div><div class="line">    margin: 10,</div><div class="line">  &#125;,</div><div class="line">  instructions: &#123;</div><div class="line">    textAlign: &apos;center&apos;,</div><div class="line">    color: &apos;#333333&apos;,</div><div class="line">    marginBottom: 5,</div><div class="line">  &#125;,</div><div class="line">&#125;);</div><div class="line"></div><div class="line">AppRegistry.registerComponent(&apos;test&apos;, () =&gt; test);</div></pre></td></tr></table></figure>
<p>这里的timer多次赋值，虽然前面的值被后面的覆盖，但是前面的time仍然会起效果，如果不想前面的time work，需要clear掉，然后再赋值。</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">alertInfo(time)&#123;</div><div class="line">		this.timer &amp;&amp; clearTimeout(this.timer);</div><div class="line">      this.timer = setTimeout(</div><div class="line">          ()=&gt;&#123;</div><div class="line">            alert(&apos;hah&apos;);</div><div class="line">          &#125;,</div><div class="line">          time,</div><div class="line">      );</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>综上，使用time的注意点：</p>
<ol>
<li>记得unmount的时候，clear</li>
<li>多个timer要使用多个变量或者数组</li>
<li>多次赋值，记得把之前的值clear掉</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;time&lt;/code&gt;是&lt;code&gt;react-native&lt;/code&gt;提供的一个定时器，在实际使用中，经常会有使用不对，造成内存泄露的情况。很多&lt;code&gt;React Native&lt;/code&gt;应用发生致命错误（闪退）是与计时器有关。具体来说，是在某个组件被
    
    </summary>
    
      <category term="react-native" scheme="https://github.com/njafei/njafei.github.io/categories/react-native/"/>
    
    
      <category term="react-native" scheme="https://github.com/njafei/njafei.github.io/tags/react-native/"/>
    
      <category term="注意事项" scheme="https://github.com/njafei/njafei.github.io/tags/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>listView和FlatList的flexGrow默认值为1</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/07/26/listViewFlexGrowDefaultValue/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/07/26/listViewFlexGrowDefaultValue/</id>
    <published>2017-07-26T11:27:06.000Z</published>
    <updated>2017-10-19T03:37:16.728Z</updated>
    
    <content type="html"><![CDATA[<p>今天遇到了适配的问题，有个列表，需要自适应高度，按理说默认应该就是自适应的，但是在实际中发现，其会和另外一个视图1：1 ，然后就发现只有设置其<code>flexGrow: 0</code>的时候，它才会自动适配高度，说明它的flexGrow默认值为1.</p>
<p>看下具体的列子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">import &#123;</div><div class="line">  AppRegistry,</div><div class="line">  StyleSheet,</div><div class="line">  Text,</div><div class="line">  View,</div><div class="line">  ListView,</div><div class="line">&#125; from &apos;react-native&apos;;</div><div class="line"></div><div class="line">export default class testListView extends Component &#123;</div><div class="line">    constructor(props) &#123;</div><div class="line">        super(props);</div><div class="line">        const ds = new ListView.DataSource(&#123;rowHasChanged: (r1, r2) =&gt; r1 !== r2&#125;);</div><div class="line">        this.state = &#123;</div><div class="line">            dataSource: ds.cloneWithRows([</div><div class="line">                &apos;John&apos;, &apos;Joel&apos;, &apos;James&apos;, &apos;Jimmy&apos;, &apos;Jackson&apos;, &apos;Jillian&apos;, &apos;Julie&apos;, &apos;Devin&apos;</div><div class="line">            ])</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">        &lt;View style=&#123;styles.blackView&#125; /&gt;</div><div class="line">        &lt;ListView</div><div class="line">            dataSource=&#123;this.state.dataSource&#125;</div><div class="line">            renderRow=&#123;(rowData) =&gt; &lt;Text&gt;&#123;rowData&#125;&lt;/Text&gt;&#125;</div><div class="line">            style=&#123;styles.list&#125;</div><div class="line">        /&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line">  container: &#123;</div><div class="line">    flexGrow: 1,</div><div class="line">    backgroundColor: &apos;#F5FCFF&apos;,</div><div class="line">  &#125;,</div><div class="line">  list:&#123;</div><div class="line">    backgroundColor: &apos;red&apos;,</div><div class="line">  &#125;,</div><div class="line">  blackView: &#123;</div><div class="line">    flexGrow: 1,</div><div class="line">    backgroundColor: &apos;black&apos;,</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">AppRegistry.registerComponent(&apos;testListView&apos;, () =&gt; testListView);</div></pre></td></tr></table></figure>
<p>这个UI看起来是这样： </p>
<p><img src="http://on0hv7n2x.bkt.clouddn.com/Simulator%20Screen%20Shot%202017%E5%B9%B47%E6%9C%8826%E6%97%A5%20%E4%B8%8B%E5%8D%887.20.31.png" alt=""></p>
<p>如果style中的list改成这样，就好了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">list:&#123;</div><div class="line">    backgroundColor: &apos;red&apos;,</div><div class="line">    flexGrow: 0,  </div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>显示成： </p>
<p><img src="http://on0hv7n2x.bkt.clouddn.com/Simulator%20Screen%20Shot%202017%E5%B9%B47%E6%9C%8826%E6%97%A5%20%E4%B8%8B%E5%8D%887.21.58.png" alt=""></p>
<p>综上，我怀疑<code>FlatList和ListView</code>的<code>flexGrow</code>默认值是1.有遇到类似问题的，不妨试试这样解决。</p>
<p>版本： “react-native”: “0.43.4”</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天遇到了适配的问题，有个列表，需要自适应高度，按理说默认应该就是自适应的，但是在实际中发现，其会和另外一个视图1：1 ，然后就发现只有设置其&lt;code&gt;flexGrow: 0&lt;/code&gt;的时候，它才会自动适配高度，说明它的flexGrow默认值为1.&lt;/p&gt;
&lt;p&gt;看下
    
    </summary>
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/categories/React-Native/"/>
    
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/tags/React-Native/"/>
    
      <category term="奇怪的bug" scheme="https://github.com/njafei/njafei.github.io/tags/%E5%A5%87%E6%80%AA%E7%9A%84bug/"/>
    
  </entry>
  
  <entry>
    <title>如何访问和修改一个对象的私有属性</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/06/15/howToChangeObjectProperty/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/06/15/howToChangeObjectProperty/</id>
    <published>2017-06-15T10:03:36.000Z</published>
    <updated>2017-10-19T03:37:16.727Z</updated>
    
    <content type="html"><![CDATA[<p>有两个思路：</p>
<ul>
<li>KVC</li>
<li>runtime</li>
</ul>
<p>先给出我们接下来要使用的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@interface Person : NSObject</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@interface Person()</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *name;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Person</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h1 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h1><p>KVC是我比较推荐的，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Person *person = [Person new];</div><div class="line">    </div><div class="line">[person setValue:@&quot;new name&quot; forKey:@&quot;name&quot;];</div><div class="line"></div><div class="line">NSString *name = [person valueForKey:@&quot;name&quot;];</div></pre></td></tr></table></figure>
<p>KVC是苹果推荐用来做类似事情的方法，所以这种需求，KVC解决是最好的，代码简洁，效率也比较高。<br>关于KVC的相关内容可以看下<a href="https://njafei.github.io/2017/04/18/KVC/" target="_blank" rel="noopener">KVC详解</a></p>
<h1 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h1><p>runtime的思路就是先读取对象的所有属性，然后找到对象的属性，赋值。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Person *person = [Person new];</div><div class="line"></div><div class="line">unsigned int count = 0; //count记录变量的数量</div><div class="line"></div><div class="line">Ivar *members = class_copyIvarList([person class], &amp;count);</div><div class="line">for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">    Ivar ivar = members[i];</div><div class="line">    const char *memberName = ivar_getName(ivar);</div><div class="line">    NSString *memberNameString = [NSString stringWithFormat:@&quot;%s&quot;,memberName];</div><div class="line">    </div><div class="line">    if ([memberNameString isEqualToString: @&quot;_name&quot;]) &#123;</div><div class="line">        object_setIvar(person, ivar, @&quot;newName&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>runtime的做法相对来讲代码比较多，也不够简洁，但是还是可以实现这个需求的。runtime的详细内容可以参考<a href="https://njafei.github.io/2017/05/04/runtime/" target="_blank" rel="noopener">iOS Runtime 详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有两个思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;KVC&lt;/li&gt;
&lt;li&gt;runtime&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先给出我们接下来要使用的类：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/njafei/njafei.github.io/categories/iOS/"/>
    
    
      <category term="iOS面试题" scheme="https://github.com/njafei/njafei.github.io/tags/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Error RawText ** must be wrapped in an explicit &lt;Text&gt; component 问题解决</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/06/14/stringToBoolError/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/06/14/stringToBoolError/</id>
    <published>2017-06-14T03:05:55.000Z</published>
    <updated>2017-10-19T03:37:16.734Z</updated>
    
    <content type="html"><![CDATA[<p>今天忽然遇到一个页面崩溃，查到错误如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error: RawText &quot;&quot; must be wrapped in an explicit &lt;Text&gt; component.</div></pre></td></tr></table></figure>
<p>查了代码，发现好久都没有动这块的代码了，所以非常疑惑。最后通过2分法不停地查哪里出了问题，最终查到了这个语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">return (</div><div class="line">    &lt;View&gt;</div><div class="line">        &#123;test &amp;&amp; test.string &amp;&amp;</div><div class="line">        &lt;Text&gt;&#123;test.string&#125;&lt;/Text&gt;</div><div class="line">        &#125;</div><div class="line">    &lt;/View&gt;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>其实作用很简单，如果string有值，则展示string。但是这条语句为什么会报错呢？查了半天，发现是因为string的值是’’,然后系统就报错了，类似这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let test = &#123;string: &apos;&apos;&#125;;</div><div class="line">return (</div><div class="line">    &lt;View&gt;</div><div class="line">        &#123;test &amp;&amp; test.string &amp;&amp;</div><div class="line">        &lt;Text&gt;&#123;test.string&#125;&lt;/Text&gt;</div><div class="line">        &#125;</div><div class="line">    &lt;/View&gt;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>后来查了下github，发现很多人也遇到了类似的错误，解决办法如下,使用!!来判断string是否有值，因为这里其实你是希望将<code>string</code>当成<code>bool</code>来使用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let test = &#123;string: &apos;&apos;&#125;;</div><div class="line">return (</div><div class="line">    &lt;View&gt;</div><div class="line">        &#123;test &amp;&amp; !!test.string &amp;&amp;</div><div class="line">        &lt;Text&gt;&#123;test.string&#125;&lt;/Text&gt;</div><div class="line">        &#125;</div><div class="line">    &lt;/View&gt;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>所以以后string的判断，都用!!去判断，否则出现string恰好为’’的时候，就会崩溃。</p>
<p>参考文章：</p>
<ul>
<li><a href="https://github.com/GeekyAnts/NativeBase/issues/186">https://github.com/GeekyAnts/NativeBase/issues/186</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天忽然遇到一个页面崩溃，查到错误如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class
    
    </summary>
    
      <category term="bugFix" scheme="https://github.com/njafei/njafei.github.io/categories/bugFix/"/>
    
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/tags/React-Native/"/>
    
      <category term="奇怪的bug" scheme="https://github.com/njafei/njafei.github.io/tags/%E5%A5%87%E6%80%AA%E7%9A%84bug/"/>
    
  </entry>
  
  <entry>
    <title>block</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/06/13/block/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/06/13/block/</id>
    <published>2017-06-13T05:20:58.000Z</published>
    <updated>2017-10-19T03:37:16.726Z</updated>
    
    <content type="html"><![CDATA[<p>其实使用<code>block</code>的时间也蛮久了，比如使用<code>__block</code>,<code>weak</code>防止循环引用，<code>copy</code>修饰等注意点也都知道，但是一直没有去看过官方的文档，仔细看下所有的点。今天就把官方文档撸一遍，深入了解下。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>苹果在介绍<code>block</code>的使用场景时，是这么说的：</p>
<blockquote>
<p>You use a block when you want to create units of work (that is, code segments) that can be passed around as though they are values. Blocks offer more flexible programming and more power. </p>
</blockquote>
<p>当你想要做一连串的工作时（代码片段），block可以被当成值来传递，从而使程序更加灵活、易用。</p>
<p>我觉得，这个类似于<code>JS</code>的<code>callback</code>，这样写看起来比较直观，不像代理，满天飞，易读性不好。</p>
<h1 id="声明和使用"><a href="#声明和使用" class="headerlink" title="声明和使用"></a>声明和使用</h1><p>正常使用<code>block</code>类似于这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int multiplier = 7;</div><div class="line">int (^myBlock)(int) = ^(int num) &#123;</div><div class="line">    return num * multiplier;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>以前其实我自己在写block的时候，很容易迷糊，因为格式容易记不住，但是看了下面的图，仔细了解下它的结构，以后就好记了</p>
<p><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Blocks/Art/blocks.jpg" alt=""></p>
<p>首先是它的返回值，然后是它的name，接着是参数的类型，声明和实现结构是一样的，只是实现里面会多形参。</p>
<p>看下如何使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int multiplier = 7;</div><div class="line">int (^myBlock)(int) = ^(int num) &#123;</div><div class="line">    return num * multiplier;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">printf(&quot;%d&quot;, myBlock(3));</div><div class="line">// prints &quot;21&quot;</div></pre></td></tr></table></figure>
<p>在苹果提供<code>block</code>之后，它提供了大量的<code>block</code>的函数用法， 比较多的应该就是数据等的遍历。我们自己在写代码的时候，通常数据请求、alert等也都会封装成<code>block</code>的形式，因为真的是易读性比较好。</p>
<h1 id="block和变量"><a href="#block和变量" class="headerlink" title="block和变量"></a>block和变量</h1><p>在<code>block</code>中，是可以直接引用外部的变量的，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int a = 0;</div><div class="line">block(a);</div></pre></td></tr></table></figure>
<p>但是不能直接修改外部的变量，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int a = 0;</div><div class="line">block = ^(int a)&#123;</div><div class="line">	a = 5;//error</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="block"><a href="#block" class="headerlink" title="__block"></a>__block</h4><p>如果你想要在<code>block</code>中改变外部变量的值的话，需要使用<code>__block</code>来修饰，为什么这个关键词可以呢？我们来看下苹果的解释</p>
<blockquote>
<p>__block variables live in storage that is shared between the lexical scope of the variable and all blocks and block copies declared or created within the variable’s lexical scope. Thus, the storage will survive the destruction of the stack frame if any copies of the blocks declared within the frame survive beyond the end of the frame (for example, by being enqueued somewhere for later execution). Multiple blocks in a given lexical scope can simultaneously use a shared variable.</p>
<p>As an optimization, block storage starts out on the stack—just like blocks themselves do. If the block is copied using Block_copy (or in Objective-C when the block is sent a copy), variables are copied to the heap. Thus, the address of a __block variable can change over time.</p>
<p>There are two further restrictions on __block variables: they cannot be variable length arrays, and cannot be structures that contain C99 variable-length arrays.</p>
</blockquote>
<p><code>__block</code>会把变量放到<code>block</code>等的存在的内存中，这样在<code>block</code>存在期间，可以直接修改变量，不同的<code>block</code>都使用这个共享的变量。</p>
<p><code>block</code>默认是存在栈中的，但是如果<code>block</code>被拷贝，则会放到堆中</p>
<p><code>__block</code>有两个注意点，不能是可变化长度的数据，也不能是<a href="https://en.wikipedia.org/wiki/Variable-length_array" target="_blank" rel="noopener">C99标准可变长度的数组</a></p>
<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ol>
<li>为什么要用copy</li>
<li>为什么要避免循环引用，如何避免</li>
<li>避免两个错误模式</li>
</ol>
<h4 id="为什么要用copy"><a href="#为什么要用copy" class="headerlink" title="为什么要用copy"></a>为什么要用copy</h4><p>如上面所述，<code>block</code>默认是存在栈中的，但是如果<code>block</code>被拷贝，则会放到堆中，所以即使你使用strong，其实系统也是会copy一份的，用copy是为了让自己知道，这个<code>block</code>在使用中是会被copy一份的。那么，为什么呢？这因为如果<code>block</code>在栈中，则他的作用域就是栈中所在的作用域，如果在作用域外调用栈的内容，则会崩溃，所以要用copy，就会将其复制到堆中，调用就不会出现问题。当然，用strong也不会有任何问题，但是copy更能让我们使用的时候，知道使用的原因。</p>
<h4 id="循环引用，如何避免"><a href="#循环引用，如何避免" class="headerlink" title="循环引用，如何避免"></a>循环引用，如何避免</h4><p>先看下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">self.printBlock = ^(block)(NSString *) = ^(NSString *name)&#123;</div><div class="line">	[self print: name];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，self会对block强引用，而block中，又会对self强引用，所以系统在回收内存的时候，这两个对象都没有办法回收内存，就造成了内存的泄露了。</p>
<p>怎么避免呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">__weak typeof(self) weakself = self</div><div class="line">self.printBlock = ^(block)(NSString *) = ^(NSString *name)&#123;</div><div class="line">	__strong __typeof(self) strongSelf = weakSelf;//里面使用strong，防止执行block的时候 self被销毁</div><div class="line">	[weakself print: name];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="避免两个错误模式"><a href="#避免两个错误模式" class="headerlink" title="避免两个错误模式"></a>避免两个错误模式</h4><p>苹果在文档中，特意提了两个错误的模式，让大家不要使用，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">void dontDoThis() &#123;</div><div class="line">    void (^blockArray[3])(void);  // an array of 3 block references</div><div class="line"> </div><div class="line">    for (int i = 0; i &lt; 3; ++i) &#123;</div><div class="line">        blockArray[i] = ^&#123; printf(&quot;hello, %d\n&quot;, i); &#125;;</div><div class="line">        // WRONG: The block literal scope is the &quot;for&quot; loop.</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void dontDoThisEither() &#123;</div><div class="line">    void (^block)(void);</div><div class="line"> </div><div class="line">    int i = random():</div><div class="line">    if (i &gt; 1000) &#123;</div><div class="line">        block = ^&#123; printf(&quot;got i at: %d\n&quot;, i); &#125;;</div><div class="line">        // WRONG: The block literal scope is the &quot;then&quot; clause.</div><div class="line">    &#125;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两个用法本身是可以执行的，但是效率太差。本来block是内联的，所以应该先定义，再使用，而不是上文的用法，每次都重新定义一个。</p>
<p>PS： 内联函数的效率非常高，可以理解为内联是之前把代码片段嵌入到使用的地方，而非内联的函数就是要调用函数了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实使用&lt;code&gt;block&lt;/code&gt;的时间也蛮久了，比如使用&lt;code&gt;__block&lt;/code&gt;,&lt;code&gt;weak&lt;/code&gt;防止循环引用，&lt;code&gt;copy&lt;/code&gt;修饰等注意点也都知道，但是一直没有去看过官方的文档，仔细看下所有的点。今天就把官方
    
    </summary>
    
      <category term="iOS基础" scheme="https://github.com/njafei/njafei.github.io/categories/iOS%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Apple文档" scheme="https://github.com/njafei/njafei.github.io/tags/Apple%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>os.system如何传参</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/05/26/os-system%E5%A6%82%E4%BD%95%E4%BC%A0%E5%8F%82/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/05/26/os-system如何传参/</id>
    <published>2017-05-26T03:21:12.000Z</published>
    <updated>2017-10-19T07:34:08.201Z</updated>
    
    <content type="html"><![CDATA[<p>今天写脚本的时候，正好希望在python脚本中调用另外一个python脚本，就使用了os.system来实现这个功能（当然，还有很多的办法，而且每种方法满足的需求不都一样，有兴趣的读者可以谷歌下）。</p>
<p>但是我需要给这个调用里面传入一个参数，网上查了半天，感觉都不太清晰，就写了这篇，简单介绍下。</p>
<p>os.system的定义是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">os.system(&quot;shell command argusFormat&quot; % argus)</div></pre></td></tr></table></figure>
<p>在双引号里面正常写命令，需要用到参数的地方，使用%s等格式代替，然后在双引号的后面加空格，加%号，然后在括号里写入所有的参数，用逗号隔开。</p>
<h4 id="单个参数"><a href="#单个参数" class="headerlink" title="单个参数"></a>单个参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">param = &apos;I&apos;m param&apos;</div><div class="line">os.system(&quot;python haha.py %s&quot; % (param))</div></pre></td></tr></table></figure>
<h4 id="多个参数"><a href="#多个参数" class="headerlink" title="多个参数"></a>多个参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">paramA = &apos;I&apos;m paramA&apos;</div><div class="line">paramB = &apos;I&apos;m paramB&apos;</div><div class="line">os.system(&quot;python haha.py %s %s&quot; % (paramA,paramB))</div></pre></td></tr></table></figure>
<p>需要注意的是，shell中对于空格的要求特别严格，一定要注意别多或者少（写js的来写shell真的好难受0_0）。</p>
<h4 id="python格式化"><a href="#python格式化" class="headerlink" title="python格式化"></a>python格式化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">%s    字符串 (采用str()的显示)</div><div class="line"></div><div class="line">%r    字符串 (采用repr()的显示)</div><div class="line"></div><div class="line">%c    单个字符</div><div class="line"></div><div class="line">%b    二进制整数</div><div class="line"></div><div class="line">%d    十进制整数</div><div class="line"></div><div class="line">%i    十进制整数</div><div class="line"></div><div class="line">%o    八进制整数</div><div class="line"></div><div class="line">%x    十六进制整数</div><div class="line"></div><div class="line">%e    指数 (基底写为e)</div><div class="line"></div><div class="line">%E    指数 (基底写为E)</div><div class="line"></div><div class="line">%f    浮点数</div><div class="line"></div><div class="line">%F    浮点数，与上相同</div><div class="line"></div><div class="line">%g    指数(e)或浮点数 (根据显示长度)</div><div class="line"></div><div class="line">%G    指数(E)或浮点数 (根据显示长度)</div><div class="line"></div><div class="line">%%    字符&quot;%&quot;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天写脚本的时候，正好希望在python脚本中调用另外一个python脚本，就使用了os.system来实现这个功能（当然，还有很多的办法，而且每种方法满足的需求不都一样，有兴趣的读者可以谷歌下）。&lt;/p&gt;
&lt;p&gt;但是我需要给这个调用里面传入一个参数，网上查了半天，感觉都不
    
    </summary>
    
      <category term="python" scheme="https://github.com/njafei/njafei.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://github.com/njafei/njafei.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>ES6之字符串拓展</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/05/23/ES6%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%93%E5%B1%95/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/05/23/ES6之字符串拓展/</id>
    <published>2017-05-23T09:37:12.000Z</published>
    <updated>2017-10-19T03:37:16.719Z</updated>
    
    <content type="html"><![CDATA[<p>ES6中，还是对字符串做了很多的改进，尤其是函数方面，增加了很多个方法。但是核心的变动，其实只有两个：</p>
<ul>
<li><code>Unicode</code>拓展</li>
<li>字符模板</li>
</ul>
<h1 id="Unicode拓展"><a href="#Unicode拓展" class="headerlink" title="Unicode拓展"></a>Unicode拓展</h1><p>在讲ES6之间，我们先了解一些背景知识。</p>
<h4 id="为什么会出现Unicode"><a href="#为什么会出现Unicode" class="headerlink" title="为什么会出现Unicode"></a>为什么会出现Unicode</h4><p>我们知道，计算机最底层其实只能识别‘0’和‘1’，就是yes或者no。但是人脑是非常高级的，我们见面会打招呼“您吃了没？”，这句话如果是想告知计算机的话，它肯定是听不懂的，最后计算机接收的其实类似于：“01010101010001100111”的字符串。那么，当这些字符串通过QQ展示出来的时候，又要去展示对人脑友好的文字。“您吃了没？”和“01001010111”这样的字符串是如何对应的呢？</p>
<p>因为最初的计算机和技术都是美国发明的，所以他们首先提出了方案<code>ASCII</code>，即使用一个字节表示所有的字符和符号。比如：”00000001”表示”a”,”00000010”表示”b”(举例用，数值不对).这样，使用一个字节就解决了所有的英文展示问题。但是256足够表示所有的英文了，中文可没办法，或者其他语言，也不能够用。这样，就提出了<code>Unicode</code>的概念，希望所有的字符，全部都使用<code>Unicode</code>表示。</p>
<p><code>Unicode</code>的第一个版本是打算使用两个字节来表示所有的字符，比如1-200给英文，200-5000给中文等等，这样总共就有2^16次方个，基本足够了。（后来发现还是不够，<code>Unicode的第二个版本就使用4个字节，共2^32个</code>）</p>
<p>所有的字符都有一个数字对应的了，怎么保存呢？这里很多人容易搞错，因为<code>Unicode</code>提出了使用2个字节来表示所有字符，所以大家把<code>UTF16</code>和<code>Unicode</code>弄混淆了。应该说，<code>UTF16</code>来存储和<code>Unicode</code>真的是天作之合，因为两者都是使用两个字节。但是这样也出现了一个问题，比如如果一篇英文文章，他使用的字符段，都是一个字节就能表示出来了，使用2个字节表示，简直是浪费空间，所以又提出了<code>UTF8</code>，即使用1个字节存储，如果出现了需要两个字节的情况，想办法做兼容。</p>
<p>综上，我们说的<code>Unicode</code>是为了表示所有的字符的一种定义方法，而<code>UTF8</code>和<code>UTF16</code>是为了存储<code>Unicode</code>的一种方案。</p>
<p>这里如果比较有兴趣，可以看下博客<a href="http://www.cnblogs.com/kingcat/archive/2012/10/16/2726334.html" target="_blank" rel="noopener">Unicode(UTF-8, UTF-16)令人混淆的概念</a></p>
<h4 id="ES6做的拓展"><a href="#ES6做的拓展" class="headerlink" title="ES6做的拓展"></a>ES6做的拓展</h4><p>JS是支持直接展示<code>Unicode</code>的，比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(&quot;\u0061&quot;);//&quot;a&quot;;</div></pre></td></tr></table></figure>
<p>但是只限 \u0000 - \FFFF之间的，如果是 \u00001这样的，就不支持了。</p>
<p>而ES6对该点做了补充，可以直接使用了，如：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(&quot;\u&#123;00001&#125;&quot;);//使用大括号包含，和四字节的UTF16等价</div></pre></td></tr></table></figure>
<p> 还可以连接使用：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">conslle.log(&quot;\u&#123;1&#125;\u&#123;2&#125;&quot;);//&quot;ab&quot; 都是举例，对应字符串可能不对</div></pre></td></tr></table></figure>
<p> ES6中还补充了很多的函数，大家有兴趣，自己去翻下文档，这里简单罗列下：</p>
<ul>
<li>codePointAt(）</li>
<li>String.fromCodePoint()</li>
<li>at()</li>
<li>normalize()</li>
<li>includes()</li>
<li>startsWith()</li>
<li>endsWith()</li>
<li>repeat()</li>
</ul>
<h1 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h1><p>在JS中，如果我们想要表达一个含有变量的字符串，大概会这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let name = &quot;飞&quot;;</div><div class="line">let lunch = &quot;午饭&quot;;</div><div class="line">let ask = name + &quot;您吃&quot; + lunch + &quot;吗？&quot;;//飞您吃午饭了吗？</div></pre></td></tr></table></figure>
<p>不得不说，这样写，比较丑。</p>
<h4 id="模板字符串-1"><a href="#模板字符串-1" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>ES6中使用字符模板解决了这个问题，让你可以拼接字符串的时候用的更爽。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let name = &quot;飞&quot;;</div><div class="line">let lunch = &quot;午饭&quot;;</div><div class="line">let ask =  `$&#123;name&#125;您吃$&#123;lunch&#125;吗?`; //您吃午饭了吗？</div></pre></td></tr></table></figure>
<p>是不是优雅多了呢？</p>
<p>另外模板字符串还会记录空格、换行等字符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">let ask =  `飞，</div><div class="line">我今天，</div><div class="line">好</div><div class="line">饿</div><div class="line">啊</div><div class="line">`</div></pre></td></tr></table></figure>
<p>打印出来就是：</p>
<pre><code>飞，
我今天，
好
饿
啊
</code></pre><p>再也不用各种空格符号和换行符号了。</p>
<h4 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h4><p>另外还有一个值得注意的地方，就是标签模板，即在“``”前面，将其变为一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">functionName`$&#123;name&#125;,您吃$&#123;lunch&#125;了吗？`</div></pre></td></tr></table></figure>
<p>其实就等同于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">functionName functionName(stringArr,...value)&#123;&#125;;</div></pre></td></tr></table></figure>
<p>stringArr就是模板里的不变的值：“,您吃了吗？”<br>而…value就是里面的变量：${name} 和 ${lunch}.</p>
<p>书上和其他的blog上面都说是可以用做字符串检查，类似于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function SaferHTML(templateData) &#123;</div><div class="line">  var s = templateData[0];</div><div class="line">  for (var i = 1; i &lt; arguments.length; i++) &#123;</div><div class="line">    var arg = String(arguments[i]);</div><div class="line">    // Escape special characters in the substitution.</div><div class="line">    s += arg.replace(/&amp;/g, &quot;&amp;amp;&quot;)</div><div class="line">            .replace(/&lt;/g, &quot;&amp;lt;&quot;)</div><div class="line">            .replace(/&gt;/g, &quot;&amp;gt;&quot;);</div><div class="line">    // Don&apos;t escape special characters in the template.</div><div class="line">    s += templateData[i];</div><div class="line">  &#125;</div><div class="line">  return s;</div><div class="line">&#125;</div><div class="line">// 调用</div><div class="line">var html = SaferHTML`&lt;p&gt;这是关于字符串模板的介绍&lt;/p&gt;`;</div></pre></td></tr></table></figure>
<p>能让你写的代码更优雅一些，算是字符串模板的拓展。</p>
<p>综上，实际使用的话，<code>Unicode</code>其实用的真的不多，但是字符串模板还是应该多关注下，能用尽量用，毕竟，使代码更优雅是每个程序员的最求。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6中，还是对字符串做了很多的改进，尤其是函数方面，增加了很多个方法。但是核心的变动，其实只有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Unicode&lt;/code&gt;拓展&lt;/li&gt;
&lt;li&gt;字符模板&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Unicode拓展&quot;&gt;&lt;a hr
    
    </summary>
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/tags/ES6/"/>
    
      <category term="JavaScript" scheme="https://github.com/njafei/njafei.github.io/tags/JavaScript/"/>
    
      <category term="react-native" scheme="https://github.com/njafei/njafei.github.io/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>react-native基类设计</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/05/20/react-native%E5%9F%BA%E7%B1%BB%E8%AE%BE%E8%AE%A1/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/05/20/react-native基类设计/</id>
    <published>2017-05-20T03:16:04.000Z</published>
    <updated>2017-10-19T03:37:16.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间发现iOS手机上，很多页面的字体样式会随着系统配置字体的大小而变换，使得界面不太美观。而这个其实只要给一个参数就可以解决，但是整个app中用该组件的地方非常多，开发挨个替换的话，工作量很大，而且很容易出现遗漏。</p>
<p>另外升级RN后，出现了<code>Android</code>手机上面的<code>Text</code>点击崩溃问题，底层的bug，前端需求的话，也是要花费相当精力而且容易遗漏。</p>
<p>那么，对于类似的问题，有没有好的解决方案呢？</p>
<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>如果抽象以下，我们其实是要解决两个痛点：</p>
<ul>
<li>风险控制问题</li>
<li>提高开发效率</li>
</ul>
<h4 id="风险控制问题"><a href="#风险控制问题" class="headerlink" title="风险控制问题"></a>风险控制问题</h4><p>这个是要解决<code>RN</code>框架界面突然爆发问题或者bug，我们应该是能及时、快速修复掉。目前其实<code>RN</code>还是可以热修复的，但是面对上面两个问题，其实没办法热修复，因为涉及到的点太多，工作量等太大。</p>
<p>所以，要解决风险控制问题，保证底层对于业务的组件是有控制力的，从而避免突然爆发问题而束手无策。</p>
<h4 id="提高开发效率"><a href="#提高开发效率" class="headerlink" title="提高开发效率"></a>提高开发效率</h4><p>这里还要介绍下在<code>Image</code>这个组件遇到的问题。一个是当前所有的图片都是没有默认的占位图的，另外就是如果图片下载失败，<code>Image</code>就会是空白，只有做特殊处理才能显示占位图。如果每个业务开发在使用<code>Image</code>的时候，都要加几行这种类似的重复代码，效率是非常低的。</p>
<p>或者临时遇到诸如整体换颜色、字体等问题，都是非常痛苦的。</p>
<p>所以提出想要能把开发从这种重复低价值劳动中解放出来。</p>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>基类的方案，有两个核心点：</p>
<ul>
<li>所有的页面都继承自基类</li>
<li>所有的组件都不再从<code>react-native</code>库中取，而是从基类中取</li>
</ul>
<p>如果一句话来概括的话，就是我们封装了一层<code>react-native</code>。业务开发使用的组件都是从我们自己库中取，而库中的控件，可以是定制的，也可以是简单从<code>react-native</code>中调用。</p>
<h1 id="包含控件"><a href="#包含控件" class="headerlink" title="包含控件"></a>包含控件</h1><p>这里是基类<code>Component</code>和其他几个开发过程中遇到的问题比较多的：</p>
<ul>
<li>Component</li>
<li>Text</li>
<li>Image</li>
</ul>
<p>具体的定制需求如下（还需要向开发搜集）：</p>
<h4 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h4><ul>
<li>默认字体等配置 </li>
<li>是否自动根据系统字体设定大小 false</li>
<li>解决number等的崩溃问题</li>
</ul>
<h4 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h4><ul>
<li>加载失败的处理</li>
<li>默认图片 （牛头图）</li>
<li>自动更换webp的操作</li>
</ul>
<h1 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h1><p>好处就是解决上文提的两个痛点：</p>
<ul>
<li>风险控制问题</li>
<li>提高开发效率</li>
</ul>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>基类如果出现bug，影响范围会比较大。</p>
<h1 id="待确定的问题"><a href="#待确定的问题" class="headerlink" title="待确定的问题"></a>待确定的问题</h1><ul>
<li>具体定制组件的需求还要搜集下</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h4 id="Base-Component"><a href="#Base-Component" class="headerlink" title="Base Component"></a>Base Component</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div></pre></td><td class="code"><pre><div class="line">import React from &apos;react&apos;;</div><div class="line"></div><div class="line">import &#123;</div><div class="line">    Button,</div><div class="line">    DatePickerIOS,</div><div class="line">    DrawerLayoutAndroid,</div><div class="line">    FlatList,</div><div class="line">    Image,</div><div class="line">    KeyboardAvoidingView,</div><div class="line">    ListView,</div><div class="line">    Modal,</div><div class="line">    Navigator,</div><div class="line">    NavigatorIOS,</div><div class="line">    Picker,</div><div class="line">    PickerIOS,</div><div class="line">    ProgressBarAndroid,</div><div class="line">    ProgressViewIOS,</div><div class="line">    RefreshControl,</div><div class="line">    ScrollView,</div><div class="line">    SectionList,</div><div class="line">    SegmentedControlIOS,</div><div class="line">    Slider,</div><div class="line">    StatusBar,</div><div class="line">    Switch,</div><div class="line">    TabBarIOS,</div><div class="line">    TextInput,</div><div class="line">    ToolbarAndroid,</div><div class="line">    TouchableHighlight,</div><div class="line">    TouchableNativeFeedback,</div><div class="line">    TouchableWithoutFeedback,</div><div class="line">    View,</div><div class="line">    ViewPagerAndroid,</div><div class="line">    VirtualizedList,</div><div class="line">    WebView,</div><div class="line">    StyleSheet,</div><div class="line">    Platform,</div><div class="line">    AsyncStorage,</div><div class="line">    TouchableOpacity,</div><div class="line">    DeviceEventEmitter,</div><div class="line">    ActivityIndicator,</div><div class="line">    NativeModules,</div><div class="line">    findNodeHandle,</div><div class="line">    ActionSheetIOS,</div><div class="line">    AdSupportIOS,</div><div class="line">    Alert,</div><div class="line">    AlertIOS,</div><div class="line">    Animated,</div><div class="line">    AppRegistry,</div><div class="line">    AppState,</div><div class="line">    BackAndroid,</div><div class="line">    CameraRoll,</div><div class="line">    Clipboard,</div><div class="line">    DatePickerAndroid,</div><div class="line">    Dimensions,</div><div class="line">    Easing,</div><div class="line">    Geolocation,</div><div class="line">    ImageEditor,</div><div class="line">    ImagePickerIOS,</div><div class="line">    ImageStore,</div><div class="line">    InteractionManager,</div><div class="line">    Keyboard,</div><div class="line">    LayoutAnimation,</div><div class="line">    Linking,</div><div class="line">    NativeMethodsMixin,</div><div class="line">    NetInfo,</div><div class="line">    PanResponder,</div><div class="line">    PermissionsAndroid,</div><div class="line">    PixelRatio,</div><div class="line">    PushNotificationIOS,</div><div class="line">    Share,</div><div class="line">    Systrace,</div><div class="line">    TimePickerAndroid,</div><div class="line">    ToastAndroid,</div><div class="line">    Vibration,</div><div class="line">&#125; from &apos;react-native&apos;;</div><div class="line"></div><div class="line">import Text from &apos;./BaseText.js&apos;</div><div class="line"></div><div class="line">class BaseComponent extends React.Component &#123;</div><div class="line"></div><div class="line">    render()&#123;</div><div class="line">        return (</div><div class="line">            &lt;View&gt;</div><div class="line"></div><div class="line">            &lt;/View&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default  BaseComponent;</div><div class="line"></div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">    //自定义的组件</div><div class="line">    BaseComponent,</div><div class="line">    Text,</div><div class="line">    //使用系统的组件</div><div class="line">    Button,</div><div class="line">    DatePickerIOS,</div><div class="line">    DrawerLayoutAndroid,</div><div class="line">    FlatList,</div><div class="line">    Image,</div><div class="line">    KeyboardAvoidingView,</div><div class="line">    ListView,</div><div class="line">    Modal,</div><div class="line">    Navigator,</div><div class="line">    NavigatorIOS,</div><div class="line">    Picker,</div><div class="line">    PickerIOS,</div><div class="line">    ProgressBarAndroid,</div><div class="line">    ProgressViewIOS,</div><div class="line">    RefreshControl,</div><div class="line">    ScrollView,</div><div class="line">    SectionList,</div><div class="line">    SegmentedControlIOS,</div><div class="line">    Slider,</div><div class="line">    StatusBar,</div><div class="line">    Switch,</div><div class="line">    TabBarIOS,</div><div class="line">    TextInput,</div><div class="line">    ToolbarAndroid,</div><div class="line">    TouchableHighlight,</div><div class="line">    TouchableNativeFeedback,</div><div class="line">    TouchableWithoutFeedback,</div><div class="line">    View,</div><div class="line">    ViewPagerAndroid,</div><div class="line">    VirtualizedList,</div><div class="line">    WebView,</div><div class="line">    Platform,</div><div class="line">    AsyncStorage,</div><div class="line">    TouchableOpacity,</div><div class="line">    DeviceEventEmitter,</div><div class="line">    ActivityIndicator,</div><div class="line">    NativeModules,</div><div class="line">    findNodeHandle,</div><div class="line">    ActionSheetIOS,</div><div class="line">    AdSupportIOS,</div><div class="line">    Alert,</div><div class="line">    AlertIOS,</div><div class="line">    Animated,</div><div class="line">    AppRegistry,</div><div class="line">    AppState,</div><div class="line">    BackAndroid,</div><div class="line">    CameraRoll,</div><div class="line">    Clipboard,</div><div class="line">    DatePickerAndroid,</div><div class="line">    Dimensions,</div><div class="line">    Easing,</div><div class="line">    Geolocation,</div><div class="line">    ImageEditor,</div><div class="line">    ImagePickerIOS,</div><div class="line">    ImageStore,</div><div class="line">    InteractionManager,</div><div class="line">    Keyboard,</div><div class="line">    LayoutAnimation,</div><div class="line">    Linking,</div><div class="line">    NativeMethodsMixin,</div><div class="line">    NetInfo,</div><div class="line">    PanResponder,</div><div class="line">    PermissionsAndroid,</div><div class="line">    PixelRatio,</div><div class="line">    PushNotificationIOS,</div><div class="line">    Share,</div><div class="line">    StyleSheet,</div><div class="line">    Systrace,</div><div class="line">    TimePickerAndroid,</div><div class="line">    ToastAndroid,</div><div class="line">    Vibration,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="定制Text："><a href="#定制Text：" class="headerlink" title="定制Text："></a>定制Text：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">import React from &apos;react&apos;;</div><div class="line">import &#123;</div><div class="line">    Text,</div><div class="line">    StyleSheet,</div><div class="line">&#125; from &apos;react-native&apos;;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">class BaseText extends React.Component&#123;</div><div class="line">    constructor(props)&#123;</div><div class="line">        super(props);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render()&#123;</div><div class="line"></div><div class="line">    let &#123;style,...others&#125; =this.props;</div><div class="line"></div><div class="line">    return (</div><div class="line">            &lt;Text &#123;...others&#125;</div><div class="line">                  allowFontScaling=&#123;false&#125;</div><div class="line">                  style=&#123;[styles.defaltStyle,style]&#125;</div><div class="line">            /&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line">    fontSize: 12,</div><div class="line">&#125;)</div><div class="line"></div><div class="line">export default  BaseText;</div></pre></td></tr></table></figure>
<h4 id="子类使用"><a href="#子类使用" class="headerlink" title="子类使用:"></a>子类使用:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import &#123;</div><div class="line">    Text,</div><div class="line">    BaseComponent,</div><div class="line">&#125; from &apos;../../../../../common/BaseComponent&apos;</div><div class="line"></div><div class="line">render() &#123;</div><div class="line"></div><div class="line">        return (</div><div class="line">            &lt;Text&gt;这是Text的内容&lt;/Text&gt;</div><div class="line">        )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h1><h4 id="第一期"><a href="#第一期" class="headerlink" title="第一期"></a>第一期</h4><p>首先可以先把紧迫的诸如<code>Text</code>、<code>Image</code>等待解决的bug和样式等做好，基类写好，替换诸如某个模块，如果上线之后没有问题，可以替换所有的RN页面。</p>
<h4 id="第二期"><a href="#第二期" class="headerlink" title="第二期"></a>第二期</h4><ul>
<li>将默认样式和诸如快捷写法等集成到基类中，提高大家书写RN代码的效率，也方便以后更换等。</li>
<li>考虑一些AOP的使用，比如打点，统计等。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前段时间发现iOS手机上，很多页面的字体样式会随着系统配置字体的大小而变换，使得界面不太美观。而这个其实只要给一个参数就可以解决，但是整个a
    
    </summary>
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/categories/React-Native/"/>
    
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>Android上的RN不能展示尺寸大的图，怎么办？</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/05/18/android-RN-bigImage/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/05/18/android-RN-bigImage/</id>
    <published>2017-05-18T09:44:01.000Z</published>
    <updated>2017-10-19T03:37:16.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近遇到一个营销的需求，一个简单的界面，上面是一个计数器，下面是一张介绍图。所以下面直接用了<code>Image</code>标签来做。但是在测试中发现了一个问题，部分的<code>Android</code>手机上面展示不出来图片。使用<code>Android studio</code>检查了下log，发现了如下的错误：</p>
<blockquote>
<p>OpenGLRenderer: Bitmap too large to be uploaded into a texture (750x4520, max=4096x4096</p>
</blockquote>
<p>这个因为图片的尺寸过大（注意，不是大小哦），导致<code>Android</code>手机不能渲染，那么怎么解决这个问题呢？</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>这里推荐使用<code>webView</code>，RN提供的<code>webView</code>功能还算强大，可以把它作为一个容易来装图片，最重要的是，大部分的<code>Android</code>手机对<code>webView</code>的优化还是非常不错的。而且<code>webView</code>还支持多种格式，你甚至可以把<code>html</code>代码写入一个字符串中传给<code>webView</code>。具体请参考wiki:<a href="http://reactnative.cn/docs/0.43/webview.html#content" target="_blank" rel="noopener">http://reactnative.cn/docs/0.43/webview.html#content</a></p>
<p>实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">let leftNum = this.getLeftNumberText();</div><div class="line">        const HTML = `</div><div class="line">            &lt;!DOCTYPE html&gt;\n</div><div class="line">            &lt;html&gt;</div><div class="line">              &lt;head&gt;</div><div class="line">                &lt;title&gt;Hello Static World&lt;/title&gt;</div><div class="line">                &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</div><div class="line">                &lt;meta name=&quot;viewport&quot; content=&quot;width=320, user-scalable=no&quot;&gt;</div><div class="line">                &lt;style type=&quot;text/css&quot;&gt;</div><div class="line">                    body&#123;</div><div class="line">                        margin:0;</div><div class="line">                        padding:0;</div><div class="line">                        </div><div class="line">                    &#125;</div><div class="line">                    img&#123;</div><div class="line">                        width:100%;</div><div class="line">                    &#125;</div><div class="line">                &lt;/style&gt;</div><div class="line">              &lt;/head&gt;</div><div class="line">              &lt;body&gt;</div><div class="line">                &lt;img src=&quot;https://m.tuniucdn.com/fb2/t1/G1/M00/F1/51/Cii9EFkAaZ-IRgGNAATB18ldk0UAAJzuQN-p1cABMHv15.jpeg&quot;/&gt;</div><div class="line">              &lt;/body&gt;</div><div class="line">            &lt;/html&gt;</div><div class="line">            `;</div><div class="line"></div><div class="line">        let image =  (</div><div class="line">            &lt;Image style=&#123;styles.image&#125;</div><div class="line">                   source=&#123;&#123;uri: &apos;https://m.tuniucdn.com/fb2/t1/G1/M00/F1/51/Cii9EFkAaZ-IRgGNAATB18ldk0UAAJzuQN-p1cABMHv15.jpeg&apos;&#125;&#125;/&gt;);</div><div class="line"></div><div class="line">        let webView = (</div><div class="line">            &lt;WebView</div><div class="line">                style=&#123;styles.image&#125;</div><div class="line">                automaticallyAdjustContentInsets=&#123;false&#125;</div><div class="line">                source=&#123;&#123;html:HTML&#125;&#125;</div><div class="line">                javaScriptEnabled=&#123;true&#125;</div><div class="line">                domStorageEnabled=&#123;true&#125;</div><div class="line">                decelerationRate=&quot;normal&quot;</div><div class="line">                startInLoadingState=&#123;true&#125;</div><div class="line">                scalesPageToFit=&#123;false&#125;</div><div class="line">                onLoadEnd = &#123;()=&gt;&#123;console.log(&apos;loading end&apos;)&#125;&#125;</div><div class="line">                onError = &#123;()=&gt;&#123;console.log(&apos;loading error&apos;)&#125;&#125;</div><div class="line">            /&gt;</div><div class="line">            )</div><div class="line"></div><div class="line">        let ImageShow = Platform.OS===&apos;android&apos; ? webView: image;</div><div class="line">        return (</div><div class="line">            &lt;View style=&#123;styles.bgView&#125;&gt;</div><div class="line">                &lt;Header title = &apos;牛大头&apos;&gt;&lt;/Header&gt;</div><div class="line">                &lt;ScrollView style=&#123;styles.scrollView&#125;&gt;</div><div class="line">                    &lt;View style=&#123;styles.tipBgView&#125;&gt;</div><div class="line">                        &lt;Image source = &#123;require(&apos;./images/icon-ask-home-tip.png&apos;)&#125;</div><div class="line">                        style=&#123;styles.tipIcon&#125;/&gt;</div><div class="line">                        &lt;Text style=&#123;styles.tipText&#125;&gt;&#123;leftNum&#125;&lt;/Text&gt;</div><div class="line">                    &lt;/View&gt;</div><div class="line">                    &#123;ImageShow&#125;</div><div class="line">                &lt;/ScrollView&gt;</div><div class="line">            &lt;/View&gt;</div><div class="line">        )</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实我觉得， 如果是营销界面，最好是公司提供一整套可以配置的H5界面，这样可以直接使用后台的<code>CMS</code>后台去配置出来一个界面，节省人力，效率高。</p>
<p>如果一定要<code>Native</code>或者<code>RN</code>来做的话，像我们这次<code>H5</code>前端人力比较紧张，那就可以<code>Native</code>的开发上。直接写H5界面放到<code>webView</code>中，还是比较方便的。当然如果是比较复杂的，还是要<code>Native</code>实现的，这里仅提供一种思路。</p>
<p>前端大融合，指日可待啊。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近遇到一个营销的需求，一个简单的界面，上面是一个计数器，下面是一张介绍图。所以下面直接用了&lt;code&gt;Image&lt;/code&gt;标签来做。但
    
    </summary>
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/categories/React-Native/"/>
    
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/tags/React-Native/"/>
    
      <category term="Android" scheme="https://github.com/njafei/njafei.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>fastlane上传appStore功能调研</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/05/17/fastlane%E4%B8%8A%E4%BC%A0APPStore%E8%B0%83%E7%A0%94/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/05/17/fastlane上传APPStore调研/</id>
    <published>2017-05-17T09:10:34.000Z</published>
    <updated>2017-10-19T03:37:16.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>目前jenkins服务器上面使用的版本比较老，是1.* 的版本。这个版本的deliver，自定义的功能比较少，存在以下弊端：</p>
<pre><code>如APP正在审核版本9，这时候上传一个版本,deliver会自动取消当前版本的审核状态。而这种自动的提交和取消审核状态是团队无法接受的。
所以今天调研了最新的版本
</code></pre><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p>查看了deliver的<a href="https://github.com/fastlane/fastlane/tree/master/deliver">最新文档</a>，最新的提供了新的参数<code>submit_for_review</code>，目前配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">app_identifier &quot;com.**.**&quot; # The bundle identifier of your app	</div><div class="line">username &quot;njafei@163.com&quot; # your Apple ID user</div><div class="line">force true #don’t show me the preview html</div><div class="line">submit_for_review false # 这个开关就是控制是否要展示的</div></pre></td></tr></table></figure>
<h1 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ fastlane deliver init //初始化fastlane 会生成配置文件Deliverfile、文档数据（用于各种说明等）文件夹metadata、screenshots（展图）等文件</div><div class="line">$ 输入itunes connenct账号等</div><div class="line">$ 配置Deliverfile文件，配置同文档中所列</div><div class="line">$ fastlane deliver *.ipa</div></pre></td></tr></table></figure>
<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><p>直接使用公司网络上传3次，均失败<br>使用lantern上传了8次，成功了一次,上传时间大约20min</p>
<p>线上无app在review中：正常上传，无影响<br>线上有app在review中：正常上传，无影响</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>使用deliver的话，一定要配置一个版本更新说明，地址在<code>./metadata/zh-Hans/release_notes.txt</code>;</p>
<p>#总结<br>fastlane的上传功能现在已经可以满足使用条件，但是网络状态实在比较差，可以考虑写脚本由上传人员使用，配合jenkins的话，恐怕失败率比较高</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;目前jenkins服务器上面使用的版本比较老，是1.* 的版本。这个版本的deliver，自定义的功能比较少，存在以下弊端：&lt;/p&gt;
&lt;pr
    
    </summary>
    
      <category term="自动化" scheme="https://github.com/njafei/njafei.github.io/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    
      <category term="自动化" scheme="https://github.com/njafei/njafei.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="fastlane" scheme="https://github.com/njafei/njafei.github.io/tags/fastlane/"/>
    
  </entry>
  
  <entry>
    <title>ES6之变量的解构赋值</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/05/11/ES6%E4%B9%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/05/11/ES6之变量的解构赋值/</id>
    <published>2017-05-11T05:22:57.000Z</published>
    <updated>2017-10-19T03:37:16.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是解构赋值"><a href="#什么是解构赋值" class="headerlink" title="什么是解构赋值"></a>什么是解构赋值</h1><p>以前，如果我们想给一个变量赋值，通常是这样（在Objective-C等语言中，现在仍然是如此）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let a = 1;</div><div class="line">let b = 2;</div><div class="line">let c = 3;</div></pre></td></tr></table></figure>
<p>而<code>ES6</code>现在支持了类似这样的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let [a,b,c] = [1,2,3];</div></pre></td></tr></table></figure>
<p>从而大大简化了变量赋值的语法，而且为诸如：Json解析、函数默认值用法提供了支持，文章最后会介绍。</p>
<p>JS的变量解构赋值，实际上的一种模式匹配，比如：{模式1} = {模式2}，如果模式1能够部分或者完全匹配模式2，则匹配成功的模式1的部分变量就会被赋值为匹配到的值，否则赋值为undefined。这是解构赋值的核心思想，后面的各种类型的解构赋值其实都是这种思想的具体体现。</p>
<p>另外解构赋值，要求赋值对象，即等号右边的值，一定是一个可以遍历的结构，即符合<code>Iterator</code>接口。</p>
<p>接下来会依次介绍以下几种用法：</p>
<ul>
<li>数组的解构赋值</li>
<li>对象的解构赋值</li>
<li>字符串的解构赋值</li>
<li>数值、布尔值的解构赋值</li>
<li>函数参数的解构赋值</li>
<li>圆括号问题</li>
</ul>
<p>在开始前，还有个关于<code>null</code>和<code>undefined</code>的小知识介绍下，js 中，null === undefined 是false。两者的区别在于：</p>
<ul>
<li>null表示”没有对象”，即该处不应该有值。</li>
<li>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义</li>
</ul>
<p>具体的可以看下阮一峰的文章：<a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="noopener">undefined与null的区别</a>。下面的文章会用到这点。</p>
<h1 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h1><p>数组的结构赋值比较简单，我们下面通过一些不同的例子来看下：</p>
<h4 id="正常结构"><a href="#正常结构" class="headerlink" title="正常结构"></a>正常结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let [a,b,c] = [1,2,3];</div><div class="line">a // 1</div><div class="line">b // 2</div><div class="line">c // 3</div></pre></td></tr></table></figure>
<h4 id="嵌套结构"><a href="#嵌套结构" class="headerlink" title="嵌套结构"></a>嵌套结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let [a,[b,c],d] = [1,[2,3],4];</div><div class="line">a // 1</div><div class="line">b // 2</div><div class="line">c // 3</div><div class="line">d // 4</div></pre></td></tr></table></figure>
<h4 id="…语句"><a href="#…语句" class="headerlink" title="…语句"></a>…语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let [a, ...b] = [1,2,3];</div><div class="line">a // 1</div><div class="line">b // [2,3]</div></pre></td></tr></table></figure>
<h4 id="缺省变量"><a href="#缺省变量" class="headerlink" title="缺省变量"></a>缺省变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let [a, ,c] = [1,2,3];</div><div class="line">a // 1</div><div class="line">c // 3</div></pre></td></tr></table></figure>
<h4 id="解构不完全成功"><a href="#解构不完全成功" class="headerlink" title="解构不完全成功"></a>解构不完全成功</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let [a,b,c] = [1,];</div><div class="line">a // 1</div><div class="line">b // undefined</div><div class="line">c // undefined</div></pre></td></tr></table></figure>
<p>另外还有两个注意点：</p>
<p>如果右侧不是一个可遍历的结构，则会报错，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let [foo] = 1;//error</div></pre></td></tr></table></figure>
<p>使用let，const，不可以重复定义变量，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let a ;</div><div class="line">let [a,b] = [1,2];//error: Duplicate declaration</div></pre></td></tr></table></figure>
<h1 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h1><p>解构赋值是允许给变量默认值的，如果解构失败(模式匹配不上，或者赋值为<code>undefined</code>)，则会使用默认值。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let [a = 1, b = 2] = [1,];</div><div class="line">a // 1</div><div class="line">b // 2</div></pre></td></tr></table></figure>
<p>在前面章节，讲了<code>null</code>和<code>undefined</code>，如果赋值<code>null</code>，系统是不会使用默认值的，因为<code>null</code>和<code>undefined</code>是不严格相等的。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let [a = 1,b] = [1,null];</div><div class="line">a // 1,</div><div class="line">b // null,</div></pre></td></tr></table></figure>
<p>另外默认值可以引用解构赋值的其他变量，前提是这个变量已经声明了，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let [x = 1, y = x] = []; // x=1, y=1</div><div class="line">let [x = 1, y = x] = [2];// x=2, y=2</div><div class="line">let [x = y, y = x] = []; // error y undefined</div></pre></td></tr></table></figure>
<h1 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h1><p>对象和数组的重要区别就是，前者是顺序的，后者是非顺序的，所以对象的解构赋值，更加能体现模式匹配的意义。</p>
<h4 id="如何理解"><a href="#如何理解" class="headerlink" title="如何理解"></a>如何理解</h4><p>我们先讲回数组的解构赋值，其实可以这样理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let [a, [b, c], d] = [1, [2,3], 4];</div></pre></td></tr></table></figure>
<p>a可以理解为模式1，[b,c]可以理解为模式2， d可以理解为模式3<br>函数可以这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let [模式1，模式2，模式3] = [匹配模式1,匹配模式2,匹配模式3];</div></pre></td></tr></table></figure>
<p>在数组中，模式的匹配是根据<code>，</code>的因为数组是有序的，而在对象中，模式匹配则是根据模式的key。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let &#123;foo, bar&#125; = &#123;foo: &apos;fooValue&apos;, bar: &apos;barValue&apos;&#125;;</div><div class="line">foo // &apos;fooValue&apos;</div><div class="line">bar // &apos;barValue&apos;</div></pre></td></tr></table></figure>
<p>我们根据模式匹配的思想，其实等号左边就是{模式1，模式2},等号右边就是{模式1：模式1值，{模式2：模式2值}}，所以上述代码的完整版是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let &#123;foo模式: foo模式实例foo, bar模式: bar模式实例bar&#125; = &#123;foo模式: foo模式实例&apos;fooValue&apos;, bar: bar模式实例&apos;barValue&apos;&#125;;</div></pre></td></tr></table></figure>
<p>这里我们一定要区分的就是模式名和模式实例，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let &#123;foo:[1,bar]&#125; = &#123;[1,2]&#125;;</div><div class="line">bar // 2</div><div class="line">foo // undefined</div></pre></td></tr></table></figure>
<p>这里的foo是模式名，并不是变量，所以不会被赋值.</p>
<h4 id="嵌套对象的注意点"><a href="#嵌套对象的注意点" class="headerlink" title="嵌套对象的注意点"></a>嵌套对象的注意点</h4><p>有嵌套对象的时候，需要注意，如果子对象的父属性不存在，会报错，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let &#123;foo: &#123;bar&#125; = &#123;bar: &apos;bar&apos;&#125;&#125;;//TypeError: Cannot read property &apos;bar&apos; of undefined</div></pre></td></tr></table></figure>
<p>这中间的流程是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let _tmp = &#123;bar: &apos;bar&apos;&#125;;</div><div class="line">_tmp.foo.bar;//error</div></pre></td></tr></table></figure>
<h5 id="已声明的变量赋值注意点"><a href="#已声明的变量赋值注意点" class="headerlink" title="已声明的变量赋值注意点"></a>已声明的变量赋值注意点</h5><p>大括号的情况要注意，会被系统理解为代码块，发生错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let x ;</div><div class="line">&#123;x&#125; = &#123;x: 1&#125;;</div></pre></td></tr></table></figure>
<p>在外面加上圆括号可以解决:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let x ;</div><div class="line">(&#123;x&#125; = &#123;x: 1&#125;);</div></pre></td></tr></table></figure>
<h1 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h1><p>字符串在被解构赋值的时候，会被转换成类似数组的对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let [a,b,c,d] = &apos;hello&apos;;</div><div class="line">a // &apos;h&apos;</div><div class="line">b // &apos;e&apos;</div><div class="line">c // &apos;l&apos;</div><div class="line">d // &apos;l&apos;</div></pre></td></tr></table></figure>
<h5 id="属性解构"><a href="#属性解构" class="headerlink" title="属性解构"></a>属性解构</h5><p>这里要介绍个好玩的东西，解构不止能解构值，还能解构属性，因为这里用的都是<code>.</code>语法,比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let &#123;length: len&#125; = &apos;hello&apos;</div><div class="line">这里最终执行的是：</div><div class="line">let _tmp = [&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;];</div><div class="line">len = _tmp.length;//这里本来是要报错的，但是_tmp恰好有length属性，所以len 是 5</div></pre></td></tr></table></figure>
<h1 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h1><p>在数值和布尔值的情况下，等号右边会先转换成对象。</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let &#123;foo&#125; = 123;</div><div class="line">实际执行是：</div><div class="line">let foo = 123.foo;</div></pre></td></tr></table></figure>
<p>这里还是可以用属性解构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let &#123;toString: s&#125; = 123;</div><div class="line">s // function toString() &#123; [native code] &#125;</div></pre></td></tr></table></figure>
<p>这里的数值和布尔值的结构赋值，我目前不太了解具体的实际用法，如果读者知道，麻烦告诉我哈。</p>
<h1 id="函数参数的结构赋值"><a href="#函数参数的结构赋值" class="headerlink" title="函数参数的结构赋值"></a>函数参数的结构赋值</h1><p>这里和对象的解构赋值一模一样，不具体介绍</p>
<h1 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h1><p>学过编译原理的人都知道，编译原理到底有多变态，所以编译器的感受应该和我们一样（笑）。在遇到（）的时候，编译器也会出现问题，所以这里有个原则：</p>
<blockquote>
<p>能不适用圆括号，就不要使用</p>
</blockquote>
<p>除非，满足两个条件</p>
<ul>
<li>不是定义变量，而是赋值</li>
<li>不在模式部分适用</li>
</ul>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123;p:(a)&#125; = &#123;p : &apos;a&apos;&#125;;</div><div class="line">a // &apos;a&apos;</div></pre></td></tr></table></figure>
<p>其他的都会报错</p>
<h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><h4 id="解析多个值"><a href="#解析多个值" class="headerlink" title="解析多个值"></a>解析多个值</h4><p>在使用函数的时候，经常会返回多个值（js中常见，其他的还真的不常见），用解构赋值的话，语法就会非常简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let &#123;a,b,c&#125; = foo();</div></pre></td></tr></table></figure>
<h4 id="函数的参数和默认值"><a href="#函数的参数和默认值" class="headerlink" title="函数的参数和默认值"></a>函数的参数和默认值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">function foo (&#123;a = 1,b = 2,c = 3&#125;)&#123;&#125;;//</div></pre></td></tr></table></figure>
<p>这里可以节省判断入参的代码</p>
<h4 id="和map结合"><a href="#和map结合" class="headerlink" title="和map结合"></a>和map结合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let map = new Map();</div><div class="line">map.set(&quot;key1&quot;,&quot;value1&quot;);</div><div class="line">map.set(&quot;key2&quot;,&quot;value2&quot;);</div><div class="line"></div><div class="line"></div><div class="line">for (let [a, b] of map) &#123;</div><div class="line">	console.log(&apos;key is &apos; + a, &apos;value is &apos;+ b);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="载入模块使用"><a href="#载入模块使用" class="headerlink" title="载入模块使用"></a>载入模块使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import &#123;foo1,foo2&#125; from &apos;react-native&apos;;</div></pre></td></tr></table></figure>
<p>这里的用法其实大都差不多，主要是用来简化代码，提高可读性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是解构赋值&quot;&gt;&lt;a href=&quot;#什么是解构赋值&quot; class=&quot;headerlink&quot; title=&quot;什么是解构赋值&quot;&gt;&lt;/a&gt;什么是解构赋值&lt;/h1&gt;&lt;p&gt;以前，如果我们想给一个变量赋值，通常是这样（在Objective-C等语言中，现在仍然是如此）：&lt;/
    
    </summary>
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/categories/React-Native/"/>
    
    
      <category term="ES6" scheme="https://github.com/njafei/njafei.github.io/tags/ES6/"/>
    
      <category term="React-Native" scheme="https://github.com/njafei/njafei.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>图片的展示清晰度问题研究</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/05/05/%E5%9B%BE%E7%89%87%E6%B8%85%E6%99%B0%E5%BA%A6%E6%8E%A2%E7%A9%B6/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/05/05/图片清晰度探究/</id>
    <published>2017-05-05T07:38:08.000Z</published>
    <updated>2017-10-19T03:37:16.734Z</updated>
    
    <content type="html"><![CDATA[<p>前两天产品经理找我，说是首页的轮播图，看起来很模糊，我看了下，确实是效果不好，很多的字看起来不都清晰，看明白是什么很费劲。</p>
<p>看起来效果像是这样（忽然想起一个老朋友，北大高材生，居然喜欢杨幂，这里就用大幂幂吧）</p>
<p><img src="http://on0hv7n2x.bkt.clouddn.com/%E5%9B%BE%E7%89%87%E6%95%88%E6%9E%9C%E5%AF%B9%E6%AF%94%E5%9B%BE%20%20%E6%95%88%E6%9E%9C%E5%B7%AE.png" alt=""></p>
<p>我当时的第一反应就是是不是原图就不清晰。然后我抓包，拿到了图片链接，但是链接的图片在浏览器中看起来效果很不错，像这样：</p>
<p><img src="http://on0hv7n2x.bkt.clouddn.com/%E5%9B%BE%E7%89%87%E6%95%88%E6%9E%9C%E5%AF%B9%E6%AF%94%E5%9B%BE%20%20%E5%8E%9F%E5%9B%BE.jpg" alt=""></p>
<p>但是展示在手机上的效果，真的差强人意，尤其是有文字的时候，文字的边缘锐化的效果很明显。</p>
<p>百思不得其解的时候，发现原图的链接给的尺寸，比手机行的设定尺寸大了好多。做iOS App开发的都知道，因为手机是retina屏，所以要求给的图都是2x和3x的，比如 100 <em> 100的图，我们通常要设计师给的是 200 </em> 200的，6p等是 300 <em> 300.但是这张图，我们需要的是200 </em> 100的，通常给 600 <em> 300肯定够了，但是服务端给的是 1200 </em> 600的，比我们需要的长宽大了两倍。然后我自己用这张图，转换了一张 600 * 300的图，debug发现效果非常好。和服务端沟通了下，给出的原因是：因为公司的图片尺寸是有限的，所以当时找了一个最接近长宽比的给前端。</p>
<p>又找了UI的大神聊了，上述的原因是这样的：</p>
<p>如果一个 9 <em> 9的图，想要在 1 </em> 1的图片中显示，怎会随机从9个像素中选取一个放到1 * 1 中，所以就失真了，类似这样：</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>n</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>1 &lt;= n &lt;= 9</p>
<p>所以呢，想要图片在app上展示出最好的效果，其实不在于图片要切的非常大，而是图片的尺寸再好和你设计的差不多，否则会失真。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天产品经理找我，说是首页的轮播图，看起来很模糊，我看了下，确实是效果不好，很多的字看起来不都清晰，看明白是什么很费劲。&lt;/p&gt;
&lt;p&gt;看起来效果像是这样（忽然想起一个老朋友，北大高材生，居然喜欢杨幂，这里就用大幂幂吧）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o
    
    </summary>
    
      <category term="闲来研究" scheme="https://github.com/njafei/njafei.github.io/categories/%E9%97%B2%E6%9D%A5%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="图片" scheme="https://github.com/njafei/njafei.github.io/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>iOS Runtime 详解</title>
    <link href="https://github.com/njafei/njafei.github.io/2017/05/04/runtime/"/>
    <id>https://github.com/njafei/njafei.github.io/2017/05/04/runtime/</id>
    <published>2017-05-04T07:45:12.000Z</published>
    <updated>2017-10-19T03:37:16.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是runtime"><a href="#什么是runtime" class="headerlink" title="什么是runtime"></a>什么是runtime</h1><p>依照苹果文档的说法，<code>runtime</code>是：</p>
<blockquote>
<p> The Objective-C language defers as many decisions as it can from compile time and link time to runtime.<br>（尽量将决定放到运行的时候，而不是在编译和链接过程）</p>
</blockquote>
<p>如何理解这段话呢，我们首先要知道，一段代码从写完到最终执行的过程中发生了什么。</p>
<h4 id="从代码到可执行文件的过程"><a href="#从代码到可执行文件的过程" class="headerlink" title="从代码到可执行文件的过程"></a>从代码到可执行文件的过程</h4><p>这是《深入理解计算机系统(第2版)》里面的一张截图：</p>
<p><img src="http://on0hv7n2x.bkt.clouddn.com/compileToLinkToRun.png" alt=""></p>
<p>主要过程我们可以简化成三个：</p>
<pre><code>- 编译
- 链接
- 运行
</code></pre><p>编译：将代码转换成底层可执行的语言（如汇编），简单来讲，就是把你能看懂的语言，转换成系统底层可以看懂的东西，这中间通常会有优化，先预处理，再编译。</p>
<p>链接：在编译的过程中，如果有调用其他的类的方法等，是不会检查或者报警的，编译的时候会默认你已经实现了。而链接就是去检查调用的方法或者类等是否确实存在。</p>
<p>运行：执行最终的可执行文件</p>
<p>如果是普通的C语言代码，我们使用的是传统的编译运行，那么一个函数的执行内容，在编译阶段其实就确定了，执行的时候只要去执行对应的内存地址的程序就好。</p>
<p>而在<code>runtime</code>中，编译阶段只能确定最终要执行的函数名，但是具体执行的时候，执行的是什么程序，是在运行的时候才能确定，大大增加了程序的灵活性。</p>
<h1 id="Objective-C-runtime介绍"><a href="#Objective-C-runtime介绍" class="headerlink" title="Objective-C runtime介绍"></a>Objective-C runtime介绍</h1><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Objective-C是一门运行时语言，这意味着代码执行可以更加灵活：我们动态的创建一个新的类，还可以转发消息给其他的消息。（消息转发是runtime的一个重要组成部分，后面会介绍）。</p>
<p>这种特性要求Objective-C语言会尽可能把决定从编译和链接的阶段延迟到运行时<code>(runtime)</code>阶段，因此Objective-C不仅有一个编译器，还有一个<code>runtime</code>系统来执行被编译过的代码。</p>
<h4 id="版本和平台"><a href="#版本和平台" class="headerlink" title="版本和平台"></a>版本和平台</h4><p>runtime是有个两个版本的: legacy 、 modern<br>在Objective-C 1.0使用的是legacy，在2.0使用的是modern。这里简单介绍下区别：</p>
<ul>
<li>在legacy runtime，如果你改变了实例变量的设计，需要重新编译它的子类。支持 32bit的OS X 程序</li>
<li>在modern runtime，如果你改变了实例变量的设计，不需要重新编译它的子类。支持iphone程序和OS X10.5之后的64bit程序</li>
</ul>
<p>因为legacy是如此的古老，我们基本可以忽略legacy版本。</p>
<h1 id="Runtime交互"><a href="#Runtime交互" class="headerlink" title="Runtime交互"></a>Runtime交互</h1><p>有三种方式可以使用Runtime：</p>
<ul>
<li>Objective-C 源代码</li>
<li>NSObject 方法</li>
<li>Runtime 方法</li>
</ul>
<h4 id="Objective-C-源代码"><a href="#Objective-C-源代码" class="headerlink" title="Objective-C 源代码"></a>Objective-C 源代码</h4><p>一般来说，runtime都是默默地在后台运行工作，我们只是写Objective-C源代码，就使用了runtime。当我们编译包含Objective-C的类和方法时，编译器就会生成包含runtime特性的数据结构和方法。数据结构中包含了从类、category、协议中定义的的信息，如：selector、变量等等。主要的runtime方法是发送信息的方法<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html#//apple_ref/doc/uid/TP40008048-CH104-SW1" target="_blank" rel="noopener">Message</a>,在下一章节会讲到。</p>
<h4 id="NSObject方法"><a href="#NSObject方法" class="headerlink" title="NSObject方法"></a>NSObject方法</h4><p>Cocoa中大部分的类都是继承自<code>NSObejct</code>，所以他们都会集成了<code>NSObject</code>定义的方法。（值得注意的例外是<code>NSProxy</code>类）因此<code>NSObject</code>的方法就决定了其他类的行为。（当然，在少数情况下，这样说并不正确，在这些情况下，<code>NSObject</code>会仅仅定义了方法，没有实现必须的代码。比如<code>description</code>，如果子类没有重写，那么会返回类名和地址，这是因为<code>NSObject</code>没法获得更多的信息。）</p>
<p>一些<code>NSObject</code>类的方法可以直接查询<code>runtime</code>系统的信息，从而获得自身的信息。比如<code>class</code>，<code>isKindeOfClass</code>，<code>respondsToSelector</code>等方法。</p>
<h4 id="Runtime方法"><a href="#Runtime方法" class="headerlink" title="Runtime方法"></a>Runtime方法</h4><p>Runtime系统是一个共享的library，包含了许多方法和数据结构，地址在<code>/usr/include/objc</code>。其中的很多方法，允许你使用C来重写编译行为，其他的方法是通过<code>NSObject</code>类使用。有了这些方法，我们就可以为<code>runtime</code>系统增加接口，或者工具。</p>
<h1 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h1><p>先抛出来一个问题，这句话代表什么？</p>
<p><code>[receiver message]</code></p>
<p>receiver执行message函数？ 是这个作用,但是more than that，等价于这行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, @selector(message))</div></pre></td></tr></table></figure>
<p>所以其实message是iOS中非常重要的一环，尤其是在动态绑定中。下面我们具体看下：</p>
<h4 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h4><p>上面讲了，iOS中的函数调用其实是给实例发送了message，有参数的函数其实执行了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</div></pre></td></tr></table></figure>
<p><code>objec_msgSend</code>的方法定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OBJC_EXPORT id objc_msgSend(id self, SEL op, ...)</div></pre></td></tr></table></figure>
<p>那么，消息转发的过程究竟发生了什么呢？<br>我们先看下这里用到的三个类：对象(object)，类(class)，方法(method)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">//对象</div><div class="line">struct objc_object &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//类</div><div class="line">struct objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"></div><div class="line">#if !__OBJC2__</div><div class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class="line">    const char *name                                         OBJC2_UNAVAILABLE;</div><div class="line">    long version                                             OBJC2_UNAVAILABLE;</div><div class="line">    long info                                                OBJC2_UNAVAILABLE;</div><div class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class="line">#endif</div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div><div class="line"></div><div class="line">//方法列表</div><div class="line">struct objc_method_list &#123;</div><div class="line">    struct objc_method_list *obsolete                        OBJC2_UNAVAILABLE;</div><div class="line"></div><div class="line">    int method_count                                         OBJC2_UNAVAILABLE;</div><div class="line">#ifdef __LP64__</div><div class="line">    int space                                                OBJC2_UNAVAILABLE;</div><div class="line">#endif</div><div class="line">    /* variable length structure */</div><div class="line">    struct objc_method method_list[1]                        OBJC2_UNAVAILABLE;</div><div class="line">&#125;                                                            OBJC2_UNAVAILABLE;</div><div class="line"></div><div class="line">//方法</div><div class="line">struct objc_method &#123;</div><div class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</div><div class="line">    char *method_types                                       OBJC2_UNAVAILABLE;</div><div class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>系统首先找到消息的接收对象，然后通过对象找到它的类。</li>
<li>在它的类中查找<code>method_list</code>，是否有selector方法。</li>
<li>没有则查找父类的<code>method_list</code></li>
<li>找到对应的<code>method</code>，执行它的<code>IMP</code></li>
<li>转发IMP的return值</li>
</ol>
<p>selector和IMP、method等的区别，可以参考我的另一篇博客<a href="https://njafei.github.io/2017/05/03/Method-SEL-IMP/" target="_blank" rel="noopener">Method,SEL,IMP</a></p>
<blockquote>
<p> 注意：编译器会生成messaging方法，所以你永远都不应该手动调用这个方法。</p>
</blockquote>
<h4 id="dispatch-table"><a href="#dispatch-table" class="headerlink" title="dispatch table"></a>dispatch table</h4><p>messaging的关键在于编译器给每个类创建的数据结构，每个类的数据结构都包含两个要素：</p>
<ul>
<li>执行父类的指针</li>
<li>一个类分发表(dispatch table)。表中有所有的相关方法和这些方法的地址和id。</li>
</ul>
<blockquote>
<p>runtime系统，要求对象必须等价于<code>objc_object</code>,<code>NSObject</code>和<code>NSProxy</code>都自动包含<code>isa</code>属性。</p>
</blockquote>
<p>结构和原理如图所示：</p>
<p><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/messaging1.gif" alt=""></p>
<p>当消息被发送给对象的时候，消息就按照上图的路径寻找对应的<code>selector</code>，直到达到<code>NSObject</code>，如果在<code>NSObject</code>中还是没有找到对应的方法，则会走到消息转发机制中，下文会介绍。</p>
<h4 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h4><p>为了加速消息分发， 系统会对方法和对应的地址进行缓存，就放在上述的<code>objc_cache</code>，所以在实际运行中，大部分常用的方法都是会被缓存起来的，<code>runtime</code>系统实际上非常快，接近直接执行内存地址的程序速度。</p>
<h1 id="Message-Forwarding"><a href="#Message-Forwarding" class="headerlink" title="Message Forwarding"></a>Message Forwarding</h1><p>如果在<code>dispatch table</code>中没有找到对应的<code>method</code>呢？ 系统仍然会给你补救的机会：</p>
<ul>
<li>resolveInstanceMethod/resolveClassMethod</li>
<li>fast forwarding</li>
<li>normal forwarding</li>
</ul>
<h4 id="resolveInstanceMethod"><a href="#resolveInstanceMethod" class="headerlink" title="resolveInstanceMethod"></a>resolveInstanceMethod</h4><p>系统没有在<code>dispatch_table</code>中找到对应的方法，会看你是否重写了<code>resolveInstanceMethod</code>，<code>resolveClassMethod</code>,这里两个方法是否用来添加动态方法的，一个是实例方法，一个是类方法。</p>
<p>举个例子：我们有个ClassA</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface ClassA : NSObject</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ClassA</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>希望执行ClassA并不存在的foo方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ClassA *a = [ClassA new];</div><div class="line">[a performSelector:@selector(foo)];</div></pre></td></tr></table></figure>
<p>系统会直接报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[ClassA foo]: unrecognized selector sent to instance 0x600000004e00&apos;</div></pre></td></tr></table></figure>
<p>如果我们想用<code>resolveInstanceMethod</code>来补救，该怎么做呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#include &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">void foo(id self, SEL _cmd) &#123;</div><div class="line">    NSLog(@&quot;resolveInstanceMethod add method foo &quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@implementation ClassA</div><div class="line"></div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</div><div class="line">&#123;</div><div class="line">    if (sel == @selector(foo)) &#123;</div><div class="line">       class_addMethod([self class], sel, (IMP)foo, &quot;v@:&quot;);</div><div class="line">       return YES;</div><div class="line">    &#125;</div><div class="line">    return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：一定要记得import <code>&lt;objc/runtime.h&gt;</code>，否则会报错：<code>class_addMethod</code> is valid in C99</p>
</blockquote>
<p>执行下，log：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">resolveInstanceMethod add method foo</div></pre></td></tr></table></figure>
<p>这里的return YES 或者 return NO,是告诉系统是否实现了这个方法，如果return YES，但是并没有增加方法，还是会报错，并且不会走到forward，因为系统默认你已经在这一步做了resolveInstanceMethod这个事情。</p>
<h4 id="forwardingTargetForSelector"><a href="#forwardingTargetForSelector" class="headerlink" title="forwardingTargetForSelector"></a>forwardingTargetForSelector</h4><p>如果上一步骤的<code>resolveInstanceMethod</code> return no，系统会走<code>forwardingTargetForSelector</code>，这一步被称为快速转发，是因为相对下面要介绍的normal fastward，这一步直接转发了消息，而normal fastward生成了NSInvocation，相对直接转发慢一些。</p>
<p>先看下如何实现，比如，我想把消息转发给有能力的classB：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@interface ClassB : NSObject</div><div class="line"></div><div class="line">- (void)foo;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ClassB</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">- (void)foo</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;ClassB foo run&quot;);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>A中需要实现<code>forwardingTargetForSelector</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    if(aSelector == @selector(foo))&#123;</div><div class="line">        ClassB *b = [ClassB new];</div><div class="line">        return b;</div><div class="line">    &#125;</div><div class="line">    return [super forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>run一下，log：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ClassB foo run</div></pre></td></tr></table></figure>
<p>苹果的文档里，讲述了这一个消息转发的出发点，其实是为了实现类似C多继承的功能。我们知道，在C中如果一个类想要具有多个类的功能，是可以直接继承多个类的。而Objective-C是单继承，如果想实现类似的功能，就用消息转发，将消息转发给有能力处理的类。苹果是这样描述他们的思想的：C的多继承，是加法，在多继承的同时，其实也增加了很多不需要的功能，而苹果通过消息转发，实现了减法的思想，只留有用的方法，而不去增加过多内容。</p>
<h4 id="forwardInvocation"><a href="#forwardInvocation" class="headerlink" title="forwardInvocation"></a>forwardInvocation</h4><p>如果你的类没有实现<code>forwardingTargetForSelector</code>方法，系统会调用<code>methodSignatureForSelector</code>方法，如果这个方法返回一个函数的签名，则执行<code>forwardInvocation</code>方法，否则执行<code>doesNotRecognizeSelector</code>。</p>
<p>如果希望在这一步补救，如何做呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">    return [ClassB instanceMethodSignatureForSelector:aSelector];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)forwardInvocation:(NSInvocation *)invocation</div><div class="line">&#123;</div><div class="line">    SEL sel = invocation.selector;</div><div class="line">    ClassB *b = [ClassB new];</div><div class="line"></div><div class="line">    if([b respondsToSelector:sel]) &#123;</div><div class="line">        [invocation invokeWithTarget:b];</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        [self doesNotRecognizeSelector:sel];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p>我自己画了个消息转发的流程图：</p>
<p><img src="http://on0hv7n2x.bkt.clouddn.com/iOS-message-forwarding.png" alt=""></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h4 id="隐藏参数"><a href="#隐藏参数" class="headerlink" title="隐藏参数"></a>隐藏参数</h4><p>刚才讲了，在一个对象执行一个函数的时候，其实是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</div></pre></td></tr></table></figure>
<p>那其实在函数中，<code>receiver</code>和<code>selector</code>是两个隐藏的参数，这两个参数是可以使用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)run</div><div class="line">&#123;</div><div class="line">    [self performSelector:_cmd];  //self: 当前对象  _cmd : &quot;run&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="获取method的地址"><a href="#获取method的地址" class="headerlink" title="获取method的地址"></a>获取method的地址</h5><p>如果你要连续执行同一个method，但是觉得每次都要遍历一遍分发表会效率低，可以直接获取地址(methodForSelector)，然后直接执行函数.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void (*setter)(id, SEL, BOOL);</div><div class="line">int i;</div><div class="line"> </div><div class="line">setter = (void (*)(id, SEL, BOOL))[target</div><div class="line">    methodForSelector:@selector(setFilled:)];</div><div class="line">for ( i = 0 ; i &lt; 1000 ; i++ )</div><div class="line">    setter(targetList[i], @selector(setFilled:), YES);</div></pre></td></tr></table></figure>
<p>个人觉得，这样意义不大，因为其实系统会做缓存。</p>
<h1 id="runtime实际应用"><a href="#runtime实际应用" class="headerlink" title="runtime实际应用"></a>runtime实际应用</h1><p>runtime的应用，主要有几种：</p>
<ul>
<li>AOP,切面编程，做打点</li>
<li>method swizzling,黑魔法做崩溃等的保护</li>
</ul>
<p>因为主要是使用<code>method swizzling</code>来做，我将会在之后的博客中专门介绍。</p>
<p>参考文章：</p>
<ul>
<li>关于编译和链接，可以看下 <a href="http://www.cprogramming.com/compilingandlinking.html" target="_blank" rel="noopener">http://www.cprogramming.com/compilingandlinking.html</a> 这篇文章。</li>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1" target="_blank" rel="noopener">ObjCRuntimeGuide</a></li>
<li><a href="http://stackoverflow.com/questions/3900549/what-is-runtime" target="_blank" rel="noopener">http://stackoverflow.com/questions/3900549/what-is-runtime</a></li>
<li><a href="http://tech.glowing.com/cn/objective-c-runtime/" target="_blank" rel="noopener">http://tech.glowing.com/cn/objective-c-runtime/</a></li>
<li><a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="noopener">http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/</a></li>
<li><a href="http://tech.glowing.com/cn/objective-c-runtime/" target="_blank" rel="noopener">http://tech.glowing.com/cn/objective-c-runtime/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是runtime&quot;&gt;&lt;a href=&quot;#什么是runtime&quot; class=&quot;headerlink&quot; title=&quot;什么是runtime&quot;&gt;&lt;/a&gt;什么是runtime&lt;/h1&gt;&lt;p&gt;依照苹果文档的说法，&lt;code&gt;runtime&lt;/code&gt;是：&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="iOS基础" scheme="https://github.com/njafei/njafei.github.io/categories/iOS%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Apple文档" scheme="https://github.com/njafei/njafei.github.io/tags/Apple%E6%96%87%E6%A1%A3/"/>
    
      <category term="基础知识" scheme="https://github.com/njafei/njafei.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
</feed>
