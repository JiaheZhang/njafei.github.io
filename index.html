<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="atom.xml" title="njafei's blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="njafei's blog">
<meta property="og:url" content="https://github.com/njafei/njafei.github.io/index.html">
<meta property="og:site_name" content="njafei's blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="njafei's blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/njafei/njafei.github.io/"/>





  <title> njafei's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">njafei's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="https://njafei.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="https://njafei.github.io/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="https://njafei.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="https://njafei.github.io/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/njafei/njafei.github.io2017/05/11/ES6之变量的解构赋值/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="njafei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="njafei's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="2017/05/11/ES6之变量的解构赋值/" itemprop="url">
                  ES6之变量的解构赋值
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-11T13:22:57+08:00">
                2017-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="categories/React-Native/" itemprop="url" rel="index">
                    <span itemprop="name">React-Native</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是解构赋值"><a href="#什么是解构赋值" class="headerlink" title="什么是解构赋值"></a>什么是解构赋值</h1><p>以前，如果我们想给一个变量赋值，通常是这样（在Objective-C等语言中，现在仍然是如此）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let a = 1;</div><div class="line">let b = 2;</div><div class="line">let c = 3;</div></pre></td></tr></table></figure>
<p>而<code>ES6</code>现在支持了类似这样的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let [a,b,c] = [1,2,3];</div></pre></td></tr></table></figure>
<p>从而大大简化了变量赋值的语法，而且为诸如：Json解析、函数默认值用法提供了支持，文章最后会介绍。</p>
<p>JS的变量解构赋值，实际上的一种模式匹配，比如：{模式1} = {模式2}，如果模式1能够部分或者完全匹配模式2，则匹配成功的模式1的部分变量就会被赋值为匹配到的值，否则赋值为undefined。这是解构赋值的核心思想，后面的各种类型的解构赋值其实都是这种思想的具体体现。</p>
<p>另外解构赋值，要求赋值对象，即等号右边的值，一定是一个可以遍历的结构，即符合<code>Iterator</code>接口。</p>
<p>接下来会依次介绍以下几种用法：</p>
<ul>
<li>数组的解构赋值</li>
<li>对象的解构赋值</li>
<li>字符串的解构赋值</li>
<li>数值、布尔值的解构赋值</li>
<li>函数参数的解构赋值</li>
<li>圆括号问题</li>
</ul>
<p>在开始前，还有个关于<code>null</code>和<code>undefined</code>的小知识介绍下，js 中，null === undefined 是false。两者的区别在于：</p>
<ul>
<li>null表示”没有对象”，即该处不应该有值。</li>
<li>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义</li>
</ul>
<p>具体的可以看下阮一峰的文章：<a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="external">undefined与null的区别</a>。下面的文章会用到这点。</p>
<h1 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h1><p>数组的结构赋值比较简单，我们下面通过一些不同的例子来看下：</p>
<h4 id="正常结构"><a href="#正常结构" class="headerlink" title="正常结构"></a>正常结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let [a,b,c] = [1,2,3];</div><div class="line">a // 1</div><div class="line">b // 2</div><div class="line">c // 3</div></pre></td></tr></table></figure>
<h4 id="嵌套结构"><a href="#嵌套结构" class="headerlink" title="嵌套结构"></a>嵌套结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let [a,[b,c],d] = [1,[2,3],4];</div><div class="line">a // 1</div><div class="line">b // 2</div><div class="line">c // 3</div><div class="line">d // 4</div></pre></td></tr></table></figure>
<h4 id="…语句"><a href="#…语句" class="headerlink" title="…语句"></a>…语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let [a, ...b] = [1,2,3];</div><div class="line">a // 1</div><div class="line">b // [2,3]</div></pre></td></tr></table></figure>
<h4 id="缺省变量"><a href="#缺省变量" class="headerlink" title="缺省变量"></a>缺省变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let [a, ,c] = [1,2,3];</div><div class="line">a // 1</div><div class="line">c // 3</div><div class="line"></div><div class="line">``` </div><div class="line"></div><div class="line"></div><div class="line">####  解构不完全成功</div></pre></td></tr></table></figure>
<p>let [a,b,c] = [1,];<br>a // 1<br>b // undefined<br>c // undefined<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">另外还有两个注意点：</div><div class="line"></div><div class="line">如果右侧不是一个可遍历的结构，则会报错，如：</div></pre></td></tr></table></figure></p>
<p>let [foo] = 1;//error<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">使用let，const，不可以重复定义变量，如：</div></pre></td></tr></table></figure></p>
<p>let a ;<br>let [a,b] = [1,2];//error: Duplicate declaration<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 默认值</div><div class="line">解构赋值是允许给变量默认值的，如果解构失败(模式匹配不上，或者赋值为`undefined`)，则会使用默认值。如：</div></pre></td></tr></table></figure></p>
<p>let [a = 1, b = 2] = [1,];<br>a // 1<br>b // 2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在前面章节，讲了`null`和`undefined`，如果赋值`null`，系统是不会使用默认值的，因为`null`和`undefined`是不严格相等的。如：</div></pre></td></tr></table></figure></p>
<p>let [a = 1,b] = [1,null];<br>a // 1,<br>b // null,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">另外默认值可以引用解构赋值的其他变量，前提是这个变量已经声明了，如：</div></pre></td></tr></table></figure></p>
<p>let [x = 1, y = x] = []; // x=1, y=1<br>let [x = 1, y = x] = [2];// x=2, y=2<br>let [x = y, y = x] = []; // error y undefined<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># 对象的解构赋值</div><div class="line">对象和数组的重要区别就是，前者是顺序的，后者是非顺序的，所以对象的解构赋值，更加能体现模式匹配的意义。</div><div class="line"></div><div class="line">#### 如何理解</div><div class="line">我们先讲回数组的解构赋值，其实可以这样理解：</div></pre></td></tr></table></figure></p>
<p>let [a, [b, c], d] = [1, [2,3], 4];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">a可以理解为模式1，[b,c]可以理解为模式2， d可以理解为模式3</div><div class="line">函数可以这样写</div></pre></td></tr></table></figure></p>
<p>let [模式1，模式2，模式3] = [匹配模式1,匹配模式2,匹配模式3];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在数组中，模式的匹配是根据`，`的因为数组是有序的，而在对象中，模式匹配则是根据模式的key。比如：</div></pre></td></tr></table></figure></p>
<p>let {foo, bar} = {foo: ‘fooValue’, bar: ‘barValue’};<br>foo // ‘fooValue’<br>bar // ‘barValue’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">我们根据模式匹配的思想，其实等号左边就是&#123;模式1，模式2&#125;,等号右边就是&#123;模式1：模式1值，&#123;模式2：模式2值&#125;&#125;，所以上述代码的完整版是：</div></pre></td></tr></table></figure></p>
<p>let {foo模式: foo模式实例foo, bar模式: bar模式实例bar} = {foo模式: foo模式实例’fooValue’, bar: bar模式实例’barValue’};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这里我们一定要区分的就是模式名和模式实例，比如：</div></pre></td></tr></table></figure></p>
<p>let {foo:[1,bar]} = {[1,2]};<br>bar // 2<br>foo // undefined<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">这里的foo是模式名，并不是变量，所以不会被赋值.</div><div class="line"></div><div class="line">#### 嵌套对象的注意点</div><div class="line">有嵌套对象的时候，需要注意，如果子对象的父属性不存在，会报错，如：</div></pre></td></tr></table></figure></p>
<p>let {foo: {bar} = {bar: ‘bar’}};//TypeError: Cannot read property ‘bar’ of undefined<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这中间的流程是这样的：</div></pre></td></tr></table></figure></p>
<p>let _tmp = {bar: ‘bar’};<br>_tmp.foo.bar;//error<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 已声明的变量赋值注意点</div><div class="line"></div><div class="line">大括号的情况要注意，会被系统理解为代码块，发生错误：</div></pre></td></tr></table></figure></p>
<p>let x ;<br>{x} = {x: 1};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在外面加上圆括号可以解决:</div></pre></td></tr></table></figure></p>
<p>let x ;<br>({x} = {x: 1});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># 字符串的解构赋值</div><div class="line">字符串在被解构赋值的时候，会被转换成类似数组的对象：</div></pre></td></tr></table></figure></p>
<p>let [a,b,c,d] = ‘hello’;<br>a // ‘h’<br>b // ‘e’<br>c // ‘l’<br>d // ‘l’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 属性解构</div><div class="line">这里要介绍个好玩的东西，解构不止能解构值，还能解构属性，因为这里用的都是`.`语法,比如：</div></pre></td></tr></table></figure></p>
<p>let {length: len} = ‘hello’<br>这里最终执行的是：<br>let _tmp = [‘h’,’e’,’l’,’l’,’o’];<br>len = _tmp.length;//这里本来是要报错的，但是_tmp恰好有length属性，所以len 是 5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"># 数值和布尔值的解构赋值</div><div class="line">在数值和布尔值的情况下，等号右边会先转换成对象。</div><div class="line"></div><div class="line">比如：</div></pre></td></tr></table></figure></p>
<p>let {foo} = 123;<br>实际执行是：<br>let foo = 123.foo;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这里还是可以用属性解构：</div></pre></td></tr></table></figure></p>
<p>let {toString: s} = 123;<br>s // function toString() { [native code] }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">这里的数值和布尔值的结构赋值，我目前不太了解具体的实际用法，如果读者知道，麻烦告诉我哈。</div><div class="line"></div><div class="line"># 函数参数的结构赋值</div><div class="line">这里和对象的解构赋值一模一样，不具体介绍</div><div class="line"></div><div class="line"># 圆括号问题</div><div class="line">学过编译原理的人都知道，编译原理到底有多变态，所以编译器的感受应该和我们一样（笑）。在遇到（）的时候，编译器也会出现问题，所以这里有个原则：</div><div class="line"></div><div class="line">&gt; 能不适用圆括号，就不要使用</div><div class="line"></div><div class="line">除非，满足两个条件</div><div class="line"></div><div class="line"> - 不是定义变量，而是赋值</div><div class="line"> - 不在模式部分适用</div><div class="line"></div><div class="line">比如：</div></pre></td></tr></table></figure></p>
<p>{p:(a)} = {p : ‘a’};<br>a // ‘a’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">其他的都会报错</div><div class="line"></div><div class="line"></div><div class="line"># 用途</div><div class="line">#### 解析多个值</div><div class="line"></div><div class="line">在使用函数的时候，经常会返回多个值（js中常见，其他的还真的不常见），用解构赋值的话，语法就会非常简单：</div></pre></td></tr></table></figure></p>
<p>let {a,b,c} = foo();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 函数的参数和默认值</div></pre></td></tr></table></figure></p>
<p>function foo ({a = 1,b = 2,c = 3}){};//<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这里可以节省判断入参的代码</div><div class="line"></div><div class="line"></div><div class="line">#### 和map结合</div></pre></td></tr></table></figure></p>
<p>let map = new Map();<br>map.set(“key1”,”value1”);<br>map.set(“key2”,”value2”);</p>
<p>for (let [a, b] of map) {<br>    console.log(‘key is ‘ + a, ‘value is ‘+ b);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 载入模块使用</div></pre></td></tr></table></figure></p>
<p>import {foo1,foo2} from ‘react-native’;<br>```</p>
<p>这里的用法其实大都差不多，主要是用来简化代码，提高可读性。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/njafei/njafei.github.io2017/05/05/图片清晰度探究/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="njafei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="njafei's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="2017/05/05/图片清晰度探究/" itemprop="url">
                  图片的展示清晰度问题研究
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-05T15:38:08+08:00">
                2017-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="categories/闲来研究/" itemprop="url" rel="index">
                    <span itemprop="name">闲来研究</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前两天产品经理找我，说是首页的轮播图，看起来很模糊，我看了下，确实是效果不好，很多的字看起来不都清晰，看明白是什么很费劲。</p>
<p>看起来效果像是这样（忽然想起一个老朋友，北大高材生，居然喜欢杨幂，这里就用大幂幂吧）</p>
<p><img src="http://on0hv7n2x.bkt.clouddn.com/%E5%9B%BE%E7%89%87%E6%95%88%E6%9E%9C%E5%AF%B9%E6%AF%94%E5%9B%BE%20%20%E6%95%88%E6%9E%9C%E5%B7%AE.png" alt=""></p>
<p>我当时的第一反应就是是不是原图就不清晰。然后我抓包，拿到了图片链接，但是链接的图片在浏览器中看起来效果很不错，像这样：</p>
<p><img src="http://on0hv7n2x.bkt.clouddn.com/%E5%9B%BE%E7%89%87%E6%95%88%E6%9E%9C%E5%AF%B9%E6%AF%94%E5%9B%BE%20%20%E5%8E%9F%E5%9B%BE.jpg" alt=""></p>
<p>但是展示在手机上的效果，真的差强人意，尤其是有文字的时候，文字的边缘锐化的效果很明显。</p>
<p>百思不得其解的时候，发现原图的链接给的尺寸，比手机行的设定尺寸大了好多。做iOS App开发的都知道，因为手机是retina屏，所以要求给的图都是2x和3x的，比如 100 <em> 100的图，我们通常要设计师给的是 200 </em> 200的，6p等是 300 <em> 300.但是这张图，我们需要的是200 </em> 100的，通常给 600 <em> 300肯定够了，但是服务端给的是 1200 </em> 600的，比我们需要的长宽大了两倍。然后我自己用这张图，转换了一张 600 * 300的图，debug发现效果非常好。和服务端沟通了下，给出的原因是：因为公司的图片尺寸是有限的，所以当时找了一个最接近长宽比的给前端。</p>
<p>又找了UI的大神聊了，上述的原因是这样的：</p>
<p>如果一个 9 <em> 9的图，想要在 1 </em> 1的图片中显示，怎会随机从9个像素中选取一个放到1 * 1 中，所以就失真了，类似这样：</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>n</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>1 &lt;= n &lt;= 9</p>
<p>所以呢，想要图片在app上展示出最好的效果，其实不在于图片要切的非常大，而是图片的尺寸再好和你设计的差不多，否则会失真。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/njafei/njafei.github.io2017/05/04/runtime/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="njafei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="njafei's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="2017/05/04/runtime/" itemprop="url">
                  iOS Runtime 详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-04T15:45:12+08:00">
                2017-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="categories/iOS基础/" itemprop="url" rel="index">
                    <span itemprop="name">iOS基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是runtime"><a href="#什么是runtime" class="headerlink" title="什么是runtime"></a>什么是runtime</h1><p>依照苹果文档的说法，<code>runtime</code>是：</p>
<blockquote>
<p> The Objective-C language defers as many decisions as it can from compile time and link time to runtime.<br>（尽量将决定放到运行的时候，而不是在编译和链接过程）</p>
</blockquote>
<p>如何理解这段话呢，我们首先要知道，一段代码从写完到最终执行的过程中发生了什么。</p>
<h4 id="从代码到可执行文件的过程"><a href="#从代码到可执行文件的过程" class="headerlink" title="从代码到可执行文件的过程"></a>从代码到可执行文件的过程</h4><p>这是《深入理解计算机系统(第2版)》里面的一张截图：</p>
<p><img src="http://on0hv7n2x.bkt.clouddn.com/compileToLinkToRun.png" alt=""></p>
<p>主要过程我们可以简化成三个：</p>
<pre><code>- 编译
- 链接
- 运行
</code></pre><p>编译：将代码转换成底层可执行的语言（如汇编），简单来讲，就是把你能看懂的语言，转换成系统底层可以看懂的东西，这中间通常会有优化，先预处理，再编译。</p>
<p>链接：在编译的过程中，如果有调用其他的类的方法等，是不会检查或者报警的，编译的时候会默认你已经实现了。而链接就是去检查调用的方法或者类等是否确实存在。</p>
<p>运行：执行最终的可执行文件</p>
<p>如果是普通的C语言代码，我们使用的是传统的编译运行，那么一个函数的执行内容，在编译阶段其实就确定了，执行的时候只要去执行对应的内存地址的程序就好。</p>
<p>而在<code>runtime</code>中，编译阶段只能确定最终要执行的函数名，但是具体执行的时候，执行的是什么程序，是在运行的时候才能确定，大大增加了程序的灵活性。</p>
<h1 id="Objective-C-runtime介绍"><a href="#Objective-C-runtime介绍" class="headerlink" title="Objective-C runtime介绍"></a>Objective-C runtime介绍</h1><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Objective-C是一门运行时语言，这意味着代码执行可以更加灵活：我们动态的创建一个新的类，还可以转发消息给其他的消息。（消息转发是runtime的一个重要组成部分，后面会介绍）。</p>
<p>这种特性要求Objective-C语言会尽可能把决定从编译和链接的阶段延迟到运行时<code>(runtime)</code>阶段，因此Objective-C不仅有一个编译器，还有一个<code>runtime</code>系统来执行被编译过的代码。</p>
<h4 id="版本和平台"><a href="#版本和平台" class="headerlink" title="版本和平台"></a>版本和平台</h4><p>runtime是有个两个版本的: legacy 、 modern<br>在Objective-C 1.0使用的是legacy，在2.0使用的是modern。这里简单介绍下区别：</p>
<ul>
<li>在legacy runtime，如果你改变了实例变量的设计，需要重新编译它的子类。支持 32bit的OS X 程序</li>
<li>在modern runtime，如果你改变了实例变量的设计，不需要重新编译它的子类。支持iphone程序和OS X10.5之后的64bit程序</li>
</ul>
<p>因为legacy是如此的古老，我们基本可以忽略legacy版本。</p>
<h1 id="Runtime交互"><a href="#Runtime交互" class="headerlink" title="Runtime交互"></a>Runtime交互</h1><p>有三种方式可以使用Runtime：</p>
<ul>
<li>Objective-C 源代码</li>
<li>NSObject 方法</li>
<li>Runtime 方法</li>
</ul>
<h4 id="Objective-C-源代码"><a href="#Objective-C-源代码" class="headerlink" title="Objective-C 源代码"></a>Objective-C 源代码</h4><p>一般来说，runtime都是默默地在后台运行工作，我们只是写Objective-C源代码，就使用了runtime。当我们编译包含Objective-C的类和方法时，编译器就会生成包含runtime特性的数据结构和方法。数据结构中包含了从类、category、协议中定义的的信息，如：selector、变量等等。主要的runtime方法是发送信息的方法<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html#//apple_ref/doc/uid/TP40008048-CH104-SW1" target="_blank" rel="external">Message</a>,在下一章节会讲到。</p>
<h4 id="NSObject方法"><a href="#NSObject方法" class="headerlink" title="NSObject方法"></a>NSObject方法</h4><p>Cocoa中大部分的类都是继承自<code>NSObejct</code>，所以他们都会集成了<code>NSObject</code>定义的方法。（值得注意的例外是<code>NSProxy</code>类）因此<code>NSObject</code>的方法就决定了其他类的行为。（当然，在少数情况下，这样说并不正确，在这些情况下，<code>NSObject</code>会仅仅定义了方法，没有实现必须的代码。比如<code>description</code>，如果子类没有重写，那么会返回类名和地址，这是因为<code>NSObject</code>没法获得更多的信息。）</p>
<p>一些<code>NSObject</code>类的方法可以直接查询<code>runtime</code>系统的信息，从而获得自身的信息。比如<code>class</code>，<code>isKindeOfClass</code>，<code>respondsToSelector</code>等方法。</p>
<h4 id="Runtime方法"><a href="#Runtime方法" class="headerlink" title="Runtime方法"></a>Runtime方法</h4><p>Runtime系统是一个共享的library，包含了许多方法和数据结构，地址在<code>/usr/include/objc</code>。其中的很多方法，允许你使用C来重写编译行为，其他的方法是通过<code>NSObject</code>类使用。有了这些方法，我们就可以为<code>runtime</code>系统增加接口，或者工具。</p>
<h1 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h1><p>先抛出来一个问题，这句话代表什么？</p>
<p><code>[receiver message]</code></p>
<p>receiver执行message函数？ 是这个作用,但是more than that，等价于这行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, @selector(message))</div></pre></td></tr></table></figure>
<p>所以其实message是iOS中非常重要的一环，尤其是在动态绑定中。下面我们具体看下：</p>
<h4 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h4><p>上面讲了，iOS中的函数调用其实是给实例发送了message，有参数的函数其实执行了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</div></pre></td></tr></table></figure>
<p><code>objec_msgSend</code>的方法定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OBJC_EXPORT id objc_msgSend(id self, SEL op, ...)</div></pre></td></tr></table></figure>
<p>那么，消息转发的过程究竟发生了什么呢？<br>我们先看下这里用到的三个类：对象(object)，类(class)，方法(method)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">//对象</div><div class="line">struct objc_object &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//类</div><div class="line">struct objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"></div><div class="line">#if !__OBJC2__</div><div class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class="line">    const char *name                                         OBJC2_UNAVAILABLE;</div><div class="line">    long version                                             OBJC2_UNAVAILABLE;</div><div class="line">    long info                                                OBJC2_UNAVAILABLE;</div><div class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class="line">#endif</div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div><div class="line"></div><div class="line">//方法列表</div><div class="line">struct objc_method_list &#123;</div><div class="line">    struct objc_method_list *obsolete                        OBJC2_UNAVAILABLE;</div><div class="line"></div><div class="line">    int method_count                                         OBJC2_UNAVAILABLE;</div><div class="line">#ifdef __LP64__</div><div class="line">    int space                                                OBJC2_UNAVAILABLE;</div><div class="line">#endif</div><div class="line">    /* variable length structure */</div><div class="line">    struct objc_method method_list[1]                        OBJC2_UNAVAILABLE;</div><div class="line">&#125;                                                            OBJC2_UNAVAILABLE;</div><div class="line"></div><div class="line">//方法</div><div class="line">struct objc_method &#123;</div><div class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</div><div class="line">    char *method_types                                       OBJC2_UNAVAILABLE;</div><div class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>系统首先找到消息的接收对象，然后通过对象找到它的类。</li>
<li>在它的类中查找<code>method_list</code>，是否有selector方法。</li>
<li>没有则查找父类的<code>method_list</code></li>
<li>找到对应的<code>method</code>，执行它的<code>IMP</code></li>
<li>转发IMP的return值</li>
</ol>
<p>selector和IMP、method等的区别，可以参考我的另一篇博客<a href="https://njafei.github.io/2017/05/03/Method-SEL-IMP/" target="_blank" rel="external">Method,SEL,IMP</a></p>
<blockquote>
<p> 注意：编译器会生成messaging方法，所以你永远都不应该手动调用这个方法。</p>
</blockquote>
<h4 id="dispatch-table"><a href="#dispatch-table" class="headerlink" title="dispatch table"></a>dispatch table</h4><p>messaging的关键在于编译器给每个类创建的数据结构，每个类的数据结构都包含两个要素：</p>
<ul>
<li>执行父类的指针</li>
<li>一个类分发表(dispatch table)。表中有所有的相关方法和这些方法的地址和id。</li>
</ul>
<blockquote>
<p>runtime系统，要求对象必须等价于<code>objc_object</code>,<code>NSObject</code>和<code>NSProxy</code>都自动包含<code>isa</code>属性。</p>
</blockquote>
<p>结构和原理如图所示：</p>
<p><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/messaging1.gif" alt=""></p>
<p>当消息被发送给对象的时候，消息就按照上图的路径寻找对应的<code>selector</code>，直到达到<code>NSObject</code>，如果在<code>NSObject</code>中还是没有找到对应的方法，则会走到消息转发机制中，下文会介绍。</p>
<h4 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h4><p>为了加速消息分发， 系统会对方法和对应的地址进行缓存，就放在上述的<code>objc_cache</code>，所以在实际运行中，大部分常用的方法都是会被缓存起来的，<code>runtime</code>系统实际上非常快，接近直接执行内存地址的程序速度。</p>
<h1 id="Message-Forwarding"><a href="#Message-Forwarding" class="headerlink" title="Message Forwarding"></a>Message Forwarding</h1><p>如果在<code>dispatch table</code>中没有找到对应的<code>method</code>呢？ 系统仍然会给你补救的机会：</p>
<ul>
<li>resolveInstanceMethod/resolveClassMethod</li>
<li>fast forwarding</li>
<li>normal forwarding</li>
</ul>
<h4 id="resolveInstanceMethod"><a href="#resolveInstanceMethod" class="headerlink" title="resolveInstanceMethod"></a>resolveInstanceMethod</h4><p>系统没有在<code>dispatch_table</code>中找到对应的方法，会看你是否重写了<code>resolveInstanceMethod</code>，<code>resolveClassMethod</code>,这里两个方法是否用来添加动态方法的，一个是实例方法，一个是类方法。</p>
<p>举个例子：我们有个ClassA</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface ClassA : NSObject</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ClassA</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>希望执行ClassA并不存在的foo方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ClassA *a = [ClassA new];</div><div class="line">[a performSelector:@selector(foo)];</div></pre></td></tr></table></figure>
<p>系统会直接报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[ClassA foo]: unrecognized selector sent to instance 0x600000004e00&apos;</div></pre></td></tr></table></figure>
<p>如果我们想用<code>resolveInstanceMethod</code>来补救，该怎么做呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#include &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">void foo(id self, SEL _cmd) &#123;</div><div class="line">    NSLog(@&quot;resolveInstanceMethod add method foo &quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@implementation ClassA</div><div class="line"></div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</div><div class="line">&#123;</div><div class="line">    if (sel == @selector(foo)) &#123;</div><div class="line">       class_addMethod([self class], sel, (IMP)foo, &quot;v@:&quot;);</div><div class="line">       return YES;</div><div class="line">    &#125;</div><div class="line">    return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：一定要记得import <code>&lt;objc/runtime.h&gt;</code>，否则会报错：<code>class_addMethod</code> is valid in C99</p>
</blockquote>
<p>执行下，log：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">resolveInstanceMethod add method foo</div></pre></td></tr></table></figure>
<p>这里的return YES 或者 return NO,是告诉系统是否实现了这个方法，如果return YES，但是并没有增加方法，还是会报错，并且不会走到forward，因为系统默认你已经在这一步做了resolveInstanceMethod这个事情。</p>
<h4 id="forwardingTargetForSelector"><a href="#forwardingTargetForSelector" class="headerlink" title="forwardingTargetForSelector"></a>forwardingTargetForSelector</h4><p>如果上一步骤的<code>resolveInstanceMethod</code> return no，系统会走<code>forwardingTargetForSelector</code>，这一步被称为快速转发，是因为相对下面要介绍的normal fastward，这一步直接转发了消息，而normal fastward生成了NSInvocation，相对直接转发慢一些。</p>
<p>先看下如何实现，比如，我想把消息转发给有能力的classB：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@interface ClassB : NSObject</div><div class="line"></div><div class="line">- (void)foo;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ClassB</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">- (void)foo</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;ClassB foo run&quot;);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>A中需要实现<code>forwardingTargetForSelector</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    if(aSelector == @selector(foo))&#123;</div><div class="line">        ClassB *b = [ClassB new];</div><div class="line">        return b;</div><div class="line">    &#125;</div><div class="line">    return [super forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>run一下，log：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ClassB foo run</div></pre></td></tr></table></figure>
<p>苹果的文档里，讲述了这一个消息转发的出发点，其实是为了实现类似C多继承的功能。我们知道，在C中如果一个类想要具有多个类的功能，是可以直接继承多个类的。而Objective-C是单继承，如果想实现类似的功能，就用消息转发，将消息转发给有能力处理的类。苹果是这样描述他们的思想的：C的多继承，是加法，在多继承的同时，其实也增加了很多不需要的功能，而苹果通过消息转发，实现了减法的思想，只留有用的方法，而不去增加过多内容。</p>
<h4 id="forwardInvocation"><a href="#forwardInvocation" class="headerlink" title="forwardInvocation"></a>forwardInvocation</h4><p>如果你的类没有实现<code>forwardingTargetForSelector</code>方法，系统会调用<code>methodSignatureForSelector</code>方法，如果这个方法返回一个函数的签名，则执行<code>forwardInvocation</code>方法，否则执行<code>doesNotRecognizeSelector</code>。</p>
<p>如果希望在这一步补救，如何做呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">    return [ClassB instanceMethodSignatureForSelector:aSelector];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)forwardInvocation:(NSInvocation *)invocation</div><div class="line">&#123;</div><div class="line">    SEL sel = invocation.selector;</div><div class="line">    ClassB *b = [ClassB new];</div><div class="line"></div><div class="line">    if([b respondsToSelector:sel]) &#123;</div><div class="line">        [invocation invokeWithTarget:b];</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        [self doesNotRecognizeSelector:sel];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p>我自己画了个消息转发的流程图：</p>
<p><img src="http://on0hv7n2x.bkt.clouddn.com/iOS-message-forwarding.png" alt=""></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h4 id="隐藏参数"><a href="#隐藏参数" class="headerlink" title="隐藏参数"></a>隐藏参数</h4><p>刚才讲了，在一个对象执行一个函数的时候，其实是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</div></pre></td></tr></table></figure>
<p>那其实在函数中，<code>receiver</code>和<code>selector</code>是两个隐藏的参数，这两个参数是可以使用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)run</div><div class="line">&#123;</div><div class="line">    [self performSelector:_cmd];  //self: 当前对象  _cmd : &quot;run&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="获取method的地址"><a href="#获取method的地址" class="headerlink" title="获取method的地址"></a>获取method的地址</h5><p>如果你要连续执行同一个method，但是觉得每次都要遍历一遍分发表会效率低，可以直接获取地址(methodForSelector)，然后直接执行函数.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void (*setter)(id, SEL, BOOL);</div><div class="line">int i;</div><div class="line"> </div><div class="line">setter = (void (*)(id, SEL, BOOL))[target</div><div class="line">    methodForSelector:@selector(setFilled:)];</div><div class="line">for ( i = 0 ; i &lt; 1000 ; i++ )</div><div class="line">    setter(targetList[i], @selector(setFilled:), YES);</div></pre></td></tr></table></figure>
<p>个人觉得，这样意义不大，因为其实系统会做缓存。</p>
<h1 id="runtime实际应用"><a href="#runtime实际应用" class="headerlink" title="runtime实际应用"></a>runtime实际应用</h1><p>runtime的应用，主要有几种：</p>
<ul>
<li>AOP,切面编程，做打点</li>
<li>method swizzling,黑魔法做崩溃等的保护</li>
</ul>
<p>因为主要是使用<code>method swizzling</code>来做，我将会在之后的博客中专门介绍。</p>
<p>参考文章：</p>
<ul>
<li>关于编译和链接，可以看下 <a href="http://www.cprogramming.com/compilingandlinking.html" target="_blank" rel="external">http://www.cprogramming.com/compilingandlinking.html</a> 这篇文章。</li>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1" target="_blank" rel="external">ObjCRuntimeGuide</a></li>
<li><a href="http://stackoverflow.com/questions/3900549/what-is-runtime" target="_blank" rel="external">http://stackoverflow.com/questions/3900549/what-is-runtime</a></li>
<li><a href="http://tech.glowing.com/cn/objective-c-runtime/" target="_blank" rel="external">http://tech.glowing.com/cn/objective-c-runtime/</a></li>
<li><a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="external">http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/</a></li>
<li><a href="http://tech.glowing.com/cn/objective-c-runtime/" target="_blank" rel="external">http://tech.glowing.com/cn/objective-c-runtime/</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/njafei/njafei.github.io2017/05/03/Method-SEL-IMP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="njafei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="njafei's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="2017/05/03/Method-SEL-IMP/" itemprop="url">
                  Method,SEL,Imp
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-03T16:11:23+08:00">
                2017-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="categories/iOS基础/" itemprop="url" rel="index">
                    <span itemprop="name">iOS基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这三个概念，虽然在平时的时候总是在用，但是最近写<code>runtime</code>的时候，又感觉有点糊涂，今天就把他们的关系搞清楚。</p>
<h1 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h1><p>先看下定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">runtime.h</div><div class="line">/// An opaque type that represents a method in a class definition.代表类定义中一个方法的不透明类型</div><div class="line">typedef struct objc_method *Method;</div><div class="line"></div><div class="line">struct objc_method &#123;</div><div class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</div><div class="line">    char *method_types                                       OBJC2_UNAVAILABLE;</div><div class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Method和我们平时理解的函数是一致的，就是表示能够独立完成一个功能的一段代码，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)logName</div><div class="line">&#123;</div><div class="line">	NSLog(@&quot;name&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码，就是一个函数。</p>
<p>我们来看下<code>objc_method</code>这个结构体的内容：</p>
<ul>
<li>SEL method_name 方法名</li>
<li>char *method_types 方法类型</li>
<li>IMP method_imp 方法实现</li>
</ul>
<p>在这个结构体重，我们已经看到了<code>SEL</code>和<code>IMP</code>，说明<code>SEL</code>和<code>IMP</code>其实都是<code>Method</code>的属性。</p>
<p>我们接着来看<code>SEL</code>。</p>
<h1 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h1><p>还是先看定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Objc.h</div><div class="line">/// An opaque type that represents a method selector.代表一个方法的不透明类型</div><div class="line">typedef struct objc_selector *SEL;</div></pre></td></tr></table></figure></p>
<p>这里要先说明下<code>selector</code>和<code>SEL</code>的关系，我在写本文的时候，其实搜索的是<code>selector</code>，直到我看到了<code>selector</code>的定义，才发现我理解一直不对。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property SEL selector;</div></pre></td></tr></table></figure>
<p>在文档中，<code>selector</code>的定义都是这样声明，也就是说：<code>selector</code>是<code>SEL</code>的一个实例，只是在iOS中，<code>selector</code>的使用是如此的频繁，我们才会把他当成一个概念。</p>
<p><code>selector</code>怎么理解呢？我们可以想想股票，比如市场上有如此多公司在纳斯达克上市，而且他们的名字又非常的长，或者有些公司的名称也是相似的，都是**有限公司。那当市场去指定一个股票的时候，效率会非常低，当你着急想买股票的时候，你会跟你的经纪人说：“hi，peter，给我买一百股Tuniu limited liability company的股票吗？”，也许等你说完，经纪人输入完，市场就变化了，所以纳斯达克通常用代码，比如“TOUR”.这里的<code>selector</code>有类似的作用，就是让我们能够快速找到对应的函数。</p>
<p>文档中是这样讲的：</p>
<blockquote>
<p> A method selector is a C string that has been registered (or “mapped“) with the Objective-C runtime. Selectors generated by the compiler are automatically mapped by the runtime when the class is loaded.</p>
</blockquote>
<p>在iOS中，<code>runtime</code>会在运行的时候，通过<code>load</code>函数，将所有的<code>method</code>hash然后map到<code>set</code>中。这样在运行的时候，寻找<code>selector</code>的速度就会非常快，不会因为<code>runtime</code>特性牺牲太多的性能。</p>
<p><code>selector</code>既然是一个string，我觉得应该是类似<code>className+method</code>的组合，命名规则有两条：</p>
<ul>
<li>同一个类，selector不能重复</li>
<li>不同的类，selector可以重复</li>
</ul>
<p>这也带来了一个弊端，我们在写C代码的时候，经常会用到函数重载，就是函数名相同，参数不同，但是这在<code>Objective-C</code>中是行不通的，因为<code>selector</code>只记了<code>method</code>的name，没有参数，所以没法区分不同的method。</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)caculate(NSInteger)num;</div><div class="line"></div><div class="line">- (void)caculate(CGFloat)num;</div></pre></td></tr></table></figure>
<p>是会报错的。</p>
<p>我们只能通过命名来区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)caculateWithInt(NSInteger)num;</div><div class="line"></div><div class="line">- (void)caculateWithFloat(CGFloat)num;</div></pre></td></tr></table></figure>
<h1 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h1><p>看下<code>IMP</code>的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/// A pointer to the function of a method implementation.  指向一个方法实现的指针</div><div class="line">typedef id (*IMP)(id, SEL, ...); </div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>这个就比较好理解了，就是指向最终实现程序的内存地址的指针。</p>
<p>综上，在iOS的<code>runtime</code>中，<code>Method</code>通过<code>selector</code>和<code>IMP</code>两个属性，实现了快速查询方法及实现，相对提高了性能，又保持了灵活性。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/njafei/njafei.github.io2017/04/28/sqlite-python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="njafei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="njafei's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="2017/04/28/sqlite-python/" itemprop="url">
                  SQLite-Python学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-28T11:05:29+08:00">
                2017-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>注： 本文默认有基本的数据库和SQLite知识</p>
</blockquote>
<p>最近在做SQLite数据库相关的自动化任务，所以学习了下<code>phthon</code>中如何使用<code>SQLite</code>，网上的教程如：<a href="http://www.runoob.com/sqlite/sqlite-python.html" target="_blank" rel="external">runoob</a>、 <a href="https://docs.python.org/2/library/sqlite3.html" target="_blank" rel="external">docs.python</a>等的说明不太详细，而且很多细节和demo都写的比较粗，遂有此文。</p>
<h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>首先我们要连接数据库，要不然没法操作。<code>python</code>2.5之后，内置了<code>sqlite3</code>，所以我们可以直接用内置的命令。</p>
<p>介绍第一个命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sqlite3.connect(database [,timeout ,other optional arguments]);</div></pre></td></tr></table></figure>
<ul>
<li>database： 数据库的path，如果不给，就会创建一个。如果给的“:memory:”，则会创建一个建在RAM上的数据库。</li>
<li>timeout: 默认是5s，当数据库锁定的时候，最长的等待时间</li>
<li><p>optional arguments： 暂时没查到有哪些参数可选</p>
<p>比如我们想要新建一个数据库：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"></div><div class="line">import sqlite3</div><div class="line"></div><div class="line">newData = sqlite3.connect(&apos;new.sqlite&apos;)</div><div class="line">print &quot;open new Database successfully&quot;;</div></pre></td></tr></table></figure>
<p>这样，就建好了一个名为new的数据库，并连接上。</p>
<p>如果想建一个RAM上面的数据库，就使用<code>:memory</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">newData = sqlite3.connect(&apos;:memory:&apos;)</div></pre></td></tr></table></figure>
<p>还可以设置10s的<code>timeout</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">newData = sqlite3.connect(&apos;:memory:&apos;[,10]);</div></pre></td></tr></table></figure>
<p>关闭数据库连接就比较简单了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">newData.close();</div></pre></td></tr></table></figure>
<h1 id="数据库执行SQL语句"><a href="#数据库执行SQL语句" class="headerlink" title="数据库执行SQL语句"></a>数据库执行<code>SQL</code>语句</h1><h4 id="执行简单语句"><a href="#执行简单语句" class="headerlink" title="执行简单语句"></a>执行简单语句</h4><p>这里主要有两种方式：</p>
<ul>
<li>数据库直接执行 <code>connection.execute()</code></li>
<li>通过cursor执行 <code>cursor.execute</code></li>
</ul>
<p>举个例子，我们希望建一个如下的数据表并插入数据：user</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>money</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>jack</td>
<td>100</td>
</tr>
<tr>
<td>1</td>
<td>rose</td>
<td>200</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#create table</div><div class="line">newData.execute(&quot;create table user (id, name, money)&quot;);</div><div class="line"></div><div class="line">#insert data</div><div class="line">newData.execute(&quot;insert into user values (1,&apos;jack&apos;,100)&quot;);</div><div class="line">newData.execute(&quot;insert into user values (2,&apos;rose&apos;,200)&quot;);</div><div class="line"></div><div class="line">#打印看下是否成功</div><div class="line">users = newData.execute(&quot;select * from user&quot;);</div><div class="line">print(&apos;row in new data&apos;);</div><div class="line">for row in users:</div><div class="line">	print row[0],</div><div class="line">	print row[1]</div><div class="line"></div><div class="line">newData.commit();</div><div class="line">newData.close();</div></pre></td></tr></table></figure>
<p>这里面有个注意点：一定要<code>commit</code> 和 <code>close</code> ，否则不会保存。</p>
<blockquote>
<p>commit: 该方法提交当前的事务。如果您未调用该方法，那么自您上一次调用 commit() 以来所做的任何动作对其他数据库连接来说是不可见的。</p>
</blockquote>
<p>这里的<code>execute</code>也可以用cursor执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#获取cursor</div><div class="line">c = localData.cursor()</div><div class="line"></div><div class="line">#cursor执行语句</div><div class="line">c.execute(&quot;select * from user&quot;);</div></pre></td></tr></table></figure>
<h4 id="执行带参数的语句"><a href="#执行带参数的语句" class="headerlink" title="执行带参数的语句"></a>执行带参数的语句</h4><p>如果我们有用到python里声明的变量，就只能通过<code>cursor</code>了。比如想要计算数组的和，放到amy的money中：</p>
<p>这里先介绍下有参数的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cursor.execute(sql, seq_of_parameters)</div><div class="line"></div><div class="line">cursor.execute(&quot;insert into people values (?, ?)&quot;, (who, age))</div></pre></td></tr></table></figure>
<p>execute只接收两个参数，sql和param，sql中的变量名，都用?或者命名代替，然后依次写在参数中。记住，一定要放到一个括号中，否则会认为有三个参数，会报错：<code>TypeError: function takes at most 2 arguments (3 given)</code></p>
<p>实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#获取cursor</div><div class="line">c = localData.cursor()</div><div class="line"></div><div class="line">#计算总和</div><div class="line">name = &apos;amy&apos;;</div><div class="line">total = money + money2 + money3;</div><div class="line"></div><div class="line">#写入rose的钱中</div><div class="line">c.execute(&quot;inset into user value (3, ?, ?)&quot;,(name,total));</div><div class="line"></div><div class="line">#or </div><div class="line">#c.execute(&quot;inset into user value (3, name, money)&quot;,(name,total));</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：这里的connect也可以执行带参数的语句，但是其实都是生成临时cursor执行，所以这两种方法本质是一样的，下文中遇到这两个，只会写一个作为示范。</p>
</blockquote>
<h4 id="处理多组数据"><a href="#处理多组数据" class="headerlink" title="处理多组数据"></a>处理多组数据</h4><p>如果我们希望针对一组数据，执行同样的sql呢？当然可以<code>for: in</code> 来挨个执行，也可以使用批量的数据处理方法：</p>
<ul>
<li><code>cursor.executemany(sql, seq_of_parameters)</code></li>
<li><code>connection.executemany(sql[, parameters])</code> 最终还是通过cursor执行</li>
</ul>
<p>比如刚才的例子，我们不用一条一条数据插入，而是直接插入一个数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">newUsers = [(1,&apos;jack&apos;,100),(2,&apos;rose&apos;,100)];</div><div class="line">newData.executemany(&quot;insert into user values(?,?,?)&quot;,newUsers);</div></pre></td></tr></table></figure>
<h4 id="处理多条语句"><a href="#处理多条语句" class="headerlink" title="处理多条语句"></a>处理多条语句</h4><p>如果是想连续执行多条语句如何呢？</p>
<ul>
<li>cursor.executescript(sql_script)</li>
<li>connection.executescript(sql_script)</li>
</ul>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sqlscript = &quot;&quot;&quot;insert into user values(1,&apos;jack&apos;,100);</div><div class="line">			   insert into user values(2,&apos;rose&apos;,200);&quot;&quot;&quot;</div><div class="line"></div><div class="line">newData.executescript(sqlscript);</div></pre></td></tr></table></figure>
<h1 id="操作cursor"><a href="#操作cursor" class="headerlink" title="操作cursor"></a>操作cursor</h1><p>这里的cursor可以理解为我们变成时候的光标，光标在哪里，我们当前的操作点和关注点就在哪里。而当我们多次操作的时候，可能想要获取当前光标所在的位置。</p>
<p>还是举个例子：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>money</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>jack</td>
<td>100</td>
</tr>
<tr>
<td>2</td>
<td>rose</td>
<td>200</td>
</tr>
<tr>
<td>3</td>
<td>john</td>
<td>200</td>
</tr>
</tbody>
</table>
<p>我希望查到谁的money是200，而且我想获得当前的光标坐在的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">c = newData.cursor();</div><div class="line">c.execute(&quot;select * from user where money = 200&quot;);</div><div class="line">#查第一条</div><div class="line">c.fetchone();//(2,rose,200)</div><div class="line"></div><div class="line"># 查前两条</div><div class="line">c.fetchmany(2);// (2,rose,200),(3,john,200)</div><div class="line"></div><div class="line"># 查所有的</div><div class="line">c.fetchall();//(2,rose,200),(3,john,200)</div><div class="line"></div><div class="line">#如果没有结果返回none</div><div class="line">c.execute(&quot;select * from user where money = 300&quot;);</div><div class="line">c.fetchone();//none</div></pre></td></tr></table></figure>
<p>说实话，刚开始看我是很疑惑的,看起来，这个光标的作用和我直接用一个数组赋值貌似没有什么区别，难道是这样比较方便来获取最后的结果么？</p>
<p>后来问了大神，发现原来光标是这样子的，fetch了一条，光标会下移，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">c.execute(&quot;select * from user where money = 200&quot;);</div><div class="line">print c.fetchone();//(2,rose, 200)</div><div class="line">print c.fetchone();//(3,john,200)</div><div class="line">print c.fetchone();//none</div></pre></td></tr></table></figure>
<p>再结合一些操作光标的操作，就可以实现一些比较复杂的用法了。</p>
<h1 id="操作相关"><a href="#操作相关" class="headerlink" title="操作相关"></a>操作相关</h1><p>数据库的操作和git还是有点相似的，都是有提交，回滚等，我们依次介绍下：</p>
<ul>
<li>connection.commit() 提交修改，否则不会保存</li>
<li>connection.rollback() 回滚上次的commit</li>
<li>connection.close() 关闭数据库连接</li>
<li>connection.total_changes() 查看修改的总行数</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/njafei/njafei.github.io2017/04/18/KVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="njafei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="njafei's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="2017/04/18/KVC/" itemprop="url">
                  KVC详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-18T17:58:01+08:00">
                2017-04-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="categories/iOS基础/" itemprop="url" rel="index">
                    <span itemprop="name">iOS基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><p>正常访问或者修改一个对象的属性，都是通过getter和setter方法，但是Cocoa仍然提供了一个间接访问属性的方法：KVC（Key-Value Coding）。 只要对象支持<code>NSKeyValueCoding</code>协议，我们就可以通过KVC来间接访问或者修改属性和属性中的更深层的属性。</p>
<p>KVC也是许多Cocoa技术的基础，比如：</p>
<ul>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i" target="_blank" rel="external">KVO</a></li>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CocoaBindings/Concepts/WhatAreBindings.html" target="_blank" rel="external">Cocoa bingdings</a></li>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/index.html#//apple_ref/doc/uid/TP40001075" target="_blank" rel="external">Core Data</a></li>
<li><a href="https://developer.apple.com/library/content/documentation/AppleScript/Conceptual/AppleScriptX/AppleScriptX.html#//apple_ref/doc/uid/10000156i" target="_blank" rel="external">AppleScript</a>。</li>
</ul>
<h3 id="使用KVC的对象"><a href="#使用KVC的对象" class="headerlink" title="使用KVC的对象"></a>使用KVC的对象</h3><p>所有继承<code>NSObject</code>的类都支持KVC，<code>NSObject</code>实现了<code>NSKeyValueCoding</code>和必要的方法。通过KVC，可以做到以下功能：</p>
<ul>
<li>获取对象属性 比如使用 <code>valueForKey</code> 和 <code>setValue:forkey:</code>来获取和修改属性</li>
<li>操作Collection类型的的属性，比如<code>NSArray</code>、<code>NSSet</code></li>
<li>使用Collection运算符</li>
<li>非对象的values</li>
<li>路径搜索的步骤（本文不会讲这个，请自己看文档）</li>
</ul>
<p>下面，我们来挨个看下上面的5种用法</p>
<h1 id="获取对象属性"><a href="#获取对象属性" class="headerlink" title="获取对象属性"></a>获取对象属性</h1><p>属性可以分为3个类型：</p>
<ul>
<li>Attributes（简单属性），比如string，int，bool等简单类型</li>
<li>To-one relationships（单一关系），比如一个<code>Person</code>类的实例</li>
<li>To-many relationships（多个关系），比如<code>NSArray</code>或者<code>NSSet</code></li>
</ul>
<p>来看下例子,这个一家人的类： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@interface Person : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *name;</div><div class="line">@property (nonatomic, assign) NSInteger age;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@interface Family : NSObject</div><div class="line"></div><div class="line">@property (nonatomic) NSNumber* numbers;              // An attribute</div><div class="line">@property (nonatomic) Person* boss;                         // A to-one relation</div><div class="line">@property (nonatomic) NSArray&lt; Person* &gt;* members; // A to-many relation</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="通过key与keyPath读取属性"><a href="#通过key与keyPath读取属性" class="headerlink" title="通过key与keyPath读取属性"></a>通过key与keyPath读取属性</h3><p>在介绍如何读取之前，我简单说下key和keyPath。<br>key可以简答理解为对象某个属性的名称，而keyPath是又<code>.</code>区分的一串string，用来读取更深层的value。举个列子：对于Family来说，他的key有几个：<code>numbers</code>、<code>boss</code>、<code>members</code>。我们可以通过这几个key来读取他对应的属性。但是如果我们想要读取<code>boss</code>的name，一种办法是先读取<code>boss</code>，然后读取<code>boss</code>的name，另一个办法就是我们通过keyPath,直接读取<code>family</code>的<code>boss.name</code>，这个<code>boss.name</code>就是keyPath。</p>
<p>通过key和keyPath读取属性，有以下几个方法：</p>
<ul>
<li><code>valueForKey:</code> 读取key</li>
<li><code>valueForKeyPath:</code> 读取keyPath </li>
<li><code>dictionaryWithValuesForKeys:</code> 批量读取</li>
</ul>
<p>还是通过例子来看，我们先初始化几个实例出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Person *father = [Person new];</div><div class="line">father.name = @&quot;Jack&quot;;</div><div class="line">father.age = 50;</div><div class="line"></div><div class="line">Person *mother = [Person new];</div><div class="line">mother.name = @&quot;rose&quot;;</div><div class="line">mother.age = 45;</div><div class="line"></div><div class="line"></div><div class="line">Family *family = [Family new];</div><div class="line">family.numbers = @(2);</div><div class="line">family.boss = father;</div><div class="line">family.members = @[father, mother];</div></pre></td></tr></table></figure>
<p>我们分别用上面的三个方法来读取属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSString *fatherName = [father valueForKey:@&quot;name&quot;];</div><div class="line">NSLog(@&quot;father name: %@,&quot;,fatherName);</div><div class="line"></div><div class="line">NSString *bossName = [family valueForKeyPath:@&quot;boss.name&quot;];</div><div class="line">NSLog(@&quot;boss name: %@,&quot;,bossName);</div><div class="line"></div><div class="line">NSDictionary *names = [family dictionaryWithValuesForKeys:@[@&quot;numbers&quot;,@&quot;members&quot;]];</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，如果是NSArray、NSSet等类型，不能包含nil，而是转皇城NSNull。系统会在使用的时候自动转换。</p>
</blockquote>
<h3 id="通过key和keyPath修改属性"><a href="#通过key和keyPath修改属性" class="headerlink" title="通过key和keyPath修改属性"></a>通过key和keyPath修改属性</h3><p>有以下几种方法：</p>
<ul>
<li>setValue:forkey:</li>
<li>setValue:forKeyPath:</li>
<li>setValuesForKeysWithDictionary:</li>
</ul>
<p>还是直接上例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[father setValue:@&quot;Jack is gone&quot; forKey:@&quot;name&quot;];</div><div class="line"></div><div class="line">[family setValue:@&quot;boss&apos;s name&quot; forKeyPath:@&quot;boss.name&quot;];</div><div class="line"></div><div class="line">[family setValuesForKeysWithDictionary:@&#123;@&quot;numbers&quot;:@(3),@&quot;boss&quot;:father&#125;];</div></pre></td></tr></table></figure>
<h3 id="使用KVC简化你的代码"><a href="#使用KVC简化你的代码" class="headerlink" title="使用KVC简化你的代码"></a>使用KVC简化你的代码</h3><p>讲了半天KVC的使用，那么我们什么时候用？怎么用比较适合呢？看个例子:</p>
<p>如果你有类column，identifier可能是name、age、favoriteColor，你要根据identifier的不同去展示不同的属性。正常写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (id)tableView:(NSTableView *)tableview objectValueForTableColumn:(id)column row:(NSInteger)row</div><div class="line">&#123;</div><div class="line">id result = nil;</div><div class="line">Person *person = [self.people objectAtIndex:row];</div><div class="line"></div><div class="line">if ([[column identifier] isEqualToString:@&quot;name&quot;]) &#123;</div><div class="line">result = [person name];</div><div class="line">&#125; else if ([[column identifier] isEqualToString:@&quot;age&quot;]) &#123;</div><div class="line">result = @([person age]);  // Wrap age, a scalar, as an NSNumber</div><div class="line">&#125; else if ([[column identifier] isEqualToString:@&quot;favoriteColor&quot;]) &#123;</div><div class="line">result = [person favoriteColor];</div><div class="line">&#125; // And so on...</div><div class="line"></div><div class="line">return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简化写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (id)tableView:(NSTableView *)tableview objectValueForTableColumn:(id)column row:(NSInteger)row</div><div class="line">&#123;</div><div class="line">return [[self.people objectAtIndex:row] valueForKey:[column identifier]];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="获取Collection对象属性"><a href="#获取Collection对象属性" class="headerlink" title="获取Collection对象属性"></a>获取Collection对象属性</h1><p>在上面我们看到，其实使用<code>valueForKey:</code>和<code>valueForKeyPath</code>是可以获取<code>NSArray</code>等类型的，但是我们获取的是一个不可变的类型，如果我们希望去修改<code>key</code>或者<code>keyPath</code>对应的数组的时候，怎么做呢？</p>
<p>使用：</p>
<ul>
<li>mutableArrayValueForKey: 和 mutableArrayValueForKeyPath:</li>
<li>mutableSetValueForKey: and mutableSetValueForKeyPath:</li>
<li>mutableOrderedSetValueForKey: and mutableOrderedSetValueForKeyPath:</li>
</ul>
<p>来个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *members = [family mutableArrayValueForKey:@&quot;members&quot;];</div><div class="line"></div><div class="line">Person *son = [Person new];</div><div class="line">father.name = @&quot;Jack&apos;s son&quot;;</div><div class="line">father.age = 15;</div><div class="line"></div><div class="line">[members addObject: son];</div></pre></td></tr></table></figure>
<h1 id="使用Collection运算符"><a href="#使用Collection运算符" class="headerlink" title="使用Collection运算符"></a>使用Collection运算符</h1><h3 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h3><p>我们在实际的使用时，会有很多类似于数组平均数、最大值等计算的需求，除了自己写算法计算之外，如果有类似于数据库的快捷操作符，那该多好啊！</p>
<p>现在，我们就来看下KVC提供的数组等的快捷计算符。</p>
<p>正常使用<code>keyPath</code>的时候，我们通常会使用类似<code>person.son.name</code>等来读取属性。<code>KVC</code>同样提供了<code>@</code>操作符和一些基本的操作，我们可以放到<code>keyPath</code>中，就可以在return之前执行这个操作，然后再返回值了，听起来有点变扭，我们先看下结构：</p>
<p><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/art/keypath.jpg" alt=""></p>
<p>操作符是由 <code>@</code>符号和操作函数名组成的</p>
<p>在操作符前面的都叫 <code>left key path</code>，这里指定接收消息的对象，为空的话，就是执行<code>keyPath</code>的对象</p>
<p>在操作符后面的都叫 <code>right key path</code>, 这里执行操作的对象，除了数组的<code>@count</code>之外，不能为空</p>
<h3 id="聚合运算"><a href="#聚合运算" class="headerlink" title="聚合运算"></a>聚合运算</h3><p>这样讲，还是有点虚，我们看个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@interface SaveRecond : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *name;</div><div class="line">@property (nonatomic, assign) NSInteger money;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@interface Bank : NSObject</div><div class="line"></div><div class="line">@property (nonatomic) NSArray&lt; SaveRecond* &gt;* reconds;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>初始化下数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">SaveRecond *save1 = [SaveRecond new];</div><div class="line">save1.name = @&quot;Jack&quot;;</div><div class="line">save1.money = 10;</div><div class="line"></div><div class="line">SaveRecond *save2 = [SaveRecond new];</div><div class="line">save2.name = @&quot;rose&quot;;</div><div class="line">save2.money = 20;</div><div class="line"></div><div class="line">SaveRecond *save3 = [SaveRecond new];</div><div class="line">save3.name = @&quot;Jack&quot;;</div><div class="line">save3.money = 30;</div><div class="line"></div><div class="line"></div><div class="line">Bank *bank = [Bank new];</div><div class="line">bank.reconds = @[save1, save2,save3];</div></pre></td></tr></table></figure>
<p>如果我们想计算这些储户的平均值，可以直接遍历bank的reconds，然后计算，那么，如果用KVC的operation，该如何做呢？一句话解决：</p>
<p><code>NSObject *count = [bank valueForKeyPath:@&quot;reconds.@count&quot;];</code></p>
<p>这句话的意思就是 我希望向bank的reconds属性，发送@count消息，执行@count运算。</p>
<p>我们再来看个有<code>right key path</code>的。这里我希望计算出所有记录的平均储蓄值。</p>
<p><code>NSObject *avg = [bank valueForKeyPath:@&quot;reconds.@avg.money&quot;];</code><br>这句话的意思是，我希望向bank的reconds属性，发送@avg消息，执行money的avg运算。</p>
<p>同理，计算符还有很多，我这里就不一一介绍了，简单列下，只要学过数据库的，应该没啥问题（没学过？感觉学习下呀0_0）</p>
<ul>
<li>@avg</li>
<li>@count</li>
<li>@max</li>
<li>@min</li>
<li>@sum</li>
</ul>
<h3 id="数组运算"><a href="#数组运算" class="headerlink" title="数组运算"></a>数组运算</h3><p>刚才用的都是聚合之后的计算，我们看下如何对数组进行计算。比如：我想要知道一共有个用户(去重)。</p>
<p><code>NSArray *array = [bank valueForKeyPath:@&quot;reconds.@distinctUnionOfObjects.name&quot;];</code></p>
<p>这句话的含义是 我希望向bank的reconds属性发送distinctUnionOfObjects消息，执行基于name的distinctUnionOfObjects操作。</p>
<p>这里的运算符有两个：</p>
<ul>
<li>distinctUnionOfObjects 去重</li>
<li>unionOfObjects 不去重</li>
</ul>
<h3 id="嵌套运算操作"><a href="#嵌套运算操作" class="headerlink" title="嵌套运算操作"></a>嵌套运算操作</h3><p>如果是想操作一个数组的数组(@[array,array,array])，要怎么样做呢？比如我有两个reconds数组，我想看一共有多少个用户(去重)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSArray *arrayOfArray = @[bank.reconds,bank.reconds];</div><div class="line">NSArray *array = [arrayOfArray valueForKeyPath:@&quot;@distinctUnionOfArrays.name&quot;];</div></pre></td></tr></table></figure>
<p>这里的运算符有三个：</p>
<ul>
<li>@distinctUnionOfArrays</li>
<li>@unionOfArrays</li>
<li>distinctUnionOfSets</li>
</ul>
<h3 id="非对象的values"><a href="#非对象的values" class="headerlink" title="非对象的values"></a>非对象的values</h3><p>当我们获取的是一个非对象的value，比如int、Bool等值，Cocoa会自动转换成NSNumber等对象<br>包括：<br>bool、char、double、float、int、long等等，这个自己去查文档吧</p>
<p>如果value是一个结构体该如何呢？ 比如NSPoint、NSRange、NSRect、NSSize等还是会返回本类，但是其他的结构体，会被返回一个NSValue</p>
<h1 id="检查属性"><a href="#检查属性" class="headerlink" title="检查属性"></a>检查属性</h1><p>当我要使用<code>setValueForKey</code>等方法去修改值时，怎么知道是不是合法呢？<br>KVC也提供了方法</p>
<ul>
<li>validateValue:forKey:error</li>
<li>validateValue:forKeyPath:error</li>
</ul>
<p>这个方法返回一个bool值，有三种情况：</p>
<ol>
<li>value合法，return YES</li>
<li>value不合法，但是可以给value重新赋值了一个新的object，return YES</li>
<li>value不合法，且不可以赋值挽救，return NO</li>
</ol>
<p>最坑人的是，这个方法要自己实现，否则默认返回YES。Are you kidding？ 那我干嘛要用你的这个方法。。。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/njafei/njafei.github.io2017/04/17/ES6-入门-let命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="njafei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="njafei's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="2017/04/17/ES6-入门-let命令/" itemprop="url">
                  《ES6入门》读书笔记之let和const命令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-17T15:37:38+08:00">
                2017-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="categories/React-Native/" itemprop="url" rel="index">
                    <span itemprop="name">React-Native</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>正在读阮一峰的<a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">《ECMAScript 6 入门》</a>,本系列博客都是读书笔记。</p>
<h1 id="ES6-PlayGround"><a href="#ES6-PlayGround" class="headerlink" title="ES6 PlayGround"></a>ES6 PlayGround</h1><p>在介绍具体的内容之前，想给大家介绍一个好玩的playgroud，尤其合适边看书，边敲代码的同学们。<a href="https://google.github.io/traceur-compiler/demo/repl.html#%7B%0A%20%20let%20a%20%3D%201%3B%0A%20%20var%20b%20%3D%200%3B%0A%20%20console.log(a" target="_blank" rel="external">Traceur</a>%3B%0A%7D%0A%0Aconsole.log(b)%3B%0A%0A)<br>这个工具会在你敲完每行代码之后帮你执行检查是否有错误，然后翻译成es5并执行，然后再配合JS控制台，就是很棒的playground了。<br>使用：</p>
<ol>
<li>打开网页</li>
<li>command + option + J打开javascript控制台</li>
<li>在最左边的框里面输入代码，</li>
</ol>
<p>效果如下：<br>左边：写代码的地方  中间：翻译之后的js代码，右边：控制台<br><img src="http://on0hv7n2x.bkt.clouddn.com/es6%20playground.png" alt=""></p>
<h1 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h1><h2 id="作用域和var不同"><a href="#作用域和var不同" class="headerlink" title="作用域和var不同"></a>作用域和var不同</h2><p>ES6中建议全部使用let来生命变量，let和var的作用用法类似，但是let声明的变量，作用域是在其所在的代码块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	var a = 0;</div><div class="line">  	let b = 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(a);</div><div class="line">console.log(b);//ReferenceError： b is not defined</div></pre></td></tr></table></figure>
<p>看起来很简单吧，那我们来看下道题目吧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var a = [];</div><div class="line">for(var i = 0; i&lt; 10 ; i++)&#123;</div><div class="line">  a[i] = ()=&gt;&#123;</div><div class="line">  	console.log(i)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">a[7]();</div></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let b = [];</div><div class="line">for(let i = 0; i&lt; 10 ; i++)&#123;</div><div class="line">  b[i] = ()=&gt;&#123;</div><div class="line">  	console.log(i)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">b[7]();</div></pre></td></tr></table></figure>
<p>答案是：<br>a(7)() : 10<br>b(7)() : 7</p>
<p>你猜对了吗？0_0<br>我第一次看其实是答错了的，然后我把a[7] 和 b[7]打印了出来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function () &#123;</div><div class="line">      console.log(i);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我理解是因为let和var的缘故，所以a[7]里面的i实际是就是一个static的变量，在i++之后变成了10，而b[7]里面的i就是7</p>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>let 不会出现变量提升的现象。<br>首先，我们把let抛一边,看下什么是变量提升。先看个代码，猜猜它的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var a = 5;</div><div class="line">function f()&#123;</div><div class="line">  if(!a)&#123;</div><div class="line">	  a = 100;</div><div class="line">	&#125;</div><div class="line">  console.log(a);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f();</div></pre></td></tr></table></figure>
<p>它的输出结果是多少？</p>
<p>答案： 5，很简单吧，好，我们再看一个相似的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var a = 5;</div><div class="line">function f()&#123;</div><div class="line">  if(!a)&#123;</div><div class="line">	 var a = 100;</div><div class="line">	&#125;</div><div class="line">  console.log(a);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f();</div></pre></td></tr></table></figure>
<p>结果是多少呢？<br>答案是：100</p>
<p>为什么会这样呢？</p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>作为一个一直在使用OC的程序员，想要弄懂JS的作用域，开始会很别扭，因为两者的作用域是基于不同的标准或者模式。在介绍之前，我们先看下两个C和JS的小例子：</p>
<p>C：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main() &#123;</div><div class="line">	int a = 1;</div><div class="line">	printf(&quot;%d&quot;,a); //1</div><div class="line">	&#123;</div><div class="line">		int a = 2;</div><div class="line">		printf(&quot;%d&quot;,a); //2</div><div class="line">	&#125;</div><div class="line">	printf(&quot;%d&quot;,a);/1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JS:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line">console.log(a); // 1</div><div class="line">&#123;</div><div class="line">    var a = 2;</div><div class="line">    console.log(a); // 2</div><div class="line">&#125;</div><div class="line">console.log(a); // 2</div></pre></td></tr></table></figure>
<p>结果不一样了，为什么呢？ 刚才提到C和Js的作用域的模式不一样，C是基于块级的作用域（block-level scope），每个大括号括起来的都可以理解为一个小的作用域，如果变量在小的作用域里声明，那么在小的作用域中是会忽略外部同名的变量。</p>
<p>而在JS中，则是基于函数的作用域，即每个函数都有自己的作用域（function-level scope），所以上述的列子最后的结果就不一致了，在JS的列子中，a的值其实被覆盖。</p>
<p>C,C++,Java都是块级作用域，那么JS中，如何实现类似的效果呢？答案是使用闭包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var a = 0;</div><div class="line">fucntion f()&#123;</div><div class="line">	var a = 1;//1</div><div class="line">	console.log(a);//1</div><div class="line">&#125;</div><div class="line">console.log(a);//0</div></pre></td></tr></table></figure>
<p>在f()这个函数中，会再次定义一个只能在f()中起作用的a,从而实现了类似块级作用域的效果。</p>
<h4 id="变量提升-1"><a href="#变量提升-1" class="headerlink" title="变量提升"></a>变量提升</h4><p>讲完了作用域，我们来看下什么是变量提升，还是先来个列子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a = 0;</div><div class="line">f();</div><div class="line">var b = 1;</div></pre></td></tr></table></figure>
<p>这三行代码在解释器中会变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a , b;</div><div class="line">a = 0;</div><div class="line">f();</div><div class="line">b = 1;</div></pre></td></tr></table></figure>
<p>所有var声明的变量的声明语句，都会被解释器给放到变量所在作用域的顶部。注意，只是把生命语句放到最上面，但是不会把赋值等位置提升，这就是所谓的变量提升。</p>
<p>函数也会有变量提升的现象，但是会根据声明方式的不同，有着不同的结果。创建函数的方法有两个： function f(){} 和 var f = function(){},他们会有什么不同呢？ 我们看下列子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">f1();// TypeError &quot;foo is not a function&quot;</div><div class="line">f2();// will run</div><div class="line"></div><div class="line">var f1 = function()&#123;</div><div class="line">	console.log(&apos;won&apos;t run&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function f2()&#123;</div><div class="line">	console.log(&apos;will run&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码在解释器中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var f1();</div><div class="line">function f2()&#123;</div><div class="line">	console.log(&apos;will run&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f1();// TypeError &quot;foo is not a function&quot;</div><div class="line">f2();// will run</div><div class="line"></div><div class="line">var f1 = function()&#123;</div><div class="line">	console.log(&apos;won&apos;t run&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数的变量提升，如果是<code>fucntion f()</code>的形式，怎会整个函数都提升到顶部，如果是<code>var f() = function(){}</code>的形式，则只会提升<code>var f()</code>到顶部。</p>
<p>如此，本节开头的两个例子就不难理解了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var a = 5;</div><div class="line">function f()&#123;</div><div class="line">  if(!a)&#123;</div><div class="line">	  a = 100;</div><div class="line">	&#125;</div><div class="line">  console.log(a);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f();</div></pre></td></tr></table></figure>
<p>在解释器中是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var a;</div><div class="line">function f()&#123;</div><div class="line">  if(!a)&#123;</div><div class="line">	  a = 100;</div><div class="line">	&#125;</div><div class="line">  console.log(a);</div><div class="line">&#125;</div><div class="line">a = 5;</div><div class="line"></div><div class="line">f();</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var a = 5;</div><div class="line">function f()&#123;</div><div class="line">  if(!a)&#123;</div><div class="line">	 var a = 100;</div><div class="line">	&#125;</div><div class="line">  console.log(a);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f();</div></pre></td></tr></table></figure>
<p>在解释器中是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var a;</div><div class="line">function f()&#123;</div><div class="line">  var a;	 </div><div class="line">  if(!a)&#123;</div><div class="line">	 a = 100;</div><div class="line">	&#125;</div><div class="line">  console.log(a);</div><div class="line">&#125;</div><div class="line">a = 5;</div><div class="line">f();</div></pre></td></tr></table></figure>
<p>而let 关键字是不具备变量提升的，所以它声明的变量，其实就是块级作用域。</p>
<p>最后一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var a = 0;</div><div class="line">let b = 0;</div><div class="line">&#123;</div><div class="line">	var a = 1;</div><div class="line">	let b = 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(a);//1</div><div class="line">console.log(b);//0</div></pre></td></tr></table></figure>
<p>而在ES5中不会报错的先使用再声明的模式，在ES6中用let的话，就会报错了。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">if (true) &#123;</div><div class="line">// TDZ开始</div><div class="line">tmp = &apos;abc&apos;; // ReferenceError</div><div class="line">console.log(tmp); // ReferenceError</div><div class="line">let tmp; // TDZ结束</div><div class="line">console.log(tmp); // undefined</div><div class="line">tmp = 123;</div><div class="line">console.log(tmp); // 123</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以建议如下：</p>
<ul>
<li>ES6中永远使用let</li>
<li>所有变量的声明，都写在函数的顶部</li>
</ul>
<p>这是我在看变量提升的时候，找到一篇质量很棒的blog，本篇的结构和内容也参考了很多<a href="https://segmentfault.com/a/1190000003114255" target="_blank" rel="external">Javascript作用域和变量提升</a></p>
<h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>const的用法和let基本一致，不可重复定义，不会变量提升，作用域是块作用域。</p>
<p>要注意的是，const修饰一个对象的话，只会限定这个对象的地址不变，不会限定它的值不变，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const foo = &#123;&#125;;</div><div class="line">foo.pro = &apos;haha&apos;;//work</div></pre></td></tr></table></figure>
<p>想要值不变的话，可以使用<code>Object.freeze()</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const foo = Object.freeze(&#123;&#125;);</div><div class="line">foo.pro = &apos;haha&apos;;//not work</div></pre></td></tr></table></figure>
<p>如果想将对象全部冻结，要将里面的每个value都冻结：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let constantize = (obj) =&gt; &#123;</div><div class="line">	Object.freeze(obj);</div><div class="line">	Object.keys(obj).forEach((key,value) =&gt; &#123;</div><div class="line">			if (typeof obj[key] === &apos;object&apos; ) &#123;</div><div class="line">				constantize(obj[key]);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	)</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/njafei/njafei.github.io2017/04/17/RN-Crash-Reasons/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="njafei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="njafei's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="2017/04/17/RN-Crash-Reasons/" itemprop="url">
                  RN 最容易crash的代码用法及应对措施（持续更新）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-17T10:37:55+08:00">
                2017-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="categories/React-Native/" itemprop="url" rel="index">
                    <span itemprop="name">React-Native</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="变量保护"><a href="#变量保护" class="headerlink" title="变量保护"></a>变量保护</h2><p>出现最多的就是在使用redux来做数据层，使用this.props的属性没有去查询时候为undefined，这种情况，基本是必crash</p>
<p>比如下例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//show user name</div><div class="line">&lt;Text&gt;&#123;this.props.userInfo.name&#125;&lt;/Text&gt;</div></pre></td></tr></table></figure>
<p>如果userInfo为undefined的话，就会崩溃，错误如下：</p>
<blockquote>
<p>TypeError: Cannot read property ‘name’ of undefined</p>
</blockquote>
<p>在这里name为undefined的时候反而没有问题，因为name是一个简单的属性，直接赋值给Text是没有问题的。</p>
<p>那如何避免这种问题呢？在赋值前加下判断会比较好：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let name = this.props.userInfo &amp;&amp; this.props.userInfo.name ? this.props.userInfo.name : &apos;&apos;;</div><div class="line"></div><div class="line">//show user name</div><div class="line">&lt;Text&gt;&#123;this.props.userInfo.name&#125;&lt;/Text&gt;</div></pre></td></tr></table></figure>
<p>这样基本可以避免崩溃的问题了。</p>
<p>但是如果都这样判断，实际是比较复杂的，所以如果你的业务比较简单，我建议可以直接在render做一个大的保护，即没有数据的时候，不去render这些业务内容.<br>思路如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">render()&#123;</div><div class="line">	if(!this.props.userInfo)&#123;</div><div class="line">		return (</div><div class="line">			&lt;EmptyView /&gt;</div><div class="line">		)</div><div class="line">	&#125; else &#123;</div><div class="line">		return (</div><div class="line">			//注意，如果name的层级更深，还是建议做保护</div><div class="line">			&lt;Text&gt;&#123;this.props.userInfo.name&#125;&lt;/Text&gt;</div><div class="line">		)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>定时器其实在iOS中也是一个非常容易出问题的地方，crash率会比较高。究其原因，我想是主要是因为定时器存在一个事件发生的延后性（废话嘛0_o）,但是很多时候会忘记，当定时任务真的发生的时候，语境变化了吗？如果语境都已经被dealloc了，定时任务仍然被激活，系统就会愤怒地罢工了。</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">componentDidMount() &#123;</div><div class="line">    setTimeout(</div><div class="line">      () =&gt; &#123; console.log(&apos;这就可能会崩溃&apos;); &#125;,</div><div class="line">      500</div><div class="line">    );</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>如果500ms之内，这个component就会Unmount了，那直接回崩溃。RN官方的建议如下：</p>
<h4 id="TimerMixin"><a href="#TimerMixin" class="headerlink" title="TimerMixin"></a>TimerMixin</h4><p>为了解决这个问题，我们引入了TimerMixin。如果你在组件中引入TimerMixin，就可以把你原本的setTimeout(fn, 500)改为this.setTimeout(fn, 500)(只需要在前面加上this.)，然后当你的组件卸载时，所有的计时器事件也会被正确的清除。</p>
<p>这个库并没有跟着React Native一起发布。你需要在项目文件夹下输入npm i react-timer-mixin –save来单独安装它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var TimerMixin = require(&apos;react-timer-mixin&apos;);</div><div class="line"></div><div class="line">var Component = React.createClass(&#123;</div><div class="line">  mixins: [TimerMixin],</div><div class="line">  componentDidMount: function() &#123;</div><div class="line">    this.setTimeout(</div><div class="line">      () =&gt; &#123; console.log(&apos;这样我就不会导致内存泄露!&apos;); &#125;,</div><div class="line">      500</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="代码保护（推荐）"><a href="#代码保护（推荐）" class="headerlink" title="代码保护（推荐）"></a>代码保护（推荐）</h4><p>Mixin属于ES5语法，对于ES6代码来说，无法直接使用Mixin。如果你的项目是用ES6代码编写，同时又使用了计时器，那么你只需铭记在unmount组件时清除（clearTimeout/clearInterval）所有用到的定时器，那么也可以实现和TimerMixin同样的效果。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import React,&#123;</div><div class="line">  Component</div><div class="line">&#125; from &apos;react&apos;;</div><div class="line"></div><div class="line">export default class Hello extends Component &#123;</div><div class="line">  componentDidMount() &#123;</div><div class="line">    this.timer = setTimeout(</div><div class="line">      () =&gt; &#123; console.log(&apos;把一个定时器的引用挂在this上&apos;); &#125;,</div><div class="line">      500</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">  componentWillUnmount() &#123;</div><div class="line">    // 如果存在this.timer，则使用clearTimeout清空。</div><div class="line">    // 如果你使用多个timer，那么用多个变量，或者用个数组来保存引用，然后逐个clear</div><div class="line">    this.timer &amp;&amp; clearTimeout(this.timer);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我今天看了我们项目的代码，发现几乎没有人做保护，代码copy的现象，真的是令人发指，可能很多人都没仔细看过官方的文档。。。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/njafei/njafei.github.io2017/04/11/settingNameAndEmailForEachProject/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="njafei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="njafei's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="2017/04/11/settingNameAndEmailForEachProject/" itemprop="url">
                  如何给同一个电脑上的不同git项目设置不同的name和email
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-11T14:38:15+08:00">
                2017-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="categories/小知识/" itemprop="url" rel="index">
                    <span itemprop="name">小知识</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在自己的电脑上同时使用github和公司的git仓库，带来了一个问题就是之前只是设置了全局的name和email，但是两边的代码需要使用不同的user，每次都要手动去改，然后我搜索了下，发现其实我们可以给每个git项目，单独配置一个name和email的。规则如下：</p>
<blockquote>
<p>如果项目由独立配置，则使用独立配置，如果没有独立配置，则使用全局配置</p>
</blockquote>
<p>命令就很简单了：<br>全局name和email配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name gitaccount</div><div class="line">$ git config --global user.email gitaccount@example.com</div></pre></td></tr></table></figure>
<p>给单独的git项目设定配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cd gitFolder</div><div class="line">$ git config user.name gitaccount</div><div class="line">$ git config user.email gitaccount@example.com</div></pre></td></tr></table></figure>
<p>这样，如果本地有多个git user 或者多个项目的话，使用起来就比较方便了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/njafei/njafei.github.io2017/04/06/React-Native-Seperate-Bundle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="njafei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="njafei's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="2017/04/06/React-Native-Seperate-Bundle/" itemprop="url">
                  React_Native拆分bundle之patch拆包
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-06T10:26:41+08:00">
                2017-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="categories/React-Native/" itemprop="url" rel="index">
                    <span itemprop="name">React-Native</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="为什么要拆包"><a href="#为什么要拆包" class="headerlink" title="为什么要拆包"></a>为什么要拆包</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>随着RN的包越来越大，第一次载入RN包的时长越来越长，用户需要等待的时间也就越长，体验较差。另外多个团队开发的话，互相之间的依赖也是个大问题，出现编译不过的话，就会出现水桶效应，所有的团队都要等待这个有问题的团队，从而拉低了整体的效率。</p>
<p>另外我一直希望，能够将React-Native的业务功能，做成类似小程序一样：即用即载入，随时可以更新。想想我们的app里面包含了多少个用户也许永远用不到的功能，还有当我们希望上一个新功能的时候，一定要等待新的版本的审核，这给运营等带来了巨大的麻烦和风险。如果用户点击某个功能，然后马上载入线上的webBundle，用户之后就可以直接使用我们的最新功能了，以后再次进入的时候，也无需等待，那该多好。</p>
<h2 id="拆包目标"><a href="#拆包目标" class="headerlink" title="拆包目标"></a>拆包目标</h2><p>所以我们拆包的目标就很明确了：</p>
<pre><code>1. 优化载入时间，提高用户体验
2. 解开依赖关系，提高开发效率
3. 实现webBundle，即用即载入
</code></pre><p>示意图如下：<br><img src="http://on0hv7n2x.bkt.clouddn.com/React-Native%E6%8B%86%E5%8C%85%E6%96%B9%E6%A1%88%E7%BB%93%E6%9E%84%E5%9B%BE.jpeg" alt=""></p>
<h2 id="国外国内app拆包情况"><a href="#国外国内app拆包情况" class="headerlink" title="国外国内app拆包情况"></a>国外国内app拆包情况</h2><p>上面啰嗦了为什么想要去拆包，好像是蛮有必要的O_o。但是当我去看国内外著名的app使用React-Native的情况时，发现真的是泾渭分明：国内基本都拆包了，包括携程、QQ音乐等，而国外没有拆包的，比如React-Native的创造者FaceBook，虽然他们的包大小已经到了10M。</p>
<p>不禁让我很疑惑，难道国外没有这个需求么？为什么拆包和热更新等几乎国内的硬需求，他们却好像完全没有这方面的需求。希望有读者知道的话可以告知我~</p>
<h1 id="拆包的几种方案"><a href="#拆包的几种方案" class="headerlink" title="拆包的几种方案"></a>拆包的几种方案</h1><p>在讲具体的方案之前，我们先看下，React-Native的包，究竟是如何打出来，然后是怎么载入到native中的。</p>
<h2 id="如何打包"><a href="#如何打包" class="headerlink" title="如何打包"></a>如何打包</h2><p>这里我直接使用QQ技术团队的一张图：<br><img src="http://on0hv7n2x.bkt.clouddn.com/React-NativeJsBundle%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B" alt=""></p>
<h2 id="如何载入"><a href="#如何载入" class="headerlink" title="如何载入"></a>如何载入</h2><p>这里主要讲下iOS React-Native0.39版本的情况。<br>RN提供了两种形式来载入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1. - (NSURL *)sourceURLForBridge:(RCTBridge *)bridge</div><div class="line">2. - (void)loadSourceForBridge:(RCTBridge *)bridge</div><div class="line">                 onProgress:(RCTSourceLoadProgressBlock)onProgress</div><div class="line">                 onComplete:(RCTSourceLoadBlock)loadCallback;</div></pre></td></tr></table></figure>
<p>第一种数据是默认模式，第二种是可以控制载入中的各个步骤。这块可以看下RCTBridgeDelegate。</p>
<h2 id="主流方案"><a href="#主流方案" class="headerlink" title="主流方案"></a>主流方案</h2><p>在网上查了相关的资料，主流的方案基本都是把Main.jsbundl拆分成基础包common.jsbundle+业务包bundle，和上面拆包目标基本一样，不赘述。</p>
<p>具体的拆分思路就很不一样了：</p>
<pre><code>1. 侵入RN代码，修改打包流程，使得打出来的包就是基础+业务包，如QQ音乐
2. 在RN打包的基础上，实现新的打包方案，如携程 moles-Packer
3. Patch方案，打包流程不变，生成基础包后，根据diff来生成每个业务不同的patch包
</code></pre><h1 id="patch方案"><a href="#patch方案" class="headerlink" title="patch方案"></a>patch方案</h1><p>因为方案1和方案要随着RN的升级，不断调整，成本比较高，而且要投入较多的人力，所以我们先看下方案3。</p>
<p>先说下patch，patch就是根据特定算法，讲两个不同的事物diff比较，然后生成的包含两个事物差别的包。我们这里使用的是google的<code>diffAndPatch</code>算法。</p>
<p><img src="http://on0hv7n2x.bkt.clouddn.com/React-Native%E7%94%9F%E6%88%90%E5%8C%85.png" alt=""></p>
<h2 id="基础包common-jsbundle"><a href="#基础包common-jsbundle" class="headerlink" title="基础包common.jsbundle"></a>基础包common.jsbundle</h2><p>首先我们先生成基础包common.jsbundle.这里我们写一个空的js文件，只包含react-native头文件common.ios.js：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import React from &apos;react&apos;; </div><div class="line">import &#123;&#125; from &apos;react-native&apos;;</div></pre></td></tr></table></figure>
<p>然后我们基于这单个文件打包，打出来的包就是只包含react-native基础框架的bundle，我们成为common.jsbundle.</p>
<p>注：</p>
<p>RN打包过程中会做混淆，所有的类最终都变成了代号为数字的function，所以这里顺序就非常重要，而对基础包的引用顺序就要严格和common.ios.js一样了，这里建议所有的业务代码直接引用common.ios.js文件。另外如果有公共组件等，也都可以放到common.ios.js文件中，这样就会被包含在基础包中了。</p>
<h2 id="业务包-business-patch"><a href="#业务包-business-patch" class="headerlink" title="业务包 business.patch"></a>业务包 business.patch</h2><p>每条业务线的代码，都需要单独维护自己的indexBisiness.js,打包的时候，入口文件就是这个index，这样就打出来了一个业务business.bundle。<br>然后使用diff，计算出业务patch。这样就算出了patch，我们叫做business.patch</p>
<h2 id="native方案"><a href="#native方案" class="headerlink" title="native方案"></a>native方案</h2><p>现在我们已经有了common.jsbundle + bisiness1.patch + business2.patch + …<br>如果打开了bisiness1中的home.js，我们首先要将common.jsbundle和bisiness1.patch使用算法合并，计算出最终bisiness1.jsbundle.然后通过上面讲到的native载入方案载入具体的bundle。</p>
<p>根据当前的bridgeName生成bisiness bundle</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">- (NSString *)getNewBundle</div><div class="line">&#123;</div><div class="line">  </div><div class="line">  NSString *commonBundlePath = [[NSBundle mainBundle] pathForResource:@&quot;common&quot; ofType:@&quot;jsbundle&quot;];</div><div class="line">  NSString *commonBundleJSCode = [[NSString alloc] initWithContentsOfFile:commonBundlePath encoding:NSUTF8StringEncoding error:nil];</div><div class="line">  </div><div class="line">  NSString *patch1Path = [[NSBundle mainBundle] pathForResource:self.bridgeName ofType:@&quot;patch&quot;];</div><div class="line">  NSString *patch1JSCode = [[NSString alloc] initWithContentsOfFile:patch1Path encoding:NSUTF8StringEncoding error:nil];</div><div class="line">  </div><div class="line">  </div><div class="line">  DiffMatchPatch *diffMatchPatch = [[DiffMatchPatch alloc] init];</div><div class="line">  NSArray *convertedPatches = [diffMatchPatch patch_fromText:patch1JSCode error:nil];</div><div class="line">  </div><div class="line">  NSArray *resultsArray = [diffMatchPatch patch_apply:convertedPatches toString:commonBundleJSCode];</div><div class="line">  NSString *resultJSCode = resultsArray[0]; //patch合并后的js</div><div class="line">  </div><div class="line">  </div><div class="line">  NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</div><div class="line">  NSString *docDir = [paths objectAtIndex:0];</div><div class="line">  NSString *newPath = [NSString stringWithFormat:@&quot;%@/%@.jsbundle&quot;,docDir,self.bridgeName];</div><div class="line">  </div><div class="line">  if (resultsArray.count &gt; 1) &#123;</div><div class="line">    [resultJSCode writeToFile:newPath atomically:NO encoding:NSUTF8StringEncoding error:nil];</div><div class="line">    return newPath;</div><div class="line">  &#125;</div><div class="line">  else &#123;</div><div class="line">    return @&quot;&quot;;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>加载bisiness bundle：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge</div><div class="line">&#123;</div><div class="line">    NSString *path = [[NSBundle mainBundle] pathForResource:self.bridgeName ofType:@&quot;jsbundle&quot;];</div><div class="line">    NSURL *jsBundleURL = [NSURL URLWithString:path];</div><div class="line">  </div><div class="line">  return jsBundleURL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，code就基本完成了。如果想看所有的代码，请看底部的githubDemo</p>
<h2 id="方案优缺点"><a href="#方案优缺点" class="headerlink" title="方案优缺点"></a>方案优缺点</h2><p>优点：</p>
<pre><code>1. 技术方案简单，实现快
2. 稳定、不用担心RN升级问题
3. 业务互相独立
4. 方便后面做web bundle
</code></pre><p>缺点：</p>
<pre><code>1. 内存占用大
2. 打包会变大
3. 业务之间资源和代码没法互相引用
</code></pre><h2 id="优化和拓展计划"><a href="#优化和拓展计划" class="headerlink" title="优化和拓展计划"></a>优化和拓展计划</h2><pre><code>1. 打包可以不用patch的方案，采用脚本逐行写入
2.web bundle 可以直接基于这个方案做
3.如果解决了函数命名和依赖的问题，就可以采用一个bundle策略
</code></pre><h2 id="Demo-in-github"><a href="#Demo-in-github" class="headerlink" title="Demo in github"></a>Demo in github</h2><p><a href="https://github.com/njafei/ReactNativeSeperateBundle">ReactNativeSeperateBundle</a></p>
<ol>
<li>cd ReactNativeSeperateBundle</li>
<li>npm install</li>
<li>run project</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="page/2/">2</a><a class="extend next" rel="next" href="page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="njafei" />
          <p class="site-author-name" itemprop="name">njafei</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="https://njafei.github.io/archives">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="https://njafei.github.io/categories">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="https://njafei.github.io/tags/">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">njafei</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
