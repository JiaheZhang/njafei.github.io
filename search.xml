<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端生命周期设计思考]]></title>
    <url>%2F2018%2F06%2F06%2FlifeCycleDesignThought%2F</url>
    <content type="text"><![CDATA[这两天在设计完善框架的生命周期，所以当我回头去看之前写过的iOS和react-native的代码时，我不禁产生了疑问，之前用的这么多的生命周期的函数，为什么是这样设计的？每个生命周期用来做什么比较合适？比如react-native中想要去请求接口，是在componentWillMount还是在componentDidMount中更合适的？为什么？查了一些资料，结合我的经验思考，遂有此文。 生命周期主要讲的就是前端页面从生成-渲染-更新-销毁等几个阶段的过程，框架一般会提供该过程的回调和可用参数，提供给用户使用。只有了解清楚生命周期中每个阶段做的事情和状态后，我们才能因地制宜，写出更优雅的代码。 下面我们来通过对比看下iOS和react中生命周期，看看生命周期究竟是怎么设计的，为什么不同的框架的生命周期不太一样呢 iOSiOS的文档核心是将页面的状态分成四种，生命周期的不同阶段就是围绕这四种状态的变化： Appearing 正在绘制 Appeared 已绘制 Disappearing 正在销毁 Disappeared 已销毁 状态变化如下图所示： iOS生命周期 123456789ViewDidLoad - Called when you create the class and load from xib. Great for initial setup and one-time-only work.ViewWillAppear - Called right before your view appears, good for hiding/showing fields or any operations that you want to happen every time before the view is visible. Because you might be going back and forth between views, this will be called every time your view is about to appear on the screen.ViewDidAppear - Called after the view appears - great place to start an animations or the loading of external data from an API.ViewWillDisappear/DidDisappear - Same idea as ViewWillAppear/ViewDidAppear.ViewDidUnload/ViewDidDispose - In Objective C, this is where you do your clean-up and release of stuff, but this is handled automatically so not much you really need to do here. react 生命周期react的文档中，是根据行为来分类生命周期的： 渲染相关 更新相关 销毁渲染相关 其他 12345678910111213141516171819202122#Moutingconstructor()static getDerivedStateFromProps()componentWillMount() / UNSAFE_componentWillMount()render()componentDidMount()#UpdatingcomponentWillReceiveProps() / UNSAFE_componentWillReceiveProps()static getDerivedStateFromProps()shouldComponentUpdate()componentWillUpdate() / UNSAFE_componentWillUpdate()render()getSnapshotBeforeUpdate()componentDidUpdate()#UnmountingcomponentWillUnmount()#Error HandlingcomponentDidCatch() 可以注意到，两个框架的生命周期设计是不同的，我认为这种不同更多是来源于设计思想的不同，react使用DOM和Virtual DOM，所以而DOM的刷新是根据props和state来驱动的，可以理解为数据驱动，所以过程中会多一个些props和state的相关函数。而iOS的渲染是偏向于编码控制每个地方的变化，所以生命周期主要关注页面的生成和销毁，而不太关心中间页面的更新（因为页面更新是代码主动控制的）。 比较完iOS和react，生命周期究竟该怎么设计，重点就是根据你的框架的设计方案，把影响到你页面刷新的步骤提炼出来，设计成不同周期，最终目的地是让你的框架更好用，使用方能更好地理解你的框架，从而写出更优雅的代码。 参考文章 关于软件的生命周期 Where to Fetch Data: componentWillMount vs componentDidMount react 生命周期 controller 生命周期[swift]]]></content>
      <categories>
        <category>frame</category>
      </categories>
      <tags>
        <tag>lifeCycle</tag>
        <tag>frame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的包管理工具 npm rvm brew gem]]></title>
    <url>%2F2018%2F06%2F06%2FpackageaManagerTools%2F</url>
    <content type="text"><![CDATA[工作中用到了很多的包管理工具，这里做个总结和维护，以便快速查找和记录踩过的坑 npm 管理js package官网地址： www.npmjs.com.cn 常用命令安装包：npm install npm@version -g. version : latest/next/1.0.0 卸载包：npm uninstall npm@version -g. -g, 全局安装，可以在任何目录下使用该包 常见错误和解决rvm 管理ruby版本官网地址：ruby-china` mac上面是默认安装了ruby的，但是不同的软件或者工具对于版本的要求不一致，所以一般使用rvm的ruby来代替 常用命令安装rvm 1234567$ gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3$ \curl -sSL https://get.rvm.io | bash -s stable$ source ~/.bashrc$ source ~/.bash_profile&lt;!--修改ruby包源到ruby-china上面，以提高网络速度--&gt;echo &quot;ruby_url=https://cache.ruby-china.org/pub/ruby&quot; &gt; ~/.rvm/user/db 安装ruby: rvm install 2.2.0 选择ruby版本： rvm use 2.2.0 将命令行中的ruby换成rvm的： rvm use 2.2.0 --default 查询所有的ruby版本： rvm list 卸载已安装版本： rvm remove 1.8.7 brew 使用 Homebrew 安装 Apple 没有预装但 你需要的东西。官网： brew.sh 常用命令安装 Homebrew: /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装包： brew install卸载包： brew uninstall 常见问题及解决gem ruby package管理工具官网： rubygems.org 常用命令安装包： gem install卸载包： gem uninstall 常见问题及解决]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URL协议详解]]></title>
    <url>%2F2018%2F03%2F23%2FURL%2F</url>
    <content type="text"><![CDATA[我们目前使用的诸如：http://www.baidu.com或者ftp://192.168.1.1等链接，都是URL标准的一个实例。URL全称Uniform Resource Locators(通用资源定位器),标注名称为rfc1738。 URL的组成部分1&lt;scheme&gt;:&lt;scheme-specific-part&gt; URL被冒号分成了两部分，前面是scheme(方案)，后面是scheme的描述部分 schemescheme只能由以下元素组成： 123a-z(不区分大小写)数字字符： 加号+ 句号. 连字符- shceme目前有这些类型： 123456789101112 ftp File Transfer protocol（文件传输协议） http Hypertext Transfer Protocol（超文本传输协议） gopher The Gopher protocol（Gopher协议） mailto Electronic mail address（电子邮件地址） news USENET news（USENET新闻） nntp USENET news using NNTP access （使用NNTP访问的USENET新闻） telnet Reference to interactive sessions（交互式会话访问） wais Wide Area Information Servers（广域信息服务系统） file Host-specific file names（特殊主机文件名） prospero Prospero Directory Service(prospero目录服务) 当然，上述的scheme大部分是应用非常广泛的，我们可以自定义scheme，只要解析器支持即可，比如我们公司就根据URL设计了一条App跳转专用的URL，方便服务器分发跳转路径。 scheme描述部分scheme的描述部分也可以拆解成以下的结构： 1&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;url-path&gt; 根据方案的不同，这些部分是可以部分省略的，比如http通常不需要user和password 我们来依次看这些组成部分： user这个比较好理解，就是用户名，没有则省略 password用户密码 hosthost(主机)是一个IP地址，由四组十进制数字以.分割组合而成。现在很多对客的地址都是用了域名，然后再通过DNS解析.DNS可以理解为将难以记住的ip地址和单词等组成的域名做映射，从而方便用户的使用。记住https://www.baidu.com可比记住192.292.22.22容易多了。很多的公司在使用的时候也会做DNS优化，即客户端等发出请求的时候，直接向对应的ip发送，从而节省DNS解析的时间，加快用户访问速度，有兴趣的可以网络搜索下。 portport(端口)是用来区分不同的网络服务的，从而实现在一个IP的基础上，提供多个网络服务。 url-pathurl路径提供了如何对特定资源访问的详细信息，一般都是文件夹的路径 URL编码URL会使用编码，因为很多字符是不安全的，比如空格，在被转录或者排版的时候，可能会被忽略。”&lt;”和”&gt;”也是不安全的，因为他们被用来作为URL在文本中的分割符。#,/,~,[,]等也都会在不同的场景下给URL的解析带来问题，所以要对不安全的字符进行编码。通常是进行ecode。 总结，本文介绍了URL的组成部分，各部分的用法和使用场景，URL的编码原因等知识。 参考文档： rfc1738 RFC1738 - 统一资源定位器URL]]></content>
      <categories>
        <category>底层协议知识</category>
      </categories>
      <tags>
        <tag>URL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node学习 Lesson1 使用express]]></title>
    <url>%2F2018%2F03%2F23%2FNodeLearnLession1%2F</url>
    <content type="text"><![CDATA[初始化项目： 1npm init 安装express，安装有两个方法 1npm install express --save //方法一：直接安装，并将配置保存在package.json 或者 12修改package.josn,增加express及版本信息npm install 创建文件app.js 12touch app.jsopen app.js 写入代码： 1234567891011var express = require(&apos;express&apos;);var app = express();app.get(&apos;/&apos;,function(req, res)&#123; res.send(&apos;hello world&apos;);&#125;);app.listen(3000, function ()&#123; console.log(&apos;app is listening ar port 3000&apos;);&#125;) 执行node： 1node app.js 在浏览器输入localhost:3000，看到上面有打印： 1hello,world 课程地址：《一个最简单的 express 应用》]]></content>
      <categories>
        <category>NodeLearn</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>NodeLearn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nvm安装、解决nvm command not found问题、卸载]]></title>
    <url>%2F2018%2F03%2F23%2Fnvm-install%2F</url>
    <content type="text"><![CDATA[安装nvm是node的包版本管理工具，github地址如下：nvm 安装命令 1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash 123nvm //检查nvm是否安装成功-bash: nvm: command not found //boom，失败了 解决nvm command not found问题进入.nvm文件夹，新建.bash_profile： 12touch .bash_profile //新建文件open .bash_profile //打开文件 在里面copy如下内容： 12export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 关闭文件，然后执行这个文件： 1source .bash_profile 执行完毕，我们再看看是否安装成功： 1nvm --version 输出： 10.33.8 安装成功。 卸载：12$ nvm use system$ npm uninstall -g a_module]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>nvm</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS module输出原理]]></title>
    <url>%2F2018%2F03%2F22%2FnodeJS-module%2F</url>
    <content type="text"><![CDATA[module输出写法为了能够复用一些基本功能，我们通常会将其封装在module中。类似这样子： 12345678910//greet.js&apos;use strict&apos;;var s = &apos;Hello&apos;;function greet(name) &#123; console.log(s + &apos;, &apos; + name + &apos;!&apos;);&#125;module.exports = greet; 我们也会看到其他的写法，这样的： 123&apos;use strict&apos;;exports.foo = &apos;foo&apos;; 直接通过exports的属性来输出的，这样看起来其实很迷惑人，比如我第一次就有疑惑： module不是模块的意思吗？ 为什么要使用module.exports的赋值来输出？ 为什么有时候是exports来赋值输出 其他的地方，是如何使用我的模块呢？ 为什么export有些可以输出多个值呢? 比如： modelu.exports = {foo: foo, tool: tool} 原理这里其实是module在默默地做了一些事情，它会在代码中植入类似这样的代码： 12345678var module = &#123; id: &apos;greet&apos;, exports: &#123;&#125;,&#125;exports = moduel.exports;load(module.exports, module); 这样，我们就知道了为什么exports和module.exports都可以作为模块的输出。 这里还要一个要注意的，之所以可以用exports来输出，是因为它指向了module.exports. 所以当exports的指针被修改的时候，这样用就会出问题了。 如果输出是一个数组，或者函数，则两者是不等价的，看下面的例子： 例子一： 等价的输出 123module.exports = &#123;foo: &apos;foo&apos;&#125;;exports.foo = &apos;foo&apos;; 例子而： 不等价输出 123456module.exports = function greet()&#123;console.log(&apos;greet&apos;)&#125;;//这时 module.exports指向greet函数exports = function greet()&#123;console.log(&apos;greet&apos;)&#125;;//这时，exoprts的指针指向greet函数，而module.exports仍然指向&#123;&#125;这里两种方式不等价，主要是因为原来都指向同一个变量，而如果赋值是数据，函数等，则export会改变指针的值。然后最终输出的还是module.exports， 所以在这里，模块的输出就不可以用export 廖雪峰的博客说是建议全部使用module.exports，这样可以避免混淆。我的建议是大家最好搞清楚原理，这样使用起来才知其所以然。 ok，总结这篇文章，主要是讲了模块(module)的输出原理，为什么有两种写法，为什么每种写法都可以work，两种写法的区别和使用时机。 引用 廖雪峰 JS教程-模块 exports 和 module.exports 的区别]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 静态类型检查 PropTypes]]></title>
    <url>%2F2018%2F03%2F20%2FJS-PropTypes%2F</url>
    <content type="text"><![CDATA[基本用法JS作为弱类型语言，有时候也会带来很多麻烦，比如需要的参数是Number，而使用方传了String，虽然我们可以通过参数的检查来return掉，但是这样也带来了很多繁琐的步骤。为了避免类似的问题，JS提供了类型检查工具PropTypes，在React V15.5之前，可以直接使用React.PropTypes助手函数，之后则提供了npm包prop-types。 注意，处于性能原因，propTypes仅会在dev模式中work，如果发现类型和定义的不一致，会通过warning来提示。 以下是官网的例子，基本上够用了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import PropTypes from &apos;prop-types&apos;;MyComponent.propTypes = &#123; // 你可以声明一个 prop 是一个特定的 JS 原始类型。 // 默认情况下，这些都是可选的。 optionalArray: PropTypes.array, optionalBool: PropTypes.bool, optionalFunc: PropTypes.func, optionalNumber: PropTypes.number, optionalObject: PropTypes.object, optionalString: PropTypes.string, optionalSymbol: PropTypes.symbol, // 任何东西都可以被渲染:numbers, strings, elements,或者是包含这些类型的数组(或者是片段)。 optionalNode: PropTypes.node, // 一个 React 元素。 optionalElement: PropTypes.element, // 你也可以声明一个 prop 是类的一个实例。 // 使用 JS 的 instanceof 运算符。 optionalMessage: PropTypes.instanceOf(Message), // 你可以声明 prop 是特定的值，类似于枚举 optionalEnum: PropTypes.oneOf([&apos;News&apos;, &apos;Photos&apos;]), // 一个对象可以是多种类型其中之一 optionalUnion: PropTypes.oneOfType([ PropTypes.string, PropTypes.number, PropTypes.instanceOf(Message) ]), // 一个某种类型的数组 optionalArrayOf: PropTypes.arrayOf(PropTypes.number), // 属性值为某种类型的对象 optionalObjectOf: PropTypes.objectOf(PropTypes.number), // 一个特定形式的对象 optionalObjectWithShape: PropTypes.shape(&#123; color: PropTypes.string, fontSize: PropTypes.number &#125;), // 你可以使用 `isRequired&apos; 链接上述任何一个，以确保在没有提供 prop 的情况下显示警告。 requiredFunc: PropTypes.func.isRequired, // 任何数据类型的值 requiredAny: PropTypes.any.isRequired, // 你也可以声明自定义的验证器。如果验证失败返回 Error 对象。不要使用 `console.warn` 或者 throw ， // 因为这不会在 `oneOfType` 类型的验证器中起作用。 customProp: function(props, propName, componentName) &#123; if (!/matchme/.test(props[propName])) &#123; return new Error( &apos;Invalid prop `&apos; + propName + &apos;` supplied to&apos; + &apos; `&apos; + componentName + &apos;`. Validation failed.&apos; ); &#125; &#125;, // 也可以声明`arrayOf`和`objectOf`类型的验证器，如果验证失败需要返回Error对象。 // 会在数组或者对象的每一个元素上调用验证器。验证器的前两个参数分别是数组或者对象本身， // 以及当前元素的键值。 customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123; if (!/matchme/.test(propValue[key])) &#123; return new Error( &apos;Invalid prop `&apos; + propFullName + &apos;` supplied to&apos; + &apos; `&apos; + componentName + &apos;`. Validation failed.&apos; ); &#125; &#125;)&#125;; 默认值指定除了能指定参数的类型，还可以指定参数的默认值： 123456789101112131415161718class Greeting extends React.Component &#123; render() &#123; return ( &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; ); &#125;&#125;// 指定 props 的默认值：Greeting.defaultProps = &#123; name: &apos;Stranger&apos;&#125;;// 渲染为 &quot;Hello, Stranger&quot;:ReactDOM.render( &lt;Greeting /&gt;, document.getElementById(&apos;example&apos;)); 只有当指定的props为undefined的时候，才会使用默认值，如果参数有，但是不符合类型检查，也会使用该参数，而不是使用默认值。 propTypes 的类型检测是在defaultProps 解析之后发生的，因此也会对默认属性 defaultProps 进行类型检测。 整体流程整体是这样的流程： 123456789101112131415//step1 check defaultPropsif (参数为undefined)&#123; if (有默认值)&#123; 使用默认参数 &#125; else &#123; 使用undefined &#125;&#125;//step2 check typeif (不符合类型检查)&#123; 警告（） &#125; 使用该参数值&#125; 如果需要更强大的拓展，可以使用Flow 或者 TypeScript。 参考 使用 PropTypes 进行类型检查 prop-types Flow TypeScript]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>PropTypes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS Event-Loop]]></title>
    <url>%2F2018%2F03%2F19%2FJS-EventLoop%2F</url>
    <content type="text"><![CDATA[最近在看JavaScript的Generator、Promise等实现异步的方法。对于一直用Objective-C编程的我来说，是有些云里雾里。故查了些资料，了解相关的内容，遂有此文。 为什么JavaScript是单线程的语言首先，我们要解释下，JS是单线程的，并不是说JS中只有一个线程，而是在JS引擎中负责解释和执行JS语句的线程只有一个，我们称之为主线程。 在JS中，还是有很多其他线程存在的，比如：处理DOM事件的线程，定时器线程，IO线程等。 为什么JS中只有一个线程呢？ 这里要说下JS诞生的背景，它是浏览器中执行脚本的语言，主要用途是和用户交互，为了提升体验，避免多线程带来的同步等问题，简化整个模型，采用了单线程。（Objective-C也是为了交互而生，但是并没有采用单线程，而是支持多线程，我个人觉得这个更多是设计思想的选择，而JS这样设计确实带来了更简单的模式） 在HTML5中，提出了Web Worker标准，允许JS创建多个线程,但是规定子线程受主线程控制，且不能操作DOM。 JS任务管理我们先看一张图，了解下JS中是如何管理和执行任务的： 这里分为三个区域： 执行栈（主线程） 任务队列（其他线程） 堆 （对象） 主线程任务执行栈 主线程的任务使用栈来实现任务执行和调用，这里用栈是因为栈的结构方便实现函数调用顺序的管理。 这里简单举个例子： 12345678910 let funcA = (x) =&gt; &#123; return x * 2;&#125;let funcB = (x) =&gt; &#123; return x + 2;&#125;console.log(funcB(funcA(2))); 栈中执行顺序就是 funcA funcB console.log 任务队列每当遇到需要异步执行的任务（请求网络、IO等），JS不会阻塞等待结果，而是往下面执行，当异步的任务执行了之后，系统发送通知出来，然后等待主线程任务栈执行完毕后，执行这些异步回调。 流程如图,就是所谓的Event Loop 注意，这里即使异步的任务很快执行完毕，也会等到执行栈中的任务执行完毕后，才执行，这里用setTimeout来举个例子： 123console.log(1);setTimeout(()=&gt;&#123;console.log(2)&#125;,0)console.log(3); 这里虽然延迟是0ms，但是输出依然是： 123132 所以setTimeout等的延迟时间，其实是不准确的，如果主线程一直很忙，是不会执行到的。 堆这里堆就是用来管理系统中的对象，大部分的语言应该都是使用堆来管理对象（我知道的），这里就不多解释。 总结这篇文章主要是介绍了JS为什么采用了单线程的思想，然后介绍了JS中是如何任务管理是如何通过主线程+任务队列的方式来实现，从而实现了Event Loop。 参考内容： 并发模型与事件循环 JavaScript 运行机制详解：再谈Event Loop JavaScript：彻底理解同步、异步和事件循环(Event Loop)]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之Map]]></title>
    <url>%2F2018%2F02%2F28%2FES6-Map%2F</url>
    <content type="text"><![CDATA[基本用法在js中，对象(Object)的本质是键值对，但是它的键只能是字符串，这带来了很多不便。为了解决这个问题，ES6中提供了新的数据结构，Map。 Map和Object最大的区别就是它的key可以是对象。 看下初始化： 1234let map = new Map();let obj = [&quot;a&quot;, &quot;b&quot;];map.set(obj, &quot;content&quot;);map.get(obj);// &quot;content&quot; map还可以用数组为参数直接初始化，要求数组中的元素都是标志键值对的数组 1let map = new Map([[&quot;key1&quot;, &quot;value1&quot;],[[&quot;key2&quot;], &quot;value2&quot;]]); 注意事项因为map和object是如此的相似，本文不再介绍set、get、has、遍历等方法，需要的话直接看下官网API即可。这里提下注意事项，因为key可以是对象了，所以如果key是对象，map寻找key依据key的内存地址，如果是简单类型，还是根据值。 看下例子： 12345678910let map = new Map();let key3 = [&quot;a&quot;];map.set(&quot;a&quot;,1);map.set([&quot;a&quot;],1);map.set(key3,1);console.log(map.get(&quot;a&quot;)); // 1 console.log(map.get([&quot;a&quot;])); // undefinedconsole.log(map.get(key3)); // 1 weakMapweakMap和weakSet有相似之处，都是为了防止内存泄露而设计，key必须是对象，也只对元素弱引用。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之Set]]></title>
    <url>%2F2018%2F02%2F28%2FES6-Set%2F</url>
    <content type="text"><![CDATA[在ES6中，提供了新的数据结构set，set类似于数组，但是其中的元素是不能重复的。我们先来看个例子： 初始化12345let set = new Set();[1,2,2,3,4,5,5,5].map(x =&gt; set.add(x));console.log(set.size); //5 初始化也可以接受数组为入参 1let set = new Set([1,2,3,4]); 刚才讲到，set中所有的元素是不能重复的，那么，怎么定义重复呢？set使用的方法类似于 ===，只有一个特例，NaN, 精确相等任务NaN不等于自身，而set中认为是相等的。 看几个例子，就一目了然了： 12345678910111213let set = new Set([&quot;a&quot;, &quot;a&quot;]);console.log(set.size); //1let set = new Set([&#123;&#125;,&#123;&#125;]);console.log(set.size); //2let a = &#123;key: &apos;a&apos;&#125;;let b = &#123;key: &apos;b&apos;&#125;;let set = new Set([a,a]);console.log(set.size); //1let set = new Set([a,&#123;a&#125;]);console.log(set.size); //2 属性属性有两个： construct 默认是Set函数 size, 即set中元素的数量 方法set有四个操作方法： add() 返回set本身 delete() 返回删除是否成功的布尔值 has() 返回set中是否某个元素 clear() 情况set，没有返回值 这里要注意的是，delete和has中判断两个元素是否相同的方法和初始化中的方法一致，所以尤其要注意对象的判断，基本类型基本不会有问题。 set有四个遍历方法： keys(): 返回所有的key values(): 返回所有的value entries(): 返回所有的键值对 forEach(): 回调函数遍历， 和数组用法一致 因为set中本身没有key，value之分，所key和value都是set中元素本身，我们来看下例子： 123456let set = new Set([&quot;key1&quot;, &quot;key2&quot;, &quot;key3&quot;]);console.log(set.keys());//[&quot;key1&quot;, &quot;key2&quot;, &quot;key3&quot;]console.log(set.values());//[&quot;key1&quot;, &quot;key2&quot;, &quot;key3&quot;]console.log(set.entries());//[&#123;&quot;key1&quot;: &quot;key1&quot;&#125;,&#123;&quot;key2&quot;: &quot;key2&quot;&#125;,&#123;&quot;key3&quot;: &quot;key3&quot;&#125;] weakSetweakSet和set类似，只有两个区别： 元素只能是对象 对象都是弱引用，即js的垃圾回收机制不会考虑weakSet中的引用 因为第一个特点，所以weakSet不能使用遍历、size等方法和属性(因为遍历的时候可能对象已经被释放了) 用法set可以用来实现去重等功能，比如： 12345let array = [1,2,2,3];let set = Set(array);let newArray = Array.from(set);console.log(newArray); //[1,2,3] weakSet在互联网上找到的内容不多，阮一峰的《ES6标准入门》中提到，可以用来保存DOM节点，而不用担心节点移除时引起内存泄露。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ipa包逆向重新签名打包]]></title>
    <url>%2F2018%2F02%2F27%2Fipa-recodesign%2F</url>
    <content type="text"><![CDATA[在使用了rn之后，我们很少会修改原生代码，但是如果想要打包，还是重新打包原生代码，挺花时间的，那么，只修改rn的代码情况下，有没有快速出包的方法？ 答案就是今天这篇文章的主题，ipa逆向，然后替换资源，重新打包，这样只需要替换掉js的bundle包，省去了重新archive的时间了。 过程如下： test.ipa 改名为 test.zip 解开zip，打开Payload，显示test资源包，右键显示报内容，就会看到ipa中所有的资源等内容 找到并复制entitlements.plist文件，这个文件是重新签名的时候要使用的，其中记录的是app需要申请的权限 替换你想替换的资源，这里就是rn的bundle.js 确定你想使用的签名证书的名称，通常是：‘iPhone Distribution: Test Company’ 重签名 codesign -f -s &quot;iPhone Distribution: Test Company&quot; --entitlements entitlements.plist Payload/Test.app 将签名之后的文件夹压缩 zip -r Test.ipa Payload 其他用法： 这里讲的替换资源是重签名打包的一种用法，我在网上搜索的时候，发现其他人也生出了很多好的思路，比如： 为了防止提供AppStore的包出问题，直接使用最后的测试包，重新签名，然后上传，这里用到的就是重签名替换证书的功能。 综上，重签名打包，可以替换资源和证书，从而达到在不需要重新编译的情况下，替换资源的功能。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-Proxy]]></title>
    <url>%2F2018%2F02%2F23%2FES6-Proxy%2F</url>
    <content type="text"><![CDATA[语法proxy的作用是代理对象的某些行为，其 实质 是重载对象的方法。 举个例子,我们想要读取一个对象的某个属性 12let obj = &#123;a: &apos;a&apos; , b: &apos;b&apos;&#125;;console.log(obj.a); // &apos;a&apos; 而使用了proxy之后： 123456789let obj = &#123;a: &apos;a&apos;, b: &apos;b&apos;&#125;;let handler = &#123; get: fucntion(target, propoty)&#123; return 35; &#125;&#125;var proxy = new Proxy(obj, handler);console.log(proxy.a);// 35 相当于 proxy通过handler里面的指令，代理了obj的行为。 proxy能代理的，并不仅仅是get函数，还有如下列表，具体的可以网上查阅下文档。 get set has deleteProperty enumerate hasOwn ownKeys getOwnPropertyDescritor defineProperty preventExtensions getPrototypeOf isExtensible setPrototypeOf apply construct 使用场景看完了proxy的文档，感觉模模糊糊有了印象，但是还是对它的使用场景没有概念，网上搜索了下，发下一篇非常好的介绍使用场景的文章，地址如下： [译] 实例解析 ES6 Proxy 使用场景，下面我也会使用这篇文章的例子，来介绍proxy到底怎么用。 校验模块这里是重写set函数，实现校验功能 1234567891011121314151617181920let numericDataStore = &#123; count: 0, amount: 1234, total: 14&#125;;numericDataStore = new Proxy(numericDataStore, &#123; set(target, key, value, proxy) &#123; if (typeof value !== &apos;number&apos;) &#123; throw Error(&quot;Properties in numericDataStore can only be numbers&quot;); &#125; return Reflect.set(target, key, value, proxy); &#125;&#125;);// 抛出错误，因为 &quot;foo&quot; 不是数值numericDataStore.count = &quot;foo&quot;;// 赋值成功numericDataStore.count = 333; 私有属性js中的私有属性，约定俗成是通过前面加下划线的方式来实现，这里可以用proxy来实现，并且做到了强制私有 1234567891011121314var api = &#123; _apiKey: &apos;123abc456def&apos;, /* mock methods that use this._apiKey */ getUsers: function()&#123;&#125;, getUser: function(userId)&#123;&#125;, setUser: function(userId, config)&#123;&#125;&#125;;// logs &apos;123abc456def&apos;;console.log(&quot;An apiKey we want to keep private&quot;, api._apiKey);// get and mutate _apiKeys as desiredvar apiKey = api._apiKey; api._apiKey = &apos;987654321&apos;; 访问日志123456789101112131415161718192021222324let api = &#123; _apiKey: &apos;123abc456def&apos;, getUsers: function() &#123; /* ... */ &#125;, getUser: function(userId) &#123; /* ... */ &#125;, setUser: function(userId, config) &#123; /* ... */ &#125;&#125;;function logMethodAsync(timestamp, method) &#123; setTimeout(function() &#123; console.log(`$&#123;timestamp&#125; - Logging $&#123;method&#125; request asynchronously.`); &#125;, 0)&#125;api = new Proxy(api, &#123; get: function(target, key, proxy) &#123; var value = target[key]; return function(...arguments) &#123; logMethodAsync(new Date(), key); return Reflect.apply(value, target, arguments); &#125;; &#125;&#125;);api.getUsers(); 预警和拦截123456789101112131415161718192021222324252627282930313233343536373839404142let dataStore = &#123; noDelete: 1235, oldMethod: function() &#123;/*...*/ &#125;, doNotChange: &quot;tried and true&quot;&#125;;const NODELETE = [&apos;noDelete&apos;]; const NOCHANGE = [&apos;doNotChange&apos;];const DEPRECATED = [&apos;oldMethod&apos;]; dataStore = new Proxy(dataStore, &#123; set(target, key, value, proxy) &#123; if (NOCHANGE.includes(key)) &#123; throw Error(`Error! $&#123;key&#125; is immutable.`); &#125; return Reflect.set(target, key, value, proxy); &#125;, deleteProperty(target, key) &#123; if (NODELETE.includes(key)) &#123; throw Error(`Error! $&#123;key&#125; cannot be deleted.`); &#125; return Reflect.deleteProperty(target, key); &#125;, get(target, key, proxy) &#123; if (DEPRECATED.includes(key)) &#123; console.warn(`Warning! $&#123;key&#125; is deprecated.`); &#125; var val = target[key]; return typeof val === &apos;function&apos; ? function(...args) &#123; Reflect.apply(target[key], target, args); &#125; : val; &#125;&#125;);// these will throw errors or log warnings, respectivelydataStore.doNotChange = &quot;foo&quot;; delete dataStore.noDelete; dataStore.oldMethod(); 过滤操作通过特征来过滤不必要的操作，例如下载中，解析中等中间过程，减少响应的压力 12345678910111213141516171819202122let obj = &#123; getGiantFile: function(fileId) &#123;/*...*/ &#125;&#125;;obj = new Proxy(obj, &#123; get(target, key, proxy) &#123; return function(...args) &#123; const id = args[0]; let isEnroute = checkEnroute(id); let isDownloading = checkStatus(id); let cached = getCached(id); if (isEnroute || isDownloading) &#123; return false; &#125; if (cached) &#123; return cached; &#125; return Reflect.apply(target[key], target, args); &#125; &#125;&#125;);]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-Symbols]]></title>
    <url>%2F2018%2F02%2F22%2FES6-Symbols%2F</url>
    <content type="text"><![CDATA[#背景ES5中，属性都可以通过点方法来获取和赋值。这也带来了一个问题，当我想给一个类增加属性的时候，除非我看完这个类的所有细节，否则我很难知道一个属性名是否已经被占用。而ES6为了解决这个问题，引入了一个新的原始类型Symbol，它表示独一无二的值，来避免重复的命名。 加入Symbol之后，JS中的基础类型共有： undefined Null Boolean String Number Object Symbol #使用 初始化Symbol的初始化方法很简单，但是要注意，它不是对象（Object），所以不能用new初始化 1let s = Symbol(); Symbol没有属性，是一个类似于string的数据类型，我的理解，Symbol其实就是独一无二的string。 1s.name = &apos;symbol&apos;; //error Symbol可以通过加参数的形式来区分不同的Symbol，如下： 1let s = Symbol(&apos;foo&apos;); 注意，即使使用相同的参数来初始化，得到的实例也是不同的，比如： 123456let a = Symbol(&apos;foo&apos;);let b = Symbol(&apos;foo&apos;);let same = a === b;console.log(same); //false 如果想要获取以某个string为参数的Symbol，在之后会讲到Symbol.for()函数。 赋值使用Symbol给属性赋值，用法和string属性赋值基本相似，但是不可以用.,要用[]。以下是三种赋值方法： 12345678910111213141516let s = Symbol();let a = &#123;&#125;;// method 1a[s] = &apos;hello&apos;;//method 2a = &#123; [s] = &apos;hello&apos;;&#125;//method 3Object.defineProperty(a, s, &#123;value: &apos;hello&apos;&#125;); 使用场景Symbol的一个场景是上述提到的，给一个类增加属性，而避免属性重复。 第二是使用在常量中，switch case来保证唯一性。 1234567891011let CASE1 = Symbol();let CASE2 = Symbol();switch (case) &#123; case CASE1 :&#123; return 1; &#125; case CASE2 :&#123; return 2; &#125;&#125; 注意事项（和string属性不同的地方）最主要的区别，使用 for ... in、 for ... of 或者Object.keys()、 Object.getOwnPropertyNames()不会返回Symbol 如果想获取对象的所有Symbols，使用函数getOwnPropertySymbols 有个新的API，Reflect.ownKyes，会返回所有的String属性和Symbol属性 Symbol.keyFor和Symbol.forSymbol.forSymbol会返回一个新的实例，无论参数是什么，上面已经将到了。 1234let a = Symbol(&apos;foo&apos;);let b = Symbol(&apos;foo&apos;);let same = a === b; //false 而Symbol.for则会先搜索是否有以这个参数初始化的Symbol，如果有则放回这个Symbol，否则初始化一个新的,实现逻辑如下 1234567Symbol.for(params) = &#123; if (searchSymbolInitWithParams)&#123; return found_symbol; &#125; else &#123; return Symbol(params); &#125;&#125; 和第一个例子对比看下： 1234let a = Symbol.for(&apos;foo&apos;);let b = Symbol.for(&apos;foo&apos;);let same = a === b; //true 如果Symbol和Symbol.for混用呢？ 1234let a = Symbol(&apos;foo&apos;);let b = Symbol.for(&apos;foo&apos;);console.log(a===b); //false 这说明两者是没有打通的，即Symbol初始化的实例无法被Symbol.for找到 Symbol.keyFor用Symbol.for来初始化的Symbol，如何知道它的初始化参数呢，这里提供了一个方法： Symbol.keyFor 12let a = Symbol.for(&apos;foo&apos;);let b = Symbol.Keyfor(a);// &apos;foo&apos; 注意，Symbol初始化不能用这个函数 12let a = Symbol(&apos;foo&apos;);let b = Symbol.Keyfor(a);// undefined 注意：Symbol.for 为Symbol值登记的是全局的，这意味着在不同的iframe都可以取到同一个值。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native性能优化]]></title>
    <url>%2F2017%2F10%2F25%2FRNpreformance%2F</url>
    <content type="text"><![CDATA[关于帧在讲述如何优化性能之前，我们要先了解一下性能的概念。对一个从未接触过相关概念的人来说，所谓的性能就是当你去使用App的时候很流畅，点击、跳转等交互效果反应很快，而且很顺滑。这是感性的角度，那么理性的角度或者数据的角度看待呢？ 这里要介绍一个概念： 帧率。我们知道，所谓的动画或者电影，其实归根结底就是在一秒内快速闪过多张不同的图片，如果快到一定的程度，肉眼会误以为里面的动画都是连贯的。在iOS等设备，标准是每秒60帧（即每秒连续展示60张图片），这个标准足以保证用户的体验。 系统会每16.6毫秒询问你下一帧的数据，如果你正在处理比较复杂的任务，则系统会默认这一帧内容保持不变，即出现了丢帧的现象。如果丢的帧比较多，则界面会看起来卡顿，比如用户点击了按钮，但是没有反馈。 对React Native来说，帧分为两种： JavaScript帧和主线程帧（UI帧） JavaScript帧React Native大部分的业务处理，都是在JavaScript帧中进行，包括API调用和触摸等交互的处理。那么当处理比较复杂的任务，比如setState然后render，则很可能会丢帧。或者做由JS处理的动画时，也极容易出现丢帧卡顿。 主线程帧（UI帧）iOS的主线程是UI线程，所以在iOS的UI效果基本是非常出色的，这也是为什么NavigatorIOS比Navigator的性能好很多的原因（NavigatorIOS是主线程处理，而Navigator是JS线程处理） 如何查看帧数据我们可以通过打开RN的Debug菜单，然后选择Show Perf Monitor来查看当前页面的JS帧和主线程帧。 好了，性能的定义和我们评估性能标准已经知道了，下面我们来看下影响性能的因素。 影响性能的因素和提升方案宽泛的原因我们先抛开RN或者iOS的前端框架，看下对一台带屏幕的设备来说，影响性能的原因有哪些。 我们用金字塔模式来看，首先最明显的有两个 设备性能 程序设计 从根本上来说，设备性能是最大的瓶颈，不过这个我们程序员暂时无能为力。而程序设计可能引起性能差的有哪些呢？判断程序设计的一个标准就是复杂度， 而复杂度又分为两个： 时间复杂度 空间复杂度 这时我们的性能因素树是： 设备性能 程序设计 时间复杂度 空间复杂度 在设备空间充足的情况下，主要的影响就是时间复杂度，而时间复杂度高的原因有几个： 前端方案不合理，UI层次或者顺序设计不合理，浪费性能 使用的算法过于复杂 我们挨个说下这两个个问题，前端方案是最容易造成性能不好的原因，比如我们有屏幕上有几个区域，互相之间没有影响，而由于不合理的设计，在一个区域变化的时候，要刷新这个界面，就会出现卡顿。一个合理的前端方案，应该是尽可能减少页面的刷新频率和刷新范围，保证每帧的计算是相对小的。 而算法过于复杂，则是算法消耗的时间太长，影响了UI的渲染。比如使用了圈复杂度非常高的算法，或者有大量的数据要不停地计算。 这样我们的性能因素树变成了： 设备性能 程序设计 空间复杂度 时间复杂度 前端方案不合理，UI层次或者顺序设计不合理，浪费性能 使用的算法过于复杂 可能还会有人觉得网络等原因会造成卡顿，但是我觉得如果交互设计良好，网络状况不好的话，只会影响数据出现的时间长，而不会造成页面的卡顿。 看完了比较普遍宽泛的原因，我们看下针对RN的 RN的特有原因JS Bridge的效率虽然官方的文章里没有写，但是从我测试看到的数据来看，虽然RN的性能比较接近Native，但是因为JS是运行在子线程中的，所以处理大量数据或者动画的时候，JS的帧数会比较少。 这个我们暂时无能为力 动画和Touchable组件在JS线程中运行Animated和Touchable系列组件都是在JS中运行，所以在处理复杂动画或者复杂操作的时候，会出现卡顿。 这里给几个建议： 关于导航 iOS上使用NavigatorIOS替换Navigator，同时，react也推出了新的Navigation库希望解决导航卡顿的问题 push的新界面的动画，使用InteractionManager，就是在导航动画结束后执行新的动画，而不是同时执行 关于动画 如果Animated的效果不能接受，使用LayoutAnimation，它是基于Core Animation android上面尽量少用动画（真的很卡0_0） 其他建议 使用PureComponent 使用 shouldComponentUpdate函数，这个函数默认返回true，但是我们可以通过自定义来优化重新绘制的逻辑 release 去除console.log() (!__DEV__) &#123;12345678 global.console = &#123; info: () =&gt; &#123;&#125;, log: () =&gt; &#123;&#125;, warn: () =&gt; &#123;&#125;, debug: () =&gt; &#123;&#125;, error: () =&gt; &#123;&#125;, &#125;;&#125; 最重要的建议 仔细考虑UI的设计 仔细考虑UI的设计 仔细考虑UI的设计 一个好的UI设计方案，是可以抵过上面所有的建议加起来的效果的，所以一定要仔细考虑再动手。 参考： 官方文档：性能]]></content>
      <categories>
        <category>React-Native</category>
      </categories>
      <tags>
        <tag>React-Native</tag>
        <tag>performance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next增加搜索localSearch]]></title>
    <url>%2F2017%2F10%2F19%2FNext-add-localSearch%2F</url>
    <content type="text"><![CDATA[Next本身增加localSearch很简单，三步即可： 安装安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能： 123# Local searchlocal_search: enable: true 遇到问题，一直loading发布了之后，点击搜索一直在loading，查了其他人的文章Hexo next 主题的 local search 功能失效，点击搜索链接无法弹出叠加层 ，发现是search.xml出现了问题。 排查问题步骤： command + option + J 打开调试器 点击NetWork，发现卡在了search.xml上面 尝试debug serach.xml文件，打开 https://njafei.github.io/search.xml 看到警告： error on line 92 at column 35: Input is not proper UTF-8, indicate encoding ! 0x10 0xE6 0x88 0x96 编码问题，找到对应的文章，先对其进行utf-8编码，然后放到sublimeText中，我发现中间多了一个类似于DEL的乱码，删除即可 重新发布，搜索可用 缓存问题search有时候会有缓存，这时候，可以打开对应的search.xml文件https://njafei.github.io/search.xml，刷新几下即可 PS： 如果你想刷新你的文件，把前面的链接替换即可。]]></content>
      <tags>
        <tag>博客搭建和功能增强</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ImageOptm 自动化无损优化图片]]></title>
    <url>%2F2017%2F09%2F26%2FImageOptm%2F</url>
    <content type="text"><![CDATA[iOS控制包的大小对于公司来说，是个非常重要的事情。因为苹果公司对于包的大小超过100M的，不会允许用户使用移动网络来下载，这很可能造成商业上的损失。 而在控制包的大小中，一个很重要的原则就是禁止大图片。之前研究其他公司的ipa包的时候，就出现过一个icon高达1M的事故。而平时，虽然程序员们百般小心，难免被设计师暗算给张大图（玩笑），所以靠人终究不是一个可持续的保证质量的方法。 平时用的无损压缩最多的工具是ImageOptm，它可以无损压缩图片（即用户看起来感官无变化，而图片尽可能小），而且它是提供命令行的，ImageOptm command line. 我们就可以通过Jenkins的定时任务，每天凌晨去优化所有的图片，然后再自动commit上传。 具体任务就很简单了，大概几个步骤： 1、Jenkins开个定时任务，更新代码 2、执行ImageOptm脚本 1/Applications/ImageOptim.app/Contents/MacOS/ImageOptim $WORKSPACE/ 3、上传代码]]></content>
      <tags>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java对空格的encode格式问题]]></title>
    <url>%2F2017%2F09%2F22%2FJava-space-encode%2F</url>
    <content type="text"><![CDATA[今天发现了一个非常奇怪的问题，服务端给了一个encode的url，内容是位“1 1”： encode之后是 11+1 前端decode之后是 11+1 可是在其他的浏览器等decode之后的结果是： 11 1 发现java的encode有个坑，在java中，encode遵循的标准是rfc1738，而在iOS中，encode遵循的标准是rfc2396，两者对于空格的encode不同 12rfc1738 =&gt; +rfc2396 =&gt; %20 所以今后和Java服务端合作的时候，如果encode之后的文案出现了+号这种莫名奇妙的bug，记得让他们检查下encode的代码，可以通过替换来解决这个问题。]]></content>
      <tags>
        <tag>小知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Native优化之PureComponent]]></title>
    <url>%2F2017%2F07%2F27%2FpureComponent%2F</url>
    <content type="text"><![CDATA[React15.3的发布中包含了PureComponent，这个类最重要的用法是为了优化React的性能，下面我们将看下它是如何优化的。 Component VS PureComponent首先要看Component的生命周期： 当props或者state改变的时候，会执行shouldComponentUpdate方法来判断是否需要重新render组建，我们平时在做页面的性能优化的时候，往往也是通过这一步来判断的。Component默认的shouldComponentUpdate返回的是true，如下： 123shouldComponentUpdate(nextProps, nextState) &#123; return true;&#125; 而PureComponent的shouldComponentUpdate是这样的： 123if (this._compositeType === CompositeTypes.PureClass) &#123; shouldUpdate = !shallowEqual(prevProps, nextProps) || ! shallowEqual(inst.state, nextState);&#125; 这里的比较，只会做潜比较，即比较两者的内存地址是否相同，而对于其值是否发生变化，则不会理会。我们通过以下的例子来看下： 例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * Sample React Native App * https://github.com/facebook/react-native * @flow */import React, &#123; PureComponent,Component &#125; from &apos;react&apos;;import &#123; AppRegistry, StyleSheet, Text, View, Button&#125; from &apos;react-native&apos;;export default class test extends PureComponent &#123; constructor(props)&#123; super(props); this.state = &#123; number : 1, numbers: [], &#125;; &#125; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Button title=&#123;&apos;number + 1&apos;&#125; onPress=&#123;this.numberAdd.bind(this)&#125; /&gt; &lt;Text&gt;number value: &#123;this.state.number&#125;&lt;/Text&gt; &lt;Button title=&#123;&apos;numbers + 1&apos;&#125; onPress=&#123;this.numbersAdd.bind(this)&#125; /&gt; &lt;Text&gt;numbers length: &#123;this.state.numbers.length&#125;&lt;/Text&gt; &lt;/View&gt; ); &#125; numberAdd()&#123; this.setState(&#123;number: ++this.state.number &#125;); &#125; numbersAdd()&#123; let numbers = this.state.numbers; numbers.push(1); this.setState(&#123;numbers: numbers&#125;); console.log(this.state.numbers); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: &apos;center&apos;, alignItems: &apos;center&apos;, backgroundColor: &apos;#F5FCFF&apos;, &#125;, welcome: &#123; fontSize: 20, textAlign: &apos;center&apos;, margin: 10, &#125;, instructions: &#123; textAlign: &apos;center&apos;, color: &apos;#333333&apos;, marginBottom: 5, &#125;,&#125;);AppRegistry.registerComponent(&apos;test&apos;, () =&gt; test); 界面如下： 这里去点击number+1 和 numbers+1都不会有任何页面的变化。 如何让PureComponent重绘那如果PureComponent变化的时候(这其实不符合我们的初衷)，我们要怎么做呢？这里有两个办法： 重写shouldUpdateComponent方法 props或者state增减参数 代码如下： 12345678numbersAdd()&#123; let numbers = this.state.numbers; numbers.push(1); this.setState(&#123;numbers: numbers&#125;); console.log(this.state.numbers); this.setState(&#123;newState: 1&#125;); &#125; 这样，shouldComponentUpdate的返回值也会是true。 总结综上，PureComponent非常适合于不变的组件，尤其是和数据、业务无关的纯展示组件，因为它的节省了大量比较的工作。但是对于大部分的业务来说，界面很少会有不变的组件，所以使用的场景会比较少，但是如果遇到，请尽情使用！]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
        <tag>component</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native time定时器 防止内存泄露的注意点]]></title>
    <url>%2F2017%2F07%2F27%2Freact-native-time-attations%2F</url>
    <content type="text"><![CDATA[time是react-native提供的一个定时器，在实际使用中，经常会有使用不对，造成内存泄露的情况。很多React Native应用发生致命错误（闪退）是与计时器有关。具体来说，是在某个组件被卸载（unmount）之后，计时器却仍然在运行。 防止出问题的办法也很简单，在unmount的时候，增加卸载定时器的操作： 12345678910111213componentDidMount() &#123; this.timer = setTimeout( () =&gt; &#123; console.log(&apos;把一个定时器的引用挂在this上&apos;); &#125;, 500 ); &#125; componentWillUnmount() &#123; // 请注意Un&quot;m&quot;ount的m是小写 // 如果存在this.timer，则使用clearTimeout清空。 // 如果你使用多个timer，那么用多个变量，或者用个数组来保存引用，然后逐个clear this.timer &amp;&amp; clearTimeout(this.timer); &#125; 这里的timer是在DidMount中赋值的，如果是多次赋值呢？比如： 12345678910111213141516171819202122232425262728export default class test extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Button title=&#123;&apos;click5000&apos;&#125; onPress=&#123;this.alertInfo.bind(this,5000)&#125; /&gt; &lt;Button title=&#123;&apos;click2000&apos;&#125; onPress=&#123;this.alertInfo.bind(this,2000)&#125; /&gt; &lt;Button title=&#123;&apos;clean timer&apos;&#125; onPress=&#123;this.cleanTimer.bind(this)&#125; /&gt; &lt;/View&gt; ); &#125; alertInfo(time)&#123; this.timer = setTimeout( ()=&gt;&#123; alert(&apos;hah&apos;); &#125;, time, ); &#125; cleanTimer()&#123; this.timer &amp;&amp; clearTimeout(this.timer); console.log(&apos;timer cleared&apos;) &#125;&#125;AppRegistry.registerComponent(&apos;test&apos;, () =&gt; test); 这里要介绍下setTimeout的返回值，我们打断点可以看到，this.timer是一个number。根据stack上面的其他网友的回答what-does-settimeout-return，setTimer会返回一个id，代表你已经向js的runtime系统中成功注册了一个定时器任务，这个id就是系统返回的id。 那如果是需要多次赋值，就一定要先将time clear掉，然后再赋值，或者使用多个参数来标志，否则之后就找不到上次的id，也就没办法clear了，同样可能造成内存泄露的情况。 例子如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Sample React Native App * https://github.com/facebook/react-native * @flow */import React, &#123; Component &#125; from &apos;react&apos;;import &#123; AppRegistry, StyleSheet, Text, View, Button&#125; from &apos;react-native&apos;;export default class test extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Button title=&#123;&apos;click5000&apos;&#125; onPress=&#123;this.alertInfo.bind(this,5000)&#125; /&gt; &lt;Button title=&#123;&apos;click2000&apos;&#125; onPress=&#123;this.alertInfo.bind(this,2000)&#125; /&gt; &lt;Button title=&#123;&apos;clean timer&apos;&#125; onPress=&#123;this.cleanTimer.bind(this)&#125; /&gt; &lt;/View&gt; ); &#125; alertInfo(time)&#123; this.timer = setTimeout( ()=&gt;&#123; alert(&apos;hah&apos;); &#125;, time, ); &#125; cleanTimer()&#123; this.timer &amp;&amp; clearTimeout(this.timer); console.log(&apos;timer cleared&apos;) &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: &apos;center&apos;, alignItems: &apos;center&apos;, backgroundColor: &apos;#F5FCFF&apos;, &#125;, welcome: &#123; fontSize: 20, textAlign: &apos;center&apos;, margin: 10, &#125;, instructions: &#123; textAlign: &apos;center&apos;, color: &apos;#333333&apos;, marginBottom: 5, &#125;,&#125;);AppRegistry.registerComponent(&apos;test&apos;, () =&gt; test); 这里的timer多次赋值，虽然前面的值被后面的覆盖，但是前面的time仍然会起效果，如果不想前面的time work，需要clear掉，然后再赋值。 代码如下： 123456789alertInfo(time)&#123; this.timer &amp;&amp; clearTimeout(this.timer); this.timer = setTimeout( ()=&gt;&#123; alert(&apos;hah&apos;); &#125;, time, ); &#125; 综上，使用time的注意点： 记得unmount的时候，clear 多个timer要使用多个变量或者数组 多次赋值，记得把之前的值clear掉]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
        <tag>注意事项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[listView和FlatList的flexGrow默认值为1]]></title>
    <url>%2F2017%2F07%2F26%2FlistViewFlexGrowDefaultValue%2F</url>
    <content type="text"><![CDATA[今天遇到了适配的问题，有个列表，需要自适应高度，按理说默认应该就是自适应的，但是在实际中发现，其会和另外一个视图1：1 ，然后就发现只有设置其flexGrow: 0的时候，它才会自动适配高度，说明它的flexGrow默认值为1. 看下具体的列子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React, &#123; Component &#125; from &apos;react&apos;;import &#123; AppRegistry, StyleSheet, Text, View, ListView,&#125; from &apos;react-native&apos;;export default class testListView extends Component &#123; constructor(props) &#123; super(props); const ds = new ListView.DataSource(&#123;rowHasChanged: (r1, r2) =&gt; r1 !== r2&#125;); this.state = &#123; dataSource: ds.cloneWithRows([ &apos;John&apos;, &apos;Joel&apos;, &apos;James&apos;, &apos;Jimmy&apos;, &apos;Jackson&apos;, &apos;Jillian&apos;, &apos;Julie&apos;, &apos;Devin&apos; ]) &#125;; &#125; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;View style=&#123;styles.blackView&#125; /&gt; &lt;ListView dataSource=&#123;this.state.dataSource&#125; renderRow=&#123;(rowData) =&gt; &lt;Text&gt;&#123;rowData&#125;&lt;/Text&gt;&#125; style=&#123;styles.list&#125; /&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flexGrow: 1, backgroundColor: &apos;#F5FCFF&apos;, &#125;, list:&#123; backgroundColor: &apos;red&apos;, &#125;, blackView: &#123; flexGrow: 1, backgroundColor: &apos;black&apos;, &#125;&#125;);AppRegistry.registerComponent(&apos;testListView&apos;, () =&gt; testListView); 这个UI看起来是这样： 如果style中的list改成这样，就好了： 1234list:&#123; backgroundColor: &apos;red&apos;, flexGrow: 0, &#125;, 显示成： 综上，我怀疑FlatList和ListView的flexGrow默认值是1.有遇到类似问题的，不妨试试这样解决。 版本： “react-native”: “0.43.4”]]></content>
      <categories>
        <category>React-Native</category>
      </categories>
      <tags>
        <tag>React-Native</tag>
        <tag>奇怪的bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何访问和修改一个对象的私有属性]]></title>
    <url>%2F2017%2F06%2F15%2FhowToChangeObjectProperty%2F</url>
    <content type="text"><![CDATA[有两个思路： KVC runtime 先给出我们接下来要使用的类： 1234567891011121314@interface Person : NSObject@end@interface Person()@property (nonatomic, copy) NSString *name;@end@implementation Person@end KVCKVC是我比较推荐的，代码如下： 12345Person *person = [Person new]; [person setValue:@&quot;new name&quot; forKey:@&quot;name&quot;];NSString *name = [person valueForKey:@&quot;name&quot;]; KVC是苹果推荐用来做类似事情的方法，所以这种需求，KVC解决是最好的，代码简洁，效率也比较高。关于KVC的相关内容可以看下KVC详解 runtimeruntime的思路就是先读取对象的所有属性，然后找到对象的属性，赋值。代码如下： 1234567891011121314Person *person = [Person new];unsigned int count = 0; //count记录变量的数量Ivar *members = class_copyIvarList([person class], &amp;count);for (int i = 0; i &lt; count; i++) &#123; Ivar ivar = members[i]; const char *memberName = ivar_getName(ivar); NSString *memberNameString = [NSString stringWithFormat:@&quot;%s&quot;,memberName]; if ([memberNameString isEqualToString: @&quot;_name&quot;]) &#123; object_setIvar(person, ivar, @&quot;newName&quot;); &#125;&#125; runtime的做法相对来讲代码比较多，也不够简洁，但是还是可以实现这个需求的。runtime的详细内容可以参考iOS Runtime 详解]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Error RawText ** must be wrapped in an explicit component 问题解决]]></title>
    <url>%2F2017%2F06%2F14%2FstringToBoolError%2F</url>
    <content type="text"><![CDATA[今天忽然遇到一个页面崩溃，查到错误如下： 1Error: RawText &quot;&quot; must be wrapped in an explicit &lt;Text&gt; component. 查了代码，发现好久都没有动这块的代码了，所以非常疑惑。最后通过2分法不停地查哪里出了问题，最终查到了这个语句： 1234567return ( &lt;View&gt; &#123;test &amp;&amp; test.string &amp;&amp; &lt;Text&gt;&#123;test.string&#125;&lt;/Text&gt; &#125; &lt;/View&gt;) 其实作用很简单，如果string有值，则展示string。但是这条语句为什么会报错呢？查了半天，发现是因为string的值是’’,然后系统就报错了，类似这样： 12345678let test = &#123;string: &apos;&apos;&#125;;return ( &lt;View&gt; &#123;test &amp;&amp; test.string &amp;&amp; &lt;Text&gt;&#123;test.string&#125;&lt;/Text&gt; &#125; &lt;/View&gt;) 后来查了下github，发现很多人也遇到了类似的错误，解决办法如下,使用!!来判断string是否有值，因为这里其实你是希望将string当成bool来使用的。 12345678let test = &#123;string: &apos;&apos;&#125;;return ( &lt;View&gt; &#123;test &amp;&amp; !!test.string &amp;&amp; &lt;Text&gt;&#123;test.string&#125;&lt;/Text&gt; &#125; &lt;/View&gt;) 所以以后string的判断，都用!!去判断，否则出现string恰好为’’的时候，就会崩溃。 参考文章： https://github.com/GeekyAnts/NativeBase/issues/186]]></content>
      <categories>
        <category>bugFix</category>
      </categories>
      <tags>
        <tag>React-Native</tag>
        <tag>奇怪的bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[block]]></title>
    <url>%2F2017%2F06%2F13%2Fblock%2F</url>
    <content type="text"><![CDATA[其实使用block的时间也蛮久了，比如使用__block,weak防止循环引用，copy修饰等注意点也都知道，但是一直没有去看过官方的文档，仔细看下所有的点。今天就把官方文档撸一遍，深入了解下。 使用场景苹果在介绍block的使用场景时，是这么说的： You use a block when you want to create units of work (that is, code segments) that can be passed around as though they are values. Blocks offer more flexible programming and more power. 当你想要做一连串的工作时（代码片段），block可以被当成值来传递，从而使程序更加灵活、易用。 我觉得，这个类似于JS的callback，这样写看起来比较直观，不像代理，满天飞，易读性不好。 声明和使用正常使用block类似于这样： 1234int multiplier = 7;int (^myBlock)(int) = ^(int num) &#123; return num * multiplier;&#125;; 以前其实我自己在写block的时候，很容易迷糊，因为格式容易记不住，但是看了下面的图，仔细了解下它的结构，以后就好记了 首先是它的返回值，然后是它的name，接着是参数的类型，声明和实现结构是一样的，只是实现里面会多形参。 看下如何使用： 1234567int multiplier = 7;int (^myBlock)(int) = ^(int num) &#123; return num * multiplier;&#125;; printf(&quot;%d&quot;, myBlock(3));// prints &quot;21&quot; 在苹果提供block之后，它提供了大量的block的函数用法， 比较多的应该就是数据等的遍历。我们自己在写代码的时候，通常数据请求、alert等也都会封装成block的形式，因为真的是易读性比较好。 block和变量在block中，是可以直接引用外部的变量的，比如： 12int a = 0;block(a); 但是不能直接修改外部的变量，比如： 1234int a = 0;block = ^(int a)&#123; a = 5;//error&#125; __block如果你想要在block中改变外部变量的值的话，需要使用__block来修饰，为什么这个关键词可以呢？我们来看下苹果的解释 __block variables live in storage that is shared between the lexical scope of the variable and all blocks and block copies declared or created within the variable’s lexical scope. Thus, the storage will survive the destruction of the stack frame if any copies of the blocks declared within the frame survive beyond the end of the frame (for example, by being enqueued somewhere for later execution). Multiple blocks in a given lexical scope can simultaneously use a shared variable. As an optimization, block storage starts out on the stack—just like blocks themselves do. If the block is copied using Block_copy (or in Objective-C when the block is sent a copy), variables are copied to the heap. Thus, the address of a __block variable can change over time. There are two further restrictions on __block variables: they cannot be variable length arrays, and cannot be structures that contain C99 variable-length arrays. __block会把变量放到block等的存在的内存中，这样在block存在期间，可以直接修改变量，不同的block都使用这个共享的变量。 block默认是存在栈中的，但是如果block被拷贝，则会放到堆中 __block有两个注意点，不能是可变化长度的数据，也不能是C99标准可变长度的数组 注意点 为什么要用copy 为什么要避免循环引用，如何避免 避免两个错误模式 为什么要用copy如上面所述，block默认是存在栈中的，但是如果block被拷贝，则会放到堆中，所以即使你使用strong，其实系统也是会copy一份的，用copy是为了让自己知道，这个block在使用中是会被copy一份的。那么，为什么呢？这因为如果block在栈中，则他的作用域就是栈中所在的作用域，如果在作用域外调用栈的内容，则会崩溃，所以要用copy，就会将其复制到堆中，调用就不会出现问题。当然，用strong也不会有任何问题，但是copy更能让我们使用的时候，知道使用的原因。 循环引用，如何避免先看下代码： 123self.printBlock = ^(block)(NSString *) = ^(NSString *name)&#123; [self print: name];&#125; 在这里，self会对block强引用，而block中，又会对self强引用，所以系统在回收内存的时候，这两个对象都没有办法回收内存，就造成了内存的泄露了。 怎么避免呢？ 12345__weak typeof(self) weakself = selfself.printBlock = ^(block)(NSString *) = ^(NSString *name)&#123; __strong __typeof(self) strongSelf = weakSelf;//里面使用strong，防止执行block的时候 self被销毁 [weakself print: name];&#125; 避免两个错误模式苹果在文档中，特意提了两个错误的模式，让大家不要使用，如下： 12345678910111213141516171819void dontDoThis() &#123; void (^blockArray[3])(void); // an array of 3 block references for (int i = 0; i &lt; 3; ++i) &#123; blockArray[i] = ^&#123; printf(&quot;hello, %d\n&quot;, i); &#125;; // WRONG: The block literal scope is the &quot;for&quot; loop. &#125;&#125;void dontDoThisEither() &#123; void (^block)(void); int i = random(): if (i &gt; 1000) &#123; block = ^&#123; printf(&quot;got i at: %d\n&quot;, i); &#125;; // WRONG: The block literal scope is the &quot;then&quot; clause. &#125; // ...&#125; 这两个用法本身是可以执行的，但是效率太差。本来block是内联的，所以应该先定义，再使用，而不是上文的用法，每次都重新定义一个。 PS： 内联函数的效率非常高，可以理解为内联是之前把代码片段嵌入到使用的地方，而非内联的函数就是要调用函数了]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>Apple文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[os.system如何传参]]></title>
    <url>%2F2017%2F05%2F26%2Fos-system%E5%A6%82%E4%BD%95%E4%BC%A0%E5%8F%82%2F</url>
    <content type="text"><![CDATA[今天写脚本的时候，正好希望在python脚本中调用另外一个python脚本，就使用了os.system来实现这个功能（当然，还有很多的办法，而且每种方法满足的需求不都一样，有兴趣的读者可以谷歌下）。 但是我需要给这个调用里面传入一个参数，网上查了半天，感觉都不太清晰，就写了这篇，简单介绍下。 os.system的定义是这样的 1os.system(&quot;shell command argusFormat&quot; % argus) 在双引号里面正常写命令，需要用到参数的地方，使用%s等格式代替，然后在双引号的后面加空格，加%号，然后在括号里写入所有的参数，用逗号隔开。 单个参数12param = &apos;I&apos;m param&apos;os.system(&quot;python haha.py %s&quot; % (param)) 多个参数123paramA = &apos;I&apos;m paramA&apos;paramB = &apos;I&apos;m paramB&apos;os.system(&quot;python haha.py %s %s&quot; % (paramA,paramB)) 需要注意的是，shell中对于空格的要求特别严格，一定要注意别多或者少（写js的来写shell真的好难受0_0）。 python格式化1234567891011121314151617181920212223242526272829%s 字符串 (采用str()的显示)%r 字符串 (采用repr()的显示)%c 单个字符%b 二进制整数%d 十进制整数%i 十进制整数%o 八进制整数%x 十六进制整数%e 指数 (基底写为e)%E 指数 (基底写为E)%f 浮点数%F 浮点数，与上相同%g 指数(e)或浮点数 (根据显示长度)%G 指数(E)或浮点数 (根据显示长度)%% 字符&quot;%&quot;]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之字符串拓展]]></title>
    <url>%2F2017%2F05%2F23%2FES6%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%93%E5%B1%95%2F</url>
    <content type="text"><![CDATA[ES6中，还是对字符串做了很多的改进，尤其是函数方面，增加了很多个方法。但是核心的变动，其实只有两个： Unicode拓展 字符模板 Unicode拓展在讲ES6之间，我们先了解一些背景知识。 为什么会出现Unicode我们知道，计算机最底层其实只能识别‘0’和‘1’，就是yes或者no。但是人脑是非常高级的，我们见面会打招呼“您吃了没？”，这句话如果是想告知计算机的话，它肯定是听不懂的，最后计算机接收的其实类似于：“01010101010001100111”的字符串。那么，当这些字符串通过QQ展示出来的时候，又要去展示对人脑友好的文字。“您吃了没？”和“01001010111”这样的字符串是如何对应的呢？ 因为最初的计算机和技术都是美国发明的，所以他们首先提出了方案ASCII，即使用一个字节表示所有的字符和符号。比如：”00000001”表示”a”,”00000010”表示”b”(举例用，数值不对).这样，使用一个字节就解决了所有的英文展示问题。但是256足够表示所有的英文了，中文可没办法，或者其他语言，也不能够用。这样，就提出了Unicode的概念，希望所有的字符，全部都使用Unicode表示。 Unicode的第一个版本是打算使用两个字节来表示所有的字符，比如1-200给英文，200-5000给中文等等，这样总共就有2^16次方个，基本足够了。（后来发现还是不够，Unicode的第二个版本就使用4个字节，共2^32个） 所有的字符都有一个数字对应的了，怎么保存呢？这里很多人容易搞错，因为Unicode提出了使用2个字节来表示所有字符，所以大家把UTF16和Unicode弄混淆了。应该说，UTF16来存储和Unicode真的是天作之合，因为两者都是使用两个字节。但是这样也出现了一个问题，比如如果一篇英文文章，他使用的字符段，都是一个字节就能表示出来了，使用2个字节表示，简直是浪费空间，所以又提出了UTF8，即使用1个字节存储，如果出现了需要两个字节的情况，想办法做兼容。 综上，我们说的Unicode是为了表示所有的字符的一种定义方法，而UTF8和UTF16是为了存储Unicode的一种方案。 这里如果比较有兴趣，可以看下博客Unicode(UTF-8, UTF-16)令人混淆的概念 ES6做的拓展JS是支持直接展示Unicode的，比如: 1console.log(&quot;\u0061&quot;);//&quot;a&quot;; 但是只限 \u0000 - \FFFF之间的，如果是 \u00001这样的，就不支持了。 而ES6对该点做了补充，可以直接使用了，如： 1console.log(&quot;\u&#123;00001&#125;&quot;);//使用大括号包含，和四字节的UTF16等价 还可以连接使用： 1conslle.log(&quot;\u&#123;1&#125;\u&#123;2&#125;&quot;);//&quot;ab&quot; 都是举例，对应字符串可能不对 ES6中还补充了很多的函数，大家有兴趣，自己去翻下文档，这里简单罗列下： codePointAt(） String.fromCodePoint() at() normalize() includes() startsWith() endsWith() repeat() 模板字符串在JS中，如果我们想要表达一个含有变量的字符串，大概会这样写： 123let name = &quot;飞&quot;;let lunch = &quot;午饭&quot;;let ask = name + &quot;您吃&quot; + lunch + &quot;吗？&quot;;//飞您吃午饭了吗？ 不得不说，这样写，比较丑。 模板字符串ES6中使用字符模板解决了这个问题，让你可以拼接字符串的时候用的更爽。 123let name = &quot;飞&quot;;let lunch = &quot;午饭&quot;;let ask = `$&#123;name&#125;您吃$&#123;lunch&#125;吗?`; //您吃午饭了吗？ 是不是优雅多了呢？ 另外模板字符串还会记录空格、换行等字符： 1234567let ask = `飞，我今天，好饿啊` 打印出来就是： 飞， 我今天， 好 饿 啊 再也不用各种空格符号和换行符号了。 标签模板另外还有一个值得注意的地方，就是标签模板，即在“``”前面，将其变为一个函数。 1functionName`$&#123;name&#125;,您吃$&#123;lunch&#125;了吗？` 其实就等同于 1functionName functionName(stringArr,...value)&#123;&#125;; stringArr就是模板里的不变的值：“,您吃了吗？”而…value就是里面的变量：${name} 和 ${lunch}. 书上和其他的blog上面都说是可以用做字符串检查，类似于 123456789101112131415function SaferHTML(templateData) &#123; var s = templateData[0]; for (var i = 1; i &lt; arguments.length; i++) &#123; var arg = String(arguments[i]); // Escape special characters in the substitution. s += arg.replace(/&amp;/g, &quot;&amp;amp;&quot;) .replace(/&lt;/g, &quot;&amp;lt;&quot;) .replace(/&gt;/g, &quot;&amp;gt;&quot;); // Don&apos;t escape special characters in the template. s += templateData[i]; &#125; return s;&#125;// 调用var html = SaferHTML`&lt;p&gt;这是关于字符串模板的介绍&lt;/p&gt;`; 能让你写的代码更优雅一些，算是字符串模板的拓展。 综上，实际使用的话，Unicode其实用的真的不多，但是字符串模板还是应该多关注下，能用尽量用，毕竟，使代码更优雅是每个程序员的最求。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>JavaScript</tag>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native基类设计]]></title>
    <url>%2F2017%2F05%2F20%2Freact-native%E5%9F%BA%E7%B1%BB%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[背景前段时间发现iOS手机上，很多页面的字体样式会随着系统配置字体的大小而变换，使得界面不太美观。而这个其实只要给一个参数就可以解决，但是整个app中用该组件的地方非常多，开发挨个替换的话，工作量很大，而且很容易出现遗漏。 另外升级RN后，出现了Android手机上面的Text点击崩溃问题，底层的bug，前端需求的话，也是要花费相当精力而且容易遗漏。 那么，对于类似的问题，有没有好的解决方案呢？ 解决思路如果抽象以下，我们其实是要解决两个痛点： 风险控制问题 提高开发效率 风险控制问题这个是要解决RN框架界面突然爆发问题或者bug，我们应该是能及时、快速修复掉。目前其实RN还是可以热修复的，但是面对上面两个问题，其实没办法热修复，因为涉及到的点太多，工作量等太大。 所以，要解决风险控制问题，保证底层对于业务的组件是有控制力的，从而避免突然爆发问题而束手无策。 提高开发效率这里还要介绍下在Image这个组件遇到的问题。一个是当前所有的图片都是没有默认的占位图的，另外就是如果图片下载失败，Image就会是空白，只有做特殊处理才能显示占位图。如果每个业务开发在使用Image的时候，都要加几行这种类似的重复代码，效率是非常低的。 或者临时遇到诸如整体换颜色、字体等问题，都是非常痛苦的。 所以提出想要能把开发从这种重复低价值劳动中解放出来。 方案基类的方案，有两个核心点： 所有的页面都继承自基类 所有的组件都不再从react-native库中取，而是从基类中取 如果一句话来概括的话，就是我们封装了一层react-native。业务开发使用的组件都是从我们自己库中取，而库中的控件，可以是定制的，也可以是简单从react-native中调用。 包含控件这里是基类Component和其他几个开发过程中遇到的问题比较多的： Component Text Image 具体的定制需求如下（还需要向开发搜集）： Text 默认字体等配置 是否自动根据系统字体设定大小 false 解决number等的崩溃问题 Image 加载失败的处理 默认图片 （牛头图） 自动更换webp的操作 好处好处就是解决上文提的两个痛点： 风险控制问题 提高开发效率 缺点基类如果出现bug，影响范围会比较大。 待确定的问题 具体定制组件的需求还要搜集下 代码实现Base Component123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169import React from &apos;react&apos;;import &#123; Button, DatePickerIOS, DrawerLayoutAndroid, FlatList, Image, KeyboardAvoidingView, ListView, Modal, Navigator, NavigatorIOS, Picker, PickerIOS, ProgressBarAndroid, ProgressViewIOS, RefreshControl, ScrollView, SectionList, SegmentedControlIOS, Slider, StatusBar, Switch, TabBarIOS, TextInput, ToolbarAndroid, TouchableHighlight, TouchableNativeFeedback, TouchableWithoutFeedback, View, ViewPagerAndroid, VirtualizedList, WebView, StyleSheet, Platform, AsyncStorage, TouchableOpacity, DeviceEventEmitter, ActivityIndicator, NativeModules, findNodeHandle, ActionSheetIOS, AdSupportIOS, Alert, AlertIOS, Animated, AppRegistry, AppState, BackAndroid, CameraRoll, Clipboard, DatePickerAndroid, Dimensions, Easing, Geolocation, ImageEditor, ImagePickerIOS, ImageStore, InteractionManager, Keyboard, LayoutAnimation, Linking, NativeMethodsMixin, NetInfo, PanResponder, PermissionsAndroid, PixelRatio, PushNotificationIOS, Share, Systrace, TimePickerAndroid, ToastAndroid, Vibration,&#125; from &apos;react-native&apos;;import Text from &apos;./BaseText.js&apos;class BaseComponent extends React.Component &#123; render()&#123; return ( &lt;View&gt; &lt;/View&gt; ) &#125;&#125;export default BaseComponent;module.exports = &#123; //自定义的组件 BaseComponent, Text, //使用系统的组件 Button, DatePickerIOS, DrawerLayoutAndroid, FlatList, Image, KeyboardAvoidingView, ListView, Modal, Navigator, NavigatorIOS, Picker, PickerIOS, ProgressBarAndroid, ProgressViewIOS, RefreshControl, ScrollView, SectionList, SegmentedControlIOS, Slider, StatusBar, Switch, TabBarIOS, TextInput, ToolbarAndroid, TouchableHighlight, TouchableNativeFeedback, TouchableWithoutFeedback, View, ViewPagerAndroid, VirtualizedList, WebView, Platform, AsyncStorage, TouchableOpacity, DeviceEventEmitter, ActivityIndicator, NativeModules, findNodeHandle, ActionSheetIOS, AdSupportIOS, Alert, AlertIOS, Animated, AppRegistry, AppState, BackAndroid, CameraRoll, Clipboard, DatePickerAndroid, Dimensions, Easing, Geolocation, ImageEditor, ImagePickerIOS, ImageStore, InteractionManager, Keyboard, LayoutAnimation, Linking, NativeMethodsMixin, NetInfo, PanResponder, PermissionsAndroid, PixelRatio, PushNotificationIOS, Share, StyleSheet, Systrace, TimePickerAndroid, ToastAndroid, Vibration,&#125; 定制Text：12345678910111213141516171819202122232425262728293031import React from &apos;react&apos;;import &#123; Text, StyleSheet,&#125; from &apos;react-native&apos;;class BaseText extends React.Component&#123; constructor(props)&#123; super(props); &#125; render()&#123; let &#123;style,...others&#125; =this.props; return ( &lt;Text &#123;...others&#125; allowFontScaling=&#123;false&#125; style=&#123;[styles.defaltStyle,style]&#125; /&gt; ) &#125;&#125;const styles = StyleSheet.create(&#123; fontSize: 12,&#125;)export default BaseText; 子类使用:1234567891011import &#123; Text, BaseComponent,&#125; from &apos;../../../../../common/BaseComponent&apos;render() &#123; return ( &lt;Text&gt;这是Text的内容&lt;/Text&gt; )&#125; 计划第一期首先可以先把紧迫的诸如Text、Image等待解决的bug和样式等做好，基类写好，替换诸如某个模块，如果上线之后没有问题，可以替换所有的RN页面。 第二期 将默认样式和诸如快捷写法等集成到基类中，提高大家书写RN代码的效率，也方便以后更换等。 考虑一些AOP的使用，比如打点，统计等。]]></content>
      <categories>
        <category>React-Native</category>
      </categories>
      <tags>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android上的RN不能展示尺寸大的图，怎么办？]]></title>
    <url>%2F2017%2F05%2F18%2Fandroid-RN-bigImage%2F</url>
    <content type="text"><![CDATA[背景最近遇到一个营销的需求，一个简单的界面，上面是一个计数器，下面是一张介绍图。所以下面直接用了Image标签来做。但是在测试中发现了一个问题，部分的Android手机上面展示不出来图片。使用Android studio检查了下log，发现了如下的错误： OpenGLRenderer: Bitmap too large to be uploaded into a texture (750x4520, max=4096x4096 这个因为图片的尺寸过大（注意，不是大小哦），导致Android手机不能渲染，那么怎么解决这个问题呢？ 解决这里推荐使用webView，RN提供的webView功能还算强大，可以把它作为一个容易来装图片，最重要的是，大部分的Android手机对webView的优化还是非常不错的。而且webView还支持多种格式，你甚至可以把html代码写入一个字符串中传给webView。具体请参考wiki:http://reactnative.cn/docs/0.43/webview.html#content 实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758let leftNum = this.getLeftNumberText(); const HTML = ` &lt;!DOCTYPE html&gt;\n &lt;html&gt; &lt;head&gt; &lt;title&gt;Hello Static World&lt;/title&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=320, user-scalable=no&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; margin:0; padding:0; &#125; img&#123; width:100%; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;https://m.tuniucdn.com/fb2/t1/G1/M00/F1/51/Cii9EFkAaZ-IRgGNAATB18ldk0UAAJzuQN-p1cABMHv15.jpeg&quot;/&gt; &lt;/body&gt; &lt;/html&gt; `; let image = ( &lt;Image style=&#123;styles.image&#125; source=&#123;&#123;uri: &apos;https://m.tuniucdn.com/fb2/t1/G1/M00/F1/51/Cii9EFkAaZ-IRgGNAATB18ldk0UAAJzuQN-p1cABMHv15.jpeg&apos;&#125;&#125;/&gt;); let webView = ( &lt;WebView style=&#123;styles.image&#125; automaticallyAdjustContentInsets=&#123;false&#125; source=&#123;&#123;html:HTML&#125;&#125; javaScriptEnabled=&#123;true&#125; domStorageEnabled=&#123;true&#125; decelerationRate=&quot;normal&quot; startInLoadingState=&#123;true&#125; scalesPageToFit=&#123;false&#125; onLoadEnd = &#123;()=&gt;&#123;console.log(&apos;loading end&apos;)&#125;&#125; onError = &#123;()=&gt;&#123;console.log(&apos;loading error&apos;)&#125;&#125; /&gt; ) let ImageShow = Platform.OS===&apos;android&apos; ? webView: image; return ( &lt;View style=&#123;styles.bgView&#125;&gt; &lt;Header title = &apos;牛大头&apos;&gt;&lt;/Header&gt; &lt;ScrollView style=&#123;styles.scrollView&#125;&gt; &lt;View style=&#123;styles.tipBgView&#125;&gt; &lt;Image source = &#123;require(&apos;./images/icon-ask-home-tip.png&apos;)&#125; style=&#123;styles.tipIcon&#125;/&gt; &lt;Text style=&#123;styles.tipText&#125;&gt;&#123;leftNum&#125;&lt;/Text&gt; &lt;/View&gt; &#123;ImageShow&#125; &lt;/ScrollView&gt; &lt;/View&gt; ) 总结其实我觉得， 如果是营销界面，最好是公司提供一整套可以配置的H5界面，这样可以直接使用后台的CMS后台去配置出来一个界面，节省人力，效率高。 如果一定要Native或者RN来做的话，像我们这次H5前端人力比较紧张，那就可以Native的开发上。直接写H5界面放到webView中，还是比较方便的。当然如果是比较复杂的，还是要Native实现的，这里仅提供一种思路。 前端大融合，指日可待啊。]]></content>
      <categories>
        <category>React-Native</category>
      </categories>
      <tags>
        <tag>React-Native</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fastlane上传appStore功能调研]]></title>
    <url>%2F2017%2F05%2F17%2Ffastlane%E4%B8%8A%E4%BC%A0APPStore%E8%B0%83%E7%A0%94%2F</url>
    <content type="text"><![CDATA[背景目前jenkins服务器上面使用的版本比较老，是1.* 的版本。这个版本的deliver，自定义的功能比较少，存在以下弊端： 如APP正在审核版本9，这时候上传一个版本,deliver会自动取消当前版本的审核状态。而这种自动的提交和取消审核状态是团队无法接受的。 所以今天调研了最新的版本 文档查看了deliver的最新文档，最新的提供了新的参数submit_for_review，目前配置如下： 1234app_identifier &quot;com.**.**&quot; # The bundle identifier of your app username &quot;njafei@163.com&quot; # your Apple ID userforce true #don’t show me the preview htmlsubmit_for_review false # 这个开关就是控制是否要展示的 使用流程1234$ fastlane deliver init //初始化fastlane 会生成配置文件Deliverfile、文档数据（用于各种说明等）文件夹metadata、screenshots（展图）等文件$ 输入itunes connenct账号等$ 配置Deliverfile文件，配置同文档中所列$ fastlane deliver *.ipa 数据直接使用公司网络上传3次，均失败使用lantern上传了8次，成功了一次,上传时间大约20min 线上无app在review中：正常上传，无影响线上有app在review中：正常上传，无影响 其他使用deliver的话，一定要配置一个版本更新说明，地址在./metadata/zh-Hans/release_notes.txt; #总结fastlane的上传功能现在已经可以满足使用条件，但是网络状态实在比较差，可以考虑写脚本由上传人员使用，配合jenkins的话，恐怕失败率比较高]]></content>
      <categories>
        <category>自动化</category>
      </categories>
      <tags>
        <tag>自动化</tag>
        <tag>fastlane</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之变量的解构赋值]]></title>
    <url>%2F2017%2F05%2F11%2FES6%E4%B9%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[什么是解构赋值以前，如果我们想给一个变量赋值，通常是这样（在Objective-C等语言中，现在仍然是如此）： 123let a = 1;let b = 2;let c = 3; 而ES6现在支持了类似这样的用法： 1let [a,b,c] = [1,2,3]; 从而大大简化了变量赋值的语法，而且为诸如：Json解析、函数默认值用法提供了支持，文章最后会介绍。 JS的变量解构赋值，实际上的一种模式匹配，比如：{模式1} = {模式2}，如果模式1能够部分或者完全匹配模式2，则匹配成功的模式1的部分变量就会被赋值为匹配到的值，否则赋值为undefined。这是解构赋值的核心思想，后面的各种类型的解构赋值其实都是这种思想的具体体现。 另外解构赋值，要求赋值对象，即等号右边的值，一定是一个可以遍历的结构，即符合Iterator接口。 接下来会依次介绍以下几种用法： 数组的解构赋值 对象的解构赋值 字符串的解构赋值 数值、布尔值的解构赋值 函数参数的解构赋值 圆括号问题 在开始前，还有个关于null和undefined的小知识介绍下，js 中，null === undefined 是false。两者的区别在于： null表示”没有对象”，即该处不应该有值。 undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义 具体的可以看下阮一峰的文章：undefined与null的区别。下面的文章会用到这点。 数组的解构赋值数组的结构赋值比较简单，我们下面通过一些不同的例子来看下： 正常结构1234let [a,b,c] = [1,2,3];a // 1b // 2c // 3 嵌套结构12345let [a,[b,c],d] = [1,[2,3],4];a // 1b // 2c // 3d // 4 …语句123let [a, ...b] = [1,2,3];a // 1b // [2,3] 缺省变量123let [a, ,c] = [1,2,3];a // 1c // 3 解构不完全成功1234let [a,b,c] = [1,];a // 1b // undefinedc // undefined 另外还有两个注意点： 如果右侧不是一个可遍历的结构，则会报错，如： 1let [foo] = 1;//error 使用let，const，不可以重复定义变量，如： 12let a ;let [a,b] = [1,2];//error: Duplicate declaration 默认值解构赋值是允许给变量默认值的，如果解构失败(模式匹配不上，或者赋值为undefined)，则会使用默认值。如： 123let [a = 1, b = 2] = [1,];a // 1b // 2 在前面章节，讲了null和undefined，如果赋值null，系统是不会使用默认值的，因为null和undefined是不严格相等的。如： 123let [a = 1,b] = [1,null];a // 1,b // null, 另外默认值可以引用解构赋值的其他变量，前提是这个变量已经声明了，如： 123let [x = 1, y = x] = []; // x=1, y=1let [x = 1, y = x] = [2];// x=2, y=2let [x = y, y = x] = []; // error y undefined 对象的解构赋值对象和数组的重要区别就是，前者是顺序的，后者是非顺序的，所以对象的解构赋值，更加能体现模式匹配的意义。 如何理解我们先讲回数组的解构赋值，其实可以这样理解： 1let [a, [b, c], d] = [1, [2,3], 4]; a可以理解为模式1，[b,c]可以理解为模式2， d可以理解为模式3函数可以这样写 1let [模式1，模式2，模式3] = [匹配模式1,匹配模式2,匹配模式3]; 在数组中，模式的匹配是根据，的因为数组是有序的，而在对象中，模式匹配则是根据模式的key。比如： 123let &#123;foo, bar&#125; = &#123;foo: &apos;fooValue&apos;, bar: &apos;barValue&apos;&#125;;foo // &apos;fooValue&apos;bar // &apos;barValue&apos; 我们根据模式匹配的思想，其实等号左边就是{模式1，模式2},等号右边就是{模式1：模式1值，{模式2：模式2值}}，所以上述代码的完整版是： 1let &#123;foo模式: foo模式实例foo, bar模式: bar模式实例bar&#125; = &#123;foo模式: foo模式实例&apos;fooValue&apos;, bar: bar模式实例&apos;barValue&apos;&#125;; 这里我们一定要区分的就是模式名和模式实例，比如： 123let &#123;foo:[1,bar]&#125; = &#123;[1,2]&#125;;bar // 2foo // undefined 这里的foo是模式名，并不是变量，所以不会被赋值. 嵌套对象的注意点有嵌套对象的时候，需要注意，如果子对象的父属性不存在，会报错，如： 1let &#123;foo: &#123;bar&#125; = &#123;bar: &apos;bar&apos;&#125;&#125;;//TypeError: Cannot read property &apos;bar&apos; of undefined 这中间的流程是这样的： 12let _tmp = &#123;bar: &apos;bar&apos;&#125;;_tmp.foo.bar;//error 已声明的变量赋值注意点大括号的情况要注意，会被系统理解为代码块，发生错误： 12let x ;&#123;x&#125; = &#123;x: 1&#125;; 在外面加上圆括号可以解决: 12let x ;(&#123;x&#125; = &#123;x: 1&#125;); 字符串的解构赋值字符串在被解构赋值的时候，会被转换成类似数组的对象： 12345let [a,b,c,d] = &apos;hello&apos;;a // &apos;h&apos;b // &apos;e&apos;c // &apos;l&apos;d // &apos;l&apos; 属性解构这里要介绍个好玩的东西，解构不止能解构值，还能解构属性，因为这里用的都是.语法,比如： 1234let &#123;length: len&#125; = &apos;hello&apos;这里最终执行的是：let _tmp = [&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;];len = _tmp.length;//这里本来是要报错的，但是_tmp恰好有length属性，所以len 是 5 数值和布尔值的解构赋值在数值和布尔值的情况下，等号右边会先转换成对象。 比如： 123let &#123;foo&#125; = 123;实际执行是：let foo = 123.foo; 这里还是可以用属性解构： 12let &#123;toString: s&#125; = 123;s // function toString() &#123; [native code] &#125; 这里的数值和布尔值的结构赋值，我目前不太了解具体的实际用法，如果读者知道，麻烦告诉我哈。 函数参数的结构赋值这里和对象的解构赋值一模一样，不具体介绍 圆括号问题学过编译原理的人都知道，编译原理到底有多变态，所以编译器的感受应该和我们一样（笑）。在遇到（）的时候，编译器也会出现问题，所以这里有个原则： 能不适用圆括号，就不要使用 除非，满足两个条件 不是定义变量，而是赋值 不在模式部分适用 比如： 12&#123;p:(a)&#125; = &#123;p : &apos;a&apos;&#125;;a // &apos;a&apos; 其他的都会报错 用途解析多个值在使用函数的时候，经常会返回多个值（js中常见，其他的还真的不常见），用解构赋值的话，语法就会非常简单： 1let &#123;a,b,c&#125; = foo(); 函数的参数和默认值1function foo (&#123;a = 1,b = 2,c = 3&#125;)&#123;&#125;;// 这里可以节省判断入参的代码 和map结合12345678let map = new Map();map.set(&quot;key1&quot;,&quot;value1&quot;);map.set(&quot;key2&quot;,&quot;value2&quot;);for (let [a, b] of map) &#123; console.log(&apos;key is &apos; + a, &apos;value is &apos;+ b);&#125; 载入模块使用1import &#123;foo1,foo2&#125; from &apos;react-native&apos;; 这里的用法其实大都差不多，主要是用来简化代码，提高可读性。]]></content>
      <categories>
        <category>React-Native</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片的展示清晰度问题研究]]></title>
    <url>%2F2017%2F05%2F05%2F%E5%9B%BE%E7%89%87%E6%B8%85%E6%99%B0%E5%BA%A6%E6%8E%A2%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[前两天产品经理找我，说是首页的轮播图，看起来很模糊，我看了下，确实是效果不好，很多的字看起来不都清晰，看明白是什么很费劲。 看起来效果像是这样（忽然想起一个老朋友，北大高材生，居然喜欢杨幂，这里就用大幂幂吧） 我当时的第一反应就是是不是原图就不清晰。然后我抓包，拿到了图片链接，但是链接的图片在浏览器中看起来效果很不错，像这样： 但是展示在手机上的效果，真的差强人意，尤其是有文字的时候，文字的边缘锐化的效果很明显。 百思不得其解的时候，发现原图的链接给的尺寸，比手机行的设定尺寸大了好多。做iOS App开发的都知道，因为手机是retina屏，所以要求给的图都是2x和3x的，比如 100 100的图，我们通常要设计师给的是 200 200的，6p等是 300 300.但是这张图，我们需要的是200 100的，通常给 600 300肯定够了，但是服务端给的是 1200 600的，比我们需要的长宽大了两倍。然后我自己用这张图，转换了一张 600 * 300的图，debug发现效果非常好。和服务端沟通了下，给出的原因是：因为公司的图片尺寸是有限的，所以当时找了一个最接近长宽比的给前端。 又找了UI的大神聊了，上述的原因是这样的： 如果一个 9 9的图，想要在 1 1的图片中显示，怎会随机从9个像素中选取一个放到1 * 1 中，所以就失真了，类似这样： 1 2 3 4 5 6 7 8 9 n 1 &lt;= n &lt;= 9 所以呢，想要图片在app上展示出最好的效果，其实不在于图片要切的非常大，而是图片的尺寸再好和你设计的差不多，否则会失真。]]></content>
      <categories>
        <category>闲来研究</category>
      </categories>
      <tags>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS Runtime 详解]]></title>
    <url>%2F2017%2F05%2F04%2Fruntime%2F</url>
    <content type="text"><![CDATA[什么是runtime依照苹果文档的说法，runtime是： The Objective-C language defers as many decisions as it can from compile time and link time to runtime.（尽量将决定放到运行的时候，而不是在编译和链接过程） 如何理解这段话呢，我们首先要知道，一段代码从写完到最终执行的过程中发生了什么。 从代码到可执行文件的过程这是《深入理解计算机系统(第2版)》里面的一张截图： 主要过程我们可以简化成三个： - 编译 - 链接 - 运行 编译：将代码转换成底层可执行的语言（如汇编），简单来讲，就是把你能看懂的语言，转换成系统底层可以看懂的东西，这中间通常会有优化，先预处理，再编译。 链接：在编译的过程中，如果有调用其他的类的方法等，是不会检查或者报警的，编译的时候会默认你已经实现了。而链接就是去检查调用的方法或者类等是否确实存在。 运行：执行最终的可执行文件 如果是普通的C语言代码，我们使用的是传统的编译运行，那么一个函数的执行内容，在编译阶段其实就确定了，执行的时候只要去执行对应的内存地址的程序就好。 而在runtime中，编译阶段只能确定最终要执行的函数名，但是具体执行的时候，执行的是什么程序，是在运行的时候才能确定，大大增加了程序的灵活性。 Objective-C runtime介绍简介Objective-C是一门运行时语言，这意味着代码执行可以更加灵活：我们动态的创建一个新的类，还可以转发消息给其他的消息。（消息转发是runtime的一个重要组成部分，后面会介绍）。 这种特性要求Objective-C语言会尽可能把决定从编译和链接的阶段延迟到运行时(runtime)阶段，因此Objective-C不仅有一个编译器，还有一个runtime系统来执行被编译过的代码。 版本和平台runtime是有个两个版本的: legacy 、 modern在Objective-C 1.0使用的是legacy，在2.0使用的是modern。这里简单介绍下区别： 在legacy runtime，如果你改变了实例变量的设计，需要重新编译它的子类。支持 32bit的OS X 程序 在modern runtime，如果你改变了实例变量的设计，不需要重新编译它的子类。支持iphone程序和OS X10.5之后的64bit程序 因为legacy是如此的古老，我们基本可以忽略legacy版本。 Runtime交互有三种方式可以使用Runtime： Objective-C 源代码 NSObject 方法 Runtime 方法 Objective-C 源代码一般来说，runtime都是默默地在后台运行工作，我们只是写Objective-C源代码，就使用了runtime。当我们编译包含Objective-C的类和方法时，编译器就会生成包含runtime特性的数据结构和方法。数据结构中包含了从类、category、协议中定义的的信息，如：selector、变量等等。主要的runtime方法是发送信息的方法Message,在下一章节会讲到。 NSObject方法Cocoa中大部分的类都是继承自NSObejct，所以他们都会集成了NSObject定义的方法。（值得注意的例外是NSProxy类）因此NSObject的方法就决定了其他类的行为。（当然，在少数情况下，这样说并不正确，在这些情况下，NSObject会仅仅定义了方法，没有实现必须的代码。比如description，如果子类没有重写，那么会返回类名和地址，这是因为NSObject没法获得更多的信息。） 一些NSObject类的方法可以直接查询runtime系统的信息，从而获得自身的信息。比如class，isKindeOfClass，respondsToSelector等方法。 Runtime方法Runtime系统是一个共享的library，包含了许多方法和数据结构，地址在/usr/include/objc。其中的很多方法，允许你使用C来重写编译行为，其他的方法是通过NSObject类使用。有了这些方法，我们就可以为runtime系统增加接口，或者工具。 Message先抛出来一个问题，这句话代表什么？ [receiver message] receiver执行message函数？ 是这个作用,但是more than that，等价于这行代码 1objc_msgSend(receiver, @selector(message)) 所以其实message是iOS中非常重要的一环，尤其是在动态绑定中。下面我们具体看下： objc_msgSend上面讲了，iOS中的函数调用其实是给实例发送了message，有参数的函数其实执行了： 1objc_msgSend(receiver, selector, arg1, arg2, ...) objec_msgSend的方法定义如下： 1OBJC_EXPORT id objc_msgSend(id self, SEL op, ...) 那么，消息转发的过程究竟发生了什么呢？我们先看下这里用到的三个类：对象(object)，类(class)，方法(method) 1234567891011121314151617181920212223242526272829303132333435363738394041//对象struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;;//类struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;//方法列表struct objc_method_list &#123; struct objc_method_list *obsolete OBJC2_UNAVAILABLE; int method_count OBJC2_UNAVAILABLE;#ifdef __LP64__ int space OBJC2_UNAVAILABLE;#endif /* variable length structure */ struct objc_method method_list[1] OBJC2_UNAVAILABLE;&#125; OBJC2_UNAVAILABLE;//方法struct objc_method &#123; SEL method_name OBJC2_UNAVAILABLE; char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE;&#125; 系统首先找到消息的接收对象，然后通过对象找到它的类。 在它的类中查找method_list，是否有selector方法。 没有则查找父类的method_list 找到对应的method，执行它的IMP 转发IMP的return值 selector和IMP、method等的区别，可以参考我的另一篇博客Method,SEL,IMP 注意：编译器会生成messaging方法，所以你永远都不应该手动调用这个方法。 dispatch tablemessaging的关键在于编译器给每个类创建的数据结构，每个类的数据结构都包含两个要素： 执行父类的指针 一个类分发表(dispatch table)。表中有所有的相关方法和这些方法的地址和id。 runtime系统，要求对象必须等价于objc_object,NSObject和NSProxy都自动包含isa属性。 结构和原理如图所示： 当消息被发送给对象的时候，消息就按照上图的路径寻找对应的selector，直到达到NSObject，如果在NSObject中还是没有找到对应的方法，则会走到消息转发机制中，下文会介绍。 cache为了加速消息分发， 系统会对方法和对应的地址进行缓存，就放在上述的objc_cache，所以在实际运行中，大部分常用的方法都是会被缓存起来的，runtime系统实际上非常快，接近直接执行内存地址的程序速度。 Message Forwarding如果在dispatch table中没有找到对应的method呢？ 系统仍然会给你补救的机会： resolveInstanceMethod/resolveClassMethod fast forwarding normal forwarding resolveInstanceMethod系统没有在dispatch_table中找到对应的方法，会看你是否重写了resolveInstanceMethod，resolveClassMethod,这里两个方法是否用来添加动态方法的，一个是实例方法，一个是类方法。 举个例子：我们有个ClassA 123456789#import &lt;Foundation/Foundation.h&gt;@interface ClassA : NSObject@end@implementation ClassA@end 希望执行ClassA并不存在的foo方法 12ClassA *a = [ClassA new];[a performSelector:@selector(foo)]; 系统会直接报错： 1Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[ClassA foo]: unrecognized selector sent to instance 0x600000004e00&apos; 如果我们想用resolveInstanceMethod来补救，该怎么做呢？ 12345678910111213141516#include &lt;objc/runtime.h&gt;void foo(id self, SEL _cmd) &#123; NSLog(@&quot;resolveInstanceMethod add method foo &quot;);&#125;@implementation ClassA+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; if (sel == @selector(foo)) &#123; class_addMethod([self class], sel, (IMP)foo, &quot;v@:&quot;); return YES; &#125; return [super resolveInstanceMethod:sel];&#125; 注意：一定要记得import &lt;objc/runtime.h&gt;，否则会报错：class_addMethod is valid in C99 执行下，log： 1resolveInstanceMethod add method foo 这里的return YES 或者 return NO,是告诉系统是否实现了这个方法，如果return YES，但是并没有增加方法，还是会报错，并且不会走到forward，因为系统默认你已经在这一步做了resolveInstanceMethod这个事情。 forwardingTargetForSelector如果上一步骤的resolveInstanceMethod return no，系统会走forwardingTargetForSelector，这一步被称为快速转发，是因为相对下面要介绍的normal fastward，这一步直接转发了消息，而normal fastward生成了NSInvocation，相对直接转发慢一些。 先看下如何实现，比如，我想把消息转发给有能力的classB： 123456789101112131415@interface ClassB : NSObject- (void)foo;@end@implementation ClassB- (void)foo&#123; NSLog(@&quot;ClassB foo run&quot;);&#125;@end A中需要实现forwardingTargetForSelector方法： 12345678- (id)forwardingTargetForSelector:(SEL)aSelector&#123; if(aSelector == @selector(foo))&#123; ClassB *b = [ClassB new]; return b; &#125; return [super forwardingTargetForSelector:aSelector];&#125; run一下，log： 1ClassB foo run 苹果的文档里，讲述了这一个消息转发的出发点，其实是为了实现类似C多继承的功能。我们知道，在C中如果一个类想要具有多个类的功能，是可以直接继承多个类的。而Objective-C是单继承，如果想实现类似的功能，就用消息转发，将消息转发给有能力处理的类。苹果是这样描述他们的思想的：C的多继承，是加法，在多继承的同时，其实也增加了很多不需要的功能，而苹果通过消息转发，实现了减法的思想，只留有用的方法，而不去增加过多内容。 forwardInvocation如果你的类没有实现forwardingTargetForSelector方法，系统会调用methodSignatureForSelector方法，如果这个方法返回一个函数的签名，则执行forwardInvocation方法，否则执行doesNotRecognizeSelector。 如果希望在这一步补救，如何做呢？ 12345678910111213141516- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; return [ClassB instanceMethodSignatureForSelector:aSelector];&#125;- (void)forwardInvocation:(NSInvocation *)invocation&#123; SEL sel = invocation.selector; ClassB *b = [ClassB new]; if([b respondsToSelector:sel]) &#123; [invocation invokeWithTarget:b]; &#125; else &#123; [self doesNotRecognizeSelector:sel]; &#125;&#125; 流程图我自己画了个消息转发的流程图： 其他隐藏参数刚才讲了，在一个对象执行一个函数的时候，其实是： 1objc_msgSend(receiver, selector, arg1, arg2, ...) 那其实在函数中，receiver和selector是两个隐藏的参数，这两个参数是可以使用的。 1234- (void)run&#123; [self performSelector:_cmd]; //self: 当前对象 _cmd : &quot;run&quot;&#125; 获取method的地址如果你要连续执行同一个method，但是觉得每次都要遍历一遍分发表会效率低，可以直接获取地址(methodForSelector)，然后直接执行函数. 1234567void (*setter)(id, SEL, BOOL);int i; setter = (void (*)(id, SEL, BOOL))[target methodForSelector:@selector(setFilled:)];for ( i = 0 ; i &lt; 1000 ; i++ ) setter(targetList[i], @selector(setFilled:), YES); 个人觉得，这样意义不大，因为其实系统会做缓存。 runtime实际应用runtime的应用，主要有几种： AOP,切面编程，做打点 method swizzling,黑魔法做崩溃等的保护 因为主要是使用method swizzling来做，我将会在之后的博客中专门介绍。 参考文章： 关于编译和链接，可以看下 http://www.cprogramming.com/compilingandlinking.html 这篇文章。 ObjCRuntimeGuide http://stackoverflow.com/questions/3900549/what-is-runtime http://tech.glowing.com/cn/objective-c-runtime/ http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/ http://tech.glowing.com/cn/objective-c-runtime/]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>Apple文档</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Method,SEL,Imp]]></title>
    <url>%2F2017%2F05%2F03%2FMethod-SEL-IMP%2F</url>
    <content type="text"><![CDATA[这三个概念，虽然在平时的时候总是在用，但是最近写runtime的时候，又感觉有点糊涂，今天就把他们的关系搞清楚。 Method先看下定义 123456789runtime.h/// An opaque type that represents a method in a class definition.代表类定义中一个方法的不透明类型typedef struct objc_method *Method;struct objc_method &#123; SEL method_name OBJC2_UNAVAILABLE; char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE;&#125; Method和我们平时理解的函数是一致的，就是表示能够独立完成一个功能的一段代码，比如： 1234- (void)logName&#123; NSLog(@&quot;name&quot;);&#125; 这段代码，就是一个函数。 我们来看下objc_method这个结构体的内容： SEL method_name 方法名 char *method_types 方法类型 IMP method_imp 方法实现 在这个结构体重，我们已经看到了SEL和IMP，说明SEL和IMP其实都是Method的属性。 我们接着来看SEL。 SEL还是先看定义123Objc.h/// An opaque type that represents a method selector.代表一个方法的不透明类型typedef struct objc_selector *SEL; 这里要先说明下selector和SEL的关系，我在写本文的时候，其实搜索的是selector，直到我看到了selector的定义，才发现我理解一直不对。 1@property SEL selector; 在文档中，selector的定义都是这样声明，也就是说：selector是SEL的一个实例，只是在iOS中，selector的使用是如此的频繁，我们才会把他当成一个概念。 selector怎么理解呢？我们可以想想股票，比如市场上有如此多公司在纳斯达克上市，而且他们的名字又非常的长，或者有些公司的名称也是相似的，都是**有限公司。那当市场去指定一个股票的时候，效率会非常低，当你着急想买股票的时候，你会跟你的经纪人说：“hi，peter，给我买一百股Tuniu limited liability company的股票吗？”，也许等你说完，经纪人输入完，市场就变化了，所以纳斯达克通常用代码，比如“TOUR”.这里的selector有类似的作用，就是让我们能够快速找到对应的函数。 文档中是这样讲的： A method selector is a C string that has been registered (or “mapped“) with the Objective-C runtime. Selectors generated by the compiler are automatically mapped by the runtime when the class is loaded. 在iOS中，runtime会在运行的时候，通过load函数，将所有的methodhash然后map到set中。这样在运行的时候，寻找selector的速度就会非常快，不会因为runtime特性牺牲太多的性能。 selector既然是一个string，我觉得应该是类似className+method的组合，命名规则有两条： 同一个类，selector不能重复 不同的类，selector可以重复 这也带来了一个弊端，我们在写C代码的时候，经常会用到函数重载，就是函数名相同，参数不同，但是这在Objective-C中是行不通的，因为selector只记了method的name，没有参数，所以没法区分不同的method。 比如： 123- (void)caculate(NSInteger)num;- (void)caculate(CGFloat)num; 是会报错的。 我们只能通过命名来区别： 123- (void)caculateWithInt(NSInteger)num;- (void)caculateWithFloat(CGFloat)num; IMP看下IMP的定义 123/// A pointer to the function of a method implementation. 指向一个方法实现的指针typedef id (*IMP)(id, SEL, ...); #endif 这个就比较好理解了，就是指向最终实现程序的内存地址的指针。 综上，在iOS的runtime中，Method通过selector和IMP两个属性，实现了快速查询方法及实现，相对提高了性能，又保持了灵活性。]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>Apple文档</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLite-Python学习]]></title>
    <url>%2F2017%2F04%2F28%2Fsqlite-python%2F</url>
    <content type="text"><![CDATA[注： 本文默认有基本的数据库和SQLite知识 最近在做SQLite数据库相关的自动化任务，所以学习了下phthon中如何使用SQLite，网上的教程如：runoob、 docs.python等的说明不太详细，而且很多细节和demo都写的比较粗，遂有此文。 连接数据库首先我们要连接数据库，要不然没法操作。python2.5之后，内置了sqlite3，所以我们可以直接用内置的命令。 介绍第一个命令 1sqlite3.connect(database [,timeout ,other optional arguments]); database： 数据库的path，如果不给，就会创建一个。如果给的“:memory:”，则会创建一个建在RAM上的数据库。 timeout: 默认是5s，当数据库锁定的时候，最长的等待时间 optional arguments： 暂时没查到有哪些参数可选 比如我们想要新建一个数据库： 123456#!/usr/bin/pythonimport sqlite3newData = sqlite3.connect(&apos;new.sqlite&apos;)print &quot;open new Database successfully&quot;; 这样，就建好了一个名为new的数据库，并连接上。 如果想建一个RAM上面的数据库，就使用:memory: 1newData = sqlite3.connect(&apos;:memory:&apos;) 还可以设置10s的timeout： 1newData = sqlite3.connect(&apos;:memory:&apos;[,10]); 关闭数据库连接就比较简单了： 1newData.close(); 数据库执行SQL语句执行简单语句这里主要有两种方式： 数据库直接执行 connection.execute() 通过cursor执行 cursor.execute 举个例子，我们希望建一个如下的数据表并插入数据：user id name money 1 jack 100 1 rose 200 12345678910111213141516#create tablenewData.execute(&quot;create table user (id, name, money)&quot;);#insert datanewData.execute(&quot;insert into user values (1,&apos;jack&apos;,100)&quot;);newData.execute(&quot;insert into user values (2,&apos;rose&apos;,200)&quot;);#打印看下是否成功users = newData.execute(&quot;select * from user&quot;);print(&apos;row in new data&apos;);for row in users: print row[0], print row[1]newData.commit();newData.close(); 这里面有个注意点：一定要commit 和 close ，否则不会保存。 commit: 该方法提交当前的事务。如果您未调用该方法，那么自您上一次调用 commit() 以来所做的任何动作对其他数据库连接来说是不可见的。 这里的execute也可以用cursor执行： 12345#获取cursorc = localData.cursor()#cursor执行语句c.execute(&quot;select * from user&quot;); 执行带参数的语句如果我们有用到python里声明的变量，就只能通过cursor了。比如想要计算数组的和，放到amy的money中： 这里先介绍下有参数的命令： 123cursor.execute(sql, seq_of_parameters)cursor.execute(&quot;insert into people values (?, ?)&quot;, (who, age)) execute只接收两个参数，sql和param，sql中的变量名，都用?或者命名代替，然后依次写在参数中。记住，一定要放到一个括号中，否则会认为有三个参数，会报错：TypeError: function takes at most 2 arguments (3 given) 实现代码如下： 123456789101112#获取cursorc = localData.cursor()#计算总和name = &apos;amy&apos;;total = money + money2 + money3;#写入rose的钱中c.execute(&quot;inset into user value (3, ?, ?)&quot;,(name,total));#or #c.execute(&quot;inset into user value (3, name, money)&quot;,(name,total)); 注意：这里的connect也可以执行带参数的语句，但是其实都是生成临时cursor执行，所以这两种方法本质是一样的，下文中遇到这两个，只会写一个作为示范。 处理多组数据如果我们希望针对一组数据，执行同样的sql呢？当然可以for: in 来挨个执行，也可以使用批量的数据处理方法： cursor.executemany(sql, seq_of_parameters) connection.executemany(sql[, parameters]) 最终还是通过cursor执行 比如刚才的例子，我们不用一条一条数据插入，而是直接插入一个数组： 12newUsers = [(1,&apos;jack&apos;,100),(2,&apos;rose&apos;,100)];newData.executemany(&quot;insert into user values(?,?,?)&quot;,newUsers); 处理多条语句如果是想连续执行多条语句如何呢？ cursor.executescript(sql_script) connection.executescript(sql_script) 比如： 1234sqlscript = &quot;&quot;&quot;insert into user values(1,&apos;jack&apos;,100); insert into user values(2,&apos;rose&apos;,200);&quot;&quot;&quot;newData.executescript(sqlscript); 操作cursor这里的cursor可以理解为我们变成时候的光标，光标在哪里，我们当前的操作点和关注点就在哪里。而当我们多次操作的时候，可能想要获取当前光标所在的位置。 还是举个例子： id name money 1 jack 100 2 rose 200 3 john 200 我希望查到谁的money是200，而且我想获得当前的光标坐在的位置： 1234567891011121314c = newData.cursor();c.execute(&quot;select * from user where money = 200&quot;);#查第一条c.fetchone();//(2,rose,200)# 查前两条c.fetchmany(2);// (2,rose,200),(3,john,200)# 查所有的c.fetchall();//(2,rose,200),(3,john,200)#如果没有结果返回nonec.execute(&quot;select * from user where money = 300&quot;);c.fetchone();//none 说实话，刚开始看我是很疑惑的,看起来，这个光标的作用和我直接用一个数组赋值貌似没有什么区别，难道是这样比较方便来获取最后的结果么？ 后来问了大神，发现原来光标是这样子的，fetch了一条，光标会下移，比如： 1234c.execute(&quot;select * from user where money = 200&quot;);print c.fetchone();//(2,rose, 200)print c.fetchone();//(3,john,200)print c.fetchone();//none 再结合一些操作光标的操作，就可以实现一些比较复杂的用法了。 操作相关数据库的操作和git还是有点相似的，都是有提交，回滚等，我们依次介绍下： connection.commit() 提交修改，否则不会保存 connection.rollback() 回滚上次的commit connection.close() 关闭数据库连接 connection.total_changes() 查看修改的总行数]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>sqlite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVC详解]]></title>
    <url>%2F2017%2F04%2F18%2FKVC%2F</url>
    <content type="text"><![CDATA[综述关于正常访问或者修改一个对象的属性，都是通过getter和setter方法，但是Cocoa仍然提供了一个间接访问属性的方法：KVC（Key-Value Coding）。 只要对象支持NSKeyValueCoding协议，我们就可以通过KVC来间接访问或者修改属性和属性中的更深层的属性。 KVC也是许多Cocoa技术的基础，比如： KVO Cocoa bingdings Core Data AppleScript。 使用KVC的对象所有继承NSObject的类都支持KVC，NSObject实现了NSKeyValueCoding和必要的方法。通过KVC，可以做到以下功能： 获取对象属性 比如使用 valueForKey 和 setValue:forkey:来获取和修改属性 操作Collection类型的的属性，比如NSArray、NSSet 使用Collection运算符 非对象的values 路径搜索的步骤（本文不会讲这个，请自己看文档） 下面，我们来挨个看下上面的5种用法 获取对象属性属性可以分为3个类型： Attributes（简单属性），比如string，int，bool等简单类型 To-one relationships（单一关系），比如一个Person类的实例 To-many relationships（多个关系），比如NSArray或者NSSet 来看下例子,这个一家人的类： 123456789101112131415@interface Person : NSObject@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) NSInteger age;@end@interface Family : NSObject@property (nonatomic) NSNumber* numbers; // An attribute@property (nonatomic) Person* boss; // A to-one relation@property (nonatomic) NSArray&lt; Person* &gt;* members; // A to-many relation@end 通过key与keyPath读取属性在介绍如何读取之前，我简单说下key和keyPath。key可以简答理解为对象某个属性的名称，而keyPath是又.区分的一串string，用来读取更深层的value。举个列子：对于Family来说，他的key有几个：numbers、boss、members。我们可以通过这几个key来读取他对应的属性。但是如果我们想要读取boss的name，一种办法是先读取boss，然后读取boss的name，另一个办法就是我们通过keyPath,直接读取family的boss.name，这个boss.name就是keyPath。 通过key和keyPath读取属性，有以下几个方法： valueForKey: 读取key valueForKeyPath: 读取keyPath dictionaryWithValuesForKeys: 批量读取 还是通过例子来看，我们先初始化几个实例出来： 12345678910111213Person *father = [Person new];father.name = @&quot;Jack&quot;;father.age = 50;Person *mother = [Person new];mother.name = @&quot;rose&quot;;mother.age = 45;Family *family = [Family new];family.numbers = @(2);family.boss = father;family.members = @[father, mother]; 我们分别用上面的三个方法来读取属性： 1234567NSString *fatherName = [father valueForKey:@&quot;name&quot;];NSLog(@&quot;father name: %@,&quot;,fatherName);NSString *bossName = [family valueForKeyPath:@&quot;boss.name&quot;];NSLog(@&quot;boss name: %@,&quot;,bossName);NSDictionary *names = [family dictionaryWithValuesForKeys:@[@&quot;numbers&quot;,@&quot;members&quot;]]; 注意，如果是NSArray、NSSet等类型，不能包含nil，而是转皇城NSNull。系统会在使用的时候自动转换。 通过key和keyPath修改属性有以下几种方法： setValue:forkey: setValue:forKeyPath: setValuesForKeysWithDictionary: 还是直接上例子： 12345[father setValue:@&quot;Jack is gone&quot; forKey:@&quot;name&quot;];[family setValue:@&quot;boss&apos;s name&quot; forKeyPath:@&quot;boss.name&quot;];[family setValuesForKeysWithDictionary:@&#123;@&quot;numbers&quot;:@(3),@&quot;boss&quot;:father&#125;]; 使用KVC简化你的代码讲了半天KVC的使用，那么我们什么时候用？怎么用比较适合呢？看个例子: 如果你有类column，identifier可能是name、age、favoriteColor，你要根据identifier的不同去展示不同的属性。正常写法： 123456789101112131415- (id)tableView:(NSTableView *)tableview objectValueForTableColumn:(id)column row:(NSInteger)row&#123;id result = nil;Person *person = [self.people objectAtIndex:row];if ([[column identifier] isEqualToString:@&quot;name&quot;]) &#123;result = [person name];&#125; else if ([[column identifier] isEqualToString:@&quot;age&quot;]) &#123;result = @([person age]); // Wrap age, a scalar, as an NSNumber&#125; else if ([[column identifier] isEqualToString:@&quot;favoriteColor&quot;]) &#123;result = [person favoriteColor];&#125; // And so on...return result;&#125; 简化写法： 1234- (id)tableView:(NSTableView *)tableview objectValueForTableColumn:(id)column row:(NSInteger)row&#123;return [[self.people objectAtIndex:row] valueForKey:[column identifier]];&#125; 获取Collection对象属性在上面我们看到，其实使用valueForKey:和valueForKeyPath是可以获取NSArray等类型的，但是我们获取的是一个不可变的类型，如果我们希望去修改key或者keyPath对应的数组的时候，怎么做呢？ 使用： mutableArrayValueForKey: 和 mutableArrayValueForKeyPath: mutableSetValueForKey: and mutableSetValueForKeyPath: mutableOrderedSetValueForKey: and mutableOrderedSetValueForKeyPath: 来个例子： 1234567NSMutableArray *members = [family mutableArrayValueForKey:@&quot;members&quot;];Person *son = [Person new];father.name = @&quot;Jack&apos;s son&quot;;father.age = 15;[members addObject: son]; 使用Collection运算符基本组成我们在实际的使用时，会有很多类似于数组平均数、最大值等计算的需求，除了自己写算法计算之外，如果有类似于数据库的快捷操作符，那该多好啊！ 现在，我们就来看下KVC提供的数组等的快捷计算符。 正常使用keyPath的时候，我们通常会使用类似person.son.name等来读取属性。KVC同样提供了@操作符和一些基本的操作，我们可以放到keyPath中，就可以在return之前执行这个操作，然后再返回值了，听起来有点变扭，我们先看下结构： 操作符是由 @符号和操作函数名组成的 在操作符前面的都叫 left key path，这里指定接收消息的对象，为空的话，就是执行keyPath的对象 在操作符后面的都叫 right key path, 这里执行操作的对象，除了数组的@count之外，不能为空 聚合运算这样讲，还是有点虚，我们看个例子： 12345678910111213@interface SaveRecond : NSObject@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) NSInteger money;@end@interface Bank : NSObject@property (nonatomic) NSArray&lt; SaveRecond* &gt;* reconds;@end 初始化下数据： 123456789101112131415SaveRecond *save1 = [SaveRecond new];save1.name = @&quot;Jack&quot;;save1.money = 10;SaveRecond *save2 = [SaveRecond new];save2.name = @&quot;rose&quot;;save2.money = 20;SaveRecond *save3 = [SaveRecond new];save3.name = @&quot;Jack&quot;;save3.money = 30;Bank *bank = [Bank new];bank.reconds = @[save1, save2,save3]; 如果我们想计算这些储户的平均值，可以直接遍历bank的reconds，然后计算，那么，如果用KVC的operation，该如何做呢？一句话解决： NSObject *count = [bank valueForKeyPath:@&quot;reconds.@count&quot;]; 这句话的意思就是 我希望向bank的reconds属性，发送@count消息，执行@count运算。 我们再来看个有right key path的。这里我希望计算出所有记录的平均储蓄值。 NSObject *avg = [bank valueForKeyPath:@&quot;reconds.@avg.money&quot;];这句话的意思是，我希望向bank的reconds属性，发送@avg消息，执行money的avg运算。 同理，计算符还有很多，我这里就不一一介绍了，简单列下，只要学过数据库的，应该没啥问题（没学过？感觉学习下呀0_0） @avg @count @max @min @sum 数组运算刚才用的都是聚合之后的计算，我们看下如何对数组进行计算。比如：我想要知道一共有个用户(去重)。 NSArray *array = [bank valueForKeyPath:@&quot;reconds.@distinctUnionOfObjects.name&quot;]; 这句话的含义是 我希望向bank的reconds属性发送distinctUnionOfObjects消息，执行基于name的distinctUnionOfObjects操作。 这里的运算符有两个： distinctUnionOfObjects 去重 unionOfObjects 不去重 嵌套运算操作如果是想操作一个数组的数组(@[array,array,array])，要怎么样做呢？比如我有两个reconds数组，我想看一共有多少个用户(去重)。 12NSArray *arrayOfArray = @[bank.reconds,bank.reconds];NSArray *array = [arrayOfArray valueForKeyPath:@&quot;@distinctUnionOfArrays.name&quot;]; 这里的运算符有三个： @distinctUnionOfArrays @unionOfArrays distinctUnionOfSets 非对象的values当我们获取的是一个非对象的value，比如int、Bool等值，Cocoa会自动转换成NSNumber等对象包括：bool、char、double、float、int、long等等，这个自己去查文档吧 如果value是一个结构体该如何呢？ 比如NSPoint、NSRange、NSRect、NSSize等还是会返回本类，但是其他的结构体，会被返回一个NSValue 检查属性当我要使用setValueForKey等方法去修改值时，怎么知道是不是合法呢？KVC也提供了方法 validateValue:forKey:error validateValue:forKeyPath:error 这个方法返回一个bool值，有三种情况： value合法，return YES value不合法，但是可以给value重新赋值了一个新的object，return YES value不合法，且不可以赋值挽救，return NO 最坑人的是，这个方法要自己实现，否则默认返回YES。Are you kidding？ 那我干嘛要用你的这个方法。。。]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>Apple文档</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ES6入门》读书笔记之let和const命令]]></title>
    <url>%2F2017%2F04%2F17%2FES6-%E5%85%A5%E9%97%A8-let%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[正在读阮一峰的《ECMAScript 6 入门》,本系列博客都是读书笔记。 ES6 PlayGround在介绍具体的内容之前，想给大家介绍一个好玩的playgroud，尤其合适边看书，边敲代码的同学们。Traceur%3B%0A%7D%0A%0Aconsole.log(b)%3B%0A%0A)这个工具会在你敲完每行代码之后帮你执行检查是否有错误，然后翻译成es5并执行，然后再配合JS控制台，就是很棒的playground了。使用： 打开网页 command + option + J打开javascript控制台 在最左边的框里面输入代码， 效果如下：左边：写代码的地方 中间：翻译之后的js代码，右边：控制台 let命令作用域和var不同ES6中建议全部使用let来生命变量，let和var的作用用法类似，但是let声明的变量，作用域是在其所在的代码块。 1234567&#123; var a = 0; let b = 1;&#125;console.log(a);console.log(b);//ReferenceError： b is not defined 看起来很简单吧，那我们来看下道题目吧 12345678var a = [];for(var i = 0; i&lt; 10 ; i++)&#123; a[i] = ()=&gt;&#123; console.log(i) &#125;&#125;a[7](); 和 12345678let b = [];for(let i = 0; i&lt; 10 ; i++)&#123; b[i] = ()=&gt;&#123; console.log(i) &#125;&#125;b[7](); 答案是：a(7)() : 10b(7)() : 7 你猜对了吗？0_0我第一次看其实是答错了的，然后我把a[7] 和 b[7]打印了出来 123function () &#123; console.log(i); &#125; 我理解是因为let和var的缘故，所以a[7]里面的i实际是就是一个static的变量，在i++之后变成了10，而b[7]里面的i就是7 变量提升let 不会出现变量提升的现象。首先，我们把let抛一边,看下什么是变量提升。先看个代码，猜猜它的结果： 123456789var a = 5;function f()&#123; if(!a)&#123; a = 100; &#125; console.log(a);&#125;f(); 它的输出结果是多少？ 答案： 5，很简单吧，好，我们再看一个相似的函数： 123456789var a = 5;function f()&#123; if(!a)&#123; var a = 100; &#125; console.log(a);&#125;f(); 结果是多少呢？答案是：100 为什么会这样呢？ 作用域作为一个一直在使用OC的程序员，想要弄懂JS的作用域，开始会很别扭，因为两者的作用域是基于不同的标准或者模式。在介绍之前，我们先看下两个C和JS的小例子： C： 12345678910#include &lt;stdio.h&gt;int main() &#123; int a = 1; printf(&quot;%d&quot;,a); //1 &#123; int a = 2; printf(&quot;%d&quot;,a); //2 &#125; printf(&quot;%d&quot;,a);/1&#125; JS: 1234567var a = 1;console.log(a); // 1&#123; var a = 2; console.log(a); // 2&#125;console.log(a); // 2 结果不一样了，为什么呢？ 刚才提到C和Js的作用域的模式不一样，C是基于块级的作用域（block-level scope），每个大括号括起来的都可以理解为一个小的作用域，如果变量在小的作用域里声明，那么在小的作用域中是会忽略外部同名的变量。 而在JS中，则是基于函数的作用域，即每个函数都有自己的作用域（function-level scope），所以上述的列子最后的结果就不一致了，在JS的列子中，a的值其实被覆盖。 C,C++,Java都是块级作用域，那么JS中，如何实现类似的效果呢？答案是使用闭包 123456var a = 0;fucntion f()&#123; var a = 1;//1 console.log(a);//1&#125;console.log(a);//0 在f()这个函数中，会再次定义一个只能在f()中起作用的a,从而实现了类似块级作用域的效果。 变量提升讲完了作用域，我们来看下什么是变量提升，还是先来个列子： 123var a = 0;f();var b = 1; 这三行代码在解释器中会变成： 1234var a , b;a = 0;f();b = 1; 所有var声明的变量的声明语句，都会被解释器给放到变量所在作用域的顶部。注意，只是把生命语句放到最上面，但是不会把赋值等位置提升，这就是所谓的变量提升。 函数也会有变量提升的现象，但是会根据声明方式的不同，有着不同的结果。创建函数的方法有两个： function f(){} 和 var f = function(){},他们会有什么不同呢？ 我们看下列子： 12345678910f1();// TypeError &quot;foo is not a function&quot;f2();// will runvar f1 = function()&#123; console.log(&apos;won&apos;t run&apos;);&#125;function f2()&#123; console.log(&apos;will run&apos;);&#125; 这段代码在解释器中： 1234567891011var f1();function f2()&#123; console.log(&apos;will run&apos;);&#125;f1();// TypeError &quot;foo is not a function&quot;f2();// will runvar f1 = function()&#123; console.log(&apos;won&apos;t run&apos;);&#125; 函数的变量提升，如果是fucntion f()的形式，怎会整个函数都提升到顶部，如果是var f() = function(){}的形式，则只会提升var f()到顶部。 如此，本节开头的两个例子就不难理解了。 123456789var a = 5;function f()&#123; if(!a)&#123; a = 100; &#125; console.log(a);&#125;f(); 在解释器中是： 12345678910var a;function f()&#123; if(!a)&#123; a = 100; &#125; console.log(a);&#125;a = 5;f(); 123456789var a = 5;function f()&#123; if(!a)&#123; var a = 100; &#125; console.log(a);&#125;f(); 在解释器中是： 12345678910var a;function f()&#123; var a; if(!a)&#123; a = 100; &#125; console.log(a);&#125;a = 5;f(); 而let 关键字是不具备变量提升的，所以它声明的变量，其实就是块级作用域。 最后一个例子： 123456789var a = 0;let b = 0;&#123; var a = 1; let b = 1;&#125;console.log(a);//1console.log(b);//0 而在ES5中不会报错的先使用再声明的模式，在ES6中用let的话，就会报错了。比如： 12345678910if (true) &#123;// TDZ开始tmp = &apos;abc&apos;; // ReferenceErrorconsole.log(tmp); // ReferenceErrorlet tmp; // TDZ结束console.log(tmp); // undefinedtmp = 123;console.log(tmp); // 123&#125; 所以建议如下： ES6中永远使用let 所有变量的声明，都写在函数的顶部 这是我在看变量提升的时候，找到一篇质量很棒的blog，本篇的结构和内容也参考了很多Javascript作用域和变量提升 constconst的用法和let基本一致，不可重复定义，不会变量提升，作用域是块作用域。 要注意的是，const修饰一个对象的话，只会限定这个对象的地址不变，不会限定它的值不变，如： 12const foo = &#123;&#125;;foo.pro = &apos;haha&apos;;//work 想要值不变的话，可以使用Object.freeze()方法： 12const foo = Object.freeze(&#123;&#125;);foo.pro = &apos;haha&apos;;//not work 如果想将对象全部冻结，要将里面的每个value都冻结： 123456789let constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach((key,value) =&gt; &#123; if (typeof obj[key] === &apos;object&apos; ) &#123; constantize(obj[key]); &#125; &#125; )&#125;]]></content>
      <categories>
        <category>React-Native</category>
      </categories>
      <tags>
        <tag>React-Native</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN 最容易crash的代码用法及应对措施（持续更新）]]></title>
    <url>%2F2017%2F04%2F17%2FRN-Crash-Reasons%2F</url>
    <content type="text"><![CDATA[变量保护出现最多的就是在使用redux来做数据层，使用this.props的属性没有去查询时候为undefined，这种情况，基本是必crash 比如下例： 12//show user name&lt;Text&gt;&#123;this.props.userInfo.name&#125;&lt;/Text&gt; 如果userInfo为undefined的话，就会崩溃，错误如下： TypeError: Cannot read property ‘name’ of undefined 在这里name为undefined的时候反而没有问题，因为name是一个简单的属性，直接赋值给Text是没有问题的。 那如何避免这种问题呢？在赋值前加下判断会比较好： 1234let name = this.props.userInfo &amp;&amp; this.props.userInfo.name ? this.props.userInfo.name : &apos;&apos;;//show user name&lt;Text&gt;&#123;this.props.userInfo.name&#125;&lt;/Text&gt; 这样基本可以避免崩溃的问题了。 但是如果都这样判断，实际是比较复杂的，所以如果你的业务比较简单，我建议可以直接在render做一个大的保护，即没有数据的时候，不去render这些业务内容.思路如下： 123456789101112render()&#123; if(!this.props.userInfo)&#123; return ( &lt;EmptyView /&gt; ) &#125; else &#123; return ( //注意，如果name的层级更深，还是建议做保护 &lt;Text&gt;&#123;this.props.userInfo.name&#125;&lt;/Text&gt; ) &#125;&#125; 定时器定时器其实在iOS中也是一个非常容易出问题的地方，crash率会比较高。究其原因，我想是主要是因为定时器存在一个事件发生的延后性（废话嘛0_o）,但是很多时候会忘记，当定时任务真的发生的时候，语境变化了吗？如果语境都已经被dealloc了，定时任务仍然被激活，系统就会愤怒地罢工了。 比如： 123456componentDidMount() &#123; setTimeout( () =&gt; &#123; console.log(&apos;这就可能会崩溃&apos;); &#125;, 500 ); &#125; 如果500ms之内，这个component就会Unmount了，那直接回崩溃。RN官方的建议如下： TimerMixin为了解决这个问题，我们引入了TimerMixin。如果你在组件中引入TimerMixin，就可以把你原本的setTimeout(fn, 500)改为this.setTimeout(fn, 500)(只需要在前面加上this.)，然后当你的组件卸载时，所有的计时器事件也会被正确的清除。 这个库并没有跟着React Native一起发布。你需要在项目文件夹下输入npm i react-timer-mixin –save来单独安装它。 1234567891011var TimerMixin = require(&apos;react-timer-mixin&apos;);var Component = React.createClass(&#123; mixins: [TimerMixin], componentDidMount: function() &#123; this.setTimeout( () =&gt; &#123; console.log(&apos;这样我就不会导致内存泄露!&apos;); &#125;, 500 ); &#125;&#125;); 代码保护（推荐）Mixin属于ES5语法，对于ES6代码来说，无法直接使用Mixin。如果你的项目是用ES6代码编写，同时又使用了计时器，那么你只需铭记在unmount组件时清除（clearTimeout/clearInterval）所有用到的定时器，那么也可以实现和TimerMixin同样的效果。例如： 1234567891011121314151617import React,&#123; Component&#125; from &apos;react&apos;;export default class Hello extends Component &#123; componentDidMount() &#123; this.timer = setTimeout( () =&gt; &#123; console.log(&apos;把一个定时器的引用挂在this上&apos;); &#125;, 500 ); &#125; componentWillUnmount() &#123; // 如果存在this.timer，则使用clearTimeout清空。 // 如果你使用多个timer，那么用多个变量，或者用个数组来保存引用，然后逐个clear this.timer &amp;&amp; clearTimeout(this.timer); &#125;&#125;; 我今天看了我们项目的代码，发现几乎没有人做保护，代码copy的现象，真的是令人发指，可能很多人都没仔细看过官方的文档。。。 RN0.43 Text组件bug最近公司升级了RN的版本，从0.39升级到了0.43，这里出现了一个比较严重的bug。github上的issue地址：https://github.com/facebook/react-native/issues/13080 具体来说，就是android上面的Text，string和int等数值混排会出现莫名的bug，无论Text是否加了点击事件，只要触摸int等数值的展示部分，就会崩溃，具体代码如下： 12345let num = 5;&lt;Text&gt;有&#123;num&#125;个赞&lt;/Text&gt; //点击crash``` 如何补救呢？使用`.toString`: let num = 5; 有{num.toString()}个赞 //ok12345678看github上的记录，0.44已经修复，但是如果使用0.43的同学，千万要小心。更新于 2017-05-10## 字符串作为判断条件 崩溃bug类似这样： let test = {string: ‘’};return ( {test &amp;&amp; test.string &amp;&amp; {test.string} } )12报错： Error: RawText “” must be wrapped in an explicit component.1234原因未知，但是会崩溃保护措施： let test = {string: ‘’};return ( {test &amp;&amp; !!test.string &amp;&amp; {test.string} } )``` 具体的可以看下这篇文章：Error RawText ** must be wrapped in an explicit component 问题解决]]></content>
      <categories>
        <category>React-Native</category>
      </categories>
      <tags>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何给同一个电脑上的不同git项目设置不同的name和email]]></title>
    <url>%2F2017%2F04%2F11%2FsettingNameAndEmailForEachProject%2F</url>
    <content type="text"><![CDATA[最近在自己的电脑上同时使用github和公司的git仓库，带来了一个问题就是之前只是设置了全局的name和email，但是两边的代码需要使用不同的user，每次都要手动去改，然后我搜索了下，发现其实我们可以给每个git项目，单独配置一个name和email的。规则如下： 如果项目由独立配置，则使用独立配置，如果没有独立配置，则使用全局配置 命令就很简单了：全局name和email配置： 12$ git config --global user.name gitaccount$ git config --global user.email gitaccount@example.com 给单独的git项目设定配置： 123$ cd gitFolder$ git config user.name gitaccount$ git config user.email gitaccount@example.com 这样，如果本地有多个git user 或者多个项目的话，使用起来就比较方便了。]]></content>
      <categories>
        <category>小知识</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React_Native拆分bundle之patch拆包]]></title>
    <url>%2F2017%2F04%2F06%2FReact-Native-Seperate-Bundle%2F</url>
    <content type="text"><![CDATA[为什么要拆包背景介绍随着RN的包越来越大，第一次载入RN包的时长越来越长，用户需要等待的时间也就越长，体验较差。另外多个团队开发的话，互相之间的依赖也是个大问题，出现编译不过的话，就会出现水桶效应，所有的团队都要等待这个有问题的团队，从而拉低了整体的效率。 另外我一直希望，能够将React-Native的业务功能，做成类似小程序一样：即用即载入，随时可以更新。想想我们的app里面包含了多少个用户也许永远用不到的功能，还有当我们希望上一个新功能的时候，一定要等待新的版本的审核，这给运营等带来了巨大的麻烦和风险。如果用户点击某个功能，然后马上载入线上的webBundle，用户之后就可以直接使用我们的最新功能了，以后再次进入的时候，也无需等待，那该多好。 拆包目标所以我们拆包的目标就很明确了： 1. 优化载入时间，提高用户体验 2. 解开依赖关系，提高开发效率 3. 实现webBundle，即用即载入 示意图如下： 国外国内app拆包情况上面啰嗦了为什么想要去拆包，好像是蛮有必要的O_o。但是当我去看国内外著名的app使用React-Native的情况时，发现真的是泾渭分明：国内基本都拆包了，包括携程、QQ音乐等，而国外没有拆包的，比如React-Native的创造者FaceBook，虽然他们的包大小已经到了10M。 不禁让我很疑惑，难道国外没有这个需求么？为什么拆包和热更新等几乎国内的硬需求，他们却好像完全没有这方面的需求。希望有读者知道的话可以告知我~ 拆包的几种方案在讲具体的方案之前，我们先看下，React-Native的包，究竟是如何打出来，然后是怎么载入到native中的。 如何打包这里我直接使用QQ技术团队的一张图： 如何载入这里主要讲下iOS React-Native0.39版本的情况。RN提供了两种形式来载入： 12341. - (NSURL *)sourceURLForBridge:(RCTBridge *)bridge2. - (void)loadSourceForBridge:(RCTBridge *)bridge onProgress:(RCTSourceLoadProgressBlock)onProgress onComplete:(RCTSourceLoadBlock)loadCallback; 第一种数据是默认模式，第二种是可以控制载入中的各个步骤。这块可以看下RCTBridgeDelegate。 主流方案在网上查了相关的资料，主流的方案基本都是把Main.jsbundl拆分成基础包common.jsbundle+业务包bundle，和上面拆包目标基本一样，不赘述。 具体的拆分思路就很不一样了： 1. 侵入RN代码，修改打包流程，使得打出来的包就是基础+业务包，如QQ音乐 2. 在RN打包的基础上，实现新的打包方案，如携程 moles-Packer 3. Patch方案，打包流程不变，生成基础包后，根据diff来生成每个业务不同的patch包 patch方案因为方案1和方案要随着RN的升级，不断调整，成本比较高，而且要投入较多的人力，所以我们先看下方案3。 先说下patch，patch就是根据特定算法，讲两个不同的事物diff比较，然后生成的包含两个事物差别的包。我们这里使用的是google的diffAndPatch算法。 基础包common.jsbundle首先我们先生成基础包common.jsbundle.这里我们写一个空的js文件，只包含react-native头文件common.ios.js： 12import React from &apos;react&apos;; import &#123;&#125; from &apos;react-native&apos;; 然后我们基于这单个文件打包，打出来的包就是只包含react-native基础框架的bundle，我们成为common.jsbundle. 注： RN打包过程中会做混淆，所有的类最终都变成了代号为数字的function，所以这里顺序就非常重要，而对基础包的引用顺序就要严格和common.ios.js一样了，这里建议所有的业务代码直接引用common.ios.js文件。另外如果有公共组件等，也都可以放到common.ios.js文件中，这样就会被包含在基础包中了。 业务包 business.patch每条业务线的代码，都需要单独维护自己的indexBisiness.js,打包的时候，入口文件就是这个index，这样就打出来了一个业务business.bundle。然后使用diff，计算出业务patch。这样就算出了patch，我们叫做business.patch native方案现在我们已经有了common.jsbundle + bisiness1.patch + business2.patch + …如果打开了bisiness1中的home.js，我们首先要将common.jsbundle和bisiness1.patch使用算法合并，计算出最终bisiness1.jsbundle.然后通过上面讲到的native载入方案载入具体的bundle。 根据当前的bridgeName生成bisiness bundle 123456789101112131415161718192021222324252627282930- (NSString *)getNewBundle&#123; NSString *commonBundlePath = [[NSBundle mainBundle] pathForResource:@&quot;common&quot; ofType:@&quot;jsbundle&quot;]; NSString *commonBundleJSCode = [[NSString alloc] initWithContentsOfFile:commonBundlePath encoding:NSUTF8StringEncoding error:nil]; NSString *patch1Path = [[NSBundle mainBundle] pathForResource:self.bridgeName ofType:@&quot;patch&quot;]; NSString *patch1JSCode = [[NSString alloc] initWithContentsOfFile:patch1Path encoding:NSUTF8StringEncoding error:nil]; DiffMatchPatch *diffMatchPatch = [[DiffMatchPatch alloc] init]; NSArray *convertedPatches = [diffMatchPatch patch_fromText:patch1JSCode error:nil]; NSArray *resultsArray = [diffMatchPatch patch_apply:convertedPatches toString:commonBundleJSCode]; NSString *resultJSCode = resultsArray[0]; //patch合并后的js NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *docDir = [paths objectAtIndex:0]; NSString *newPath = [NSString stringWithFormat:@&quot;%@/%@.jsbundle&quot;,docDir,self.bridgeName]; if (resultsArray.count &gt; 1) &#123; [resultJSCode writeToFile:newPath atomically:NO encoding:NSUTF8StringEncoding error:nil]; return newPath; &#125; else &#123; return @&quot;&quot;; &#125; &#125; 加载bisiness bundle： 1234567- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge&#123; NSString *path = [[NSBundle mainBundle] pathForResource:self.bridgeName ofType:@&quot;jsbundle&quot;]; NSURL *jsBundleURL = [NSURL URLWithString:path]; return jsBundleURL;&#125; 这样，code就基本完成了。如果想看所有的代码，请看底部的githubDemo 方案优缺点优点： 1. 技术方案简单，实现快 2. 稳定、不用担心RN升级问题 3. 业务互相独立 4. 方便后面做web bundle 缺点： 1. 内存占用大 2. 打包会变大 3. 业务之间资源和代码没法互相引用 优化和拓展计划1. 打包可以不用patch的方案，采用脚本逐行写入 2.web bundle 可以直接基于这个方案做 3.如果解决了函数命名和依赖的问题，就可以采用一个bundle策略 Demo in githubReactNativeSeperateBundle cd ReactNativeSeperateBundle npm install run project]]></content>
      <categories>
        <category>React-Native</category>
      </categories>
      <tags>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 响应链 Responder Chain]]></title>
    <url>%2F2017%2F03%2F29%2FResponder-chain%2F</url>
    <content type="text"><![CDATA[EventiOS设备和用户的交互其实有很多种方式，包括触摸屏幕，摇晃设备，多媒体控制（音量等）等。当设备检测到这三种事件中的一种的时候，iOS就会捕获当前事件的时间和内容，然后发出消息，通知App发生了事件，这个就是Event。 Responder有了Event之后，系统需要找到能够处理这个event的对象，而能够处理event的对象，就是UIResponder.我们常用的UIApplication、UIView、UIViewController，其实都是UIResponder的实例。UIResponder为了要处理特定的事件，要实现corresponding方法。比如touch事件，那么Responder就要实现touchesBegan：withEvent,touchedMoved:withEvent:等方法。 Responder Chain如果有当前的界面有多个Responder的时候，到底是谁来响应呢？这里其实是根据特定的一个顺序，依次寻找响应的对象，这个就叫响应链（Responder Chain）机制了。在Responder Chain中，系统首先UIkit会按照一定的规则（下节会讲到）来找到当前的first responder，通常是事件发生的view，我们叫做initial view,然后根据这个view是否有处理的能力（比如touch事件就是看是否实现了上述的touchesBegan：withEvent等方法），如果当前的responder无法处理该事件，那么会响应链的顺序来查找下个响应者，通常的顺序是： view -&gt; super view -&gt; viewController -&gt; window -&gt; UIApplicaiton，如下图： 如果到了响应链的最后一个节点，还是没有找到响应者，那么系统就会抛弃这条event。 Hit-Test View，Hit-Testing那么系统是如何找到first responder的呢？答：使用Hit-Testing。当触摸事件发生时，iOS会使用Hit-Testing超找当前事件所在的view，它会从UIApplication开始，依次往下寻找事件发生的view，直到找到这个view，顺序和上述的响应链，其实是相反的，我怀疑可能响应链就是在Hit-Testing的过程中建立的，但是没有查到相关的资料。 我们看个苹果的官方列子： 如果触摸事件发生在D中，那么系统会依次检查： 触摸区域在A中，遍历它的所有subViews 触摸区域在C中，遍历它的所有subViews 触摸事件在D中 D就是所谓的Hit-Test View，也是上述的响应链中的first responder 参考文档 EventHandlingiPhoneOS 官方文档忽然实效了 Responder object iOS Events and Responder Chain iOS中的响应链（The Responder Chain）]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apple文档翻译之Event-Handing-Guide-for-iOS]]></title>
    <url>%2F2017%2F03%2F27%2FEvent-Handing-Guide-for-iOS%2F</url>
    <content type="text"><![CDATA[About Events in iOS用户会使用很多的方式来操作他们的iOS设备，比如点击屏幕或者摇晃屏幕。当用户正在操作硬件或者向App传递信息时，iOS会获取时间和方式。你的App给用户的反馈越自然、越直接，用户就会越有兴趣。 AT a GlanceEvent是当用户有动作时，（UIKit）向App发出的通知。在iOS中，有很多形式的event：多点触摸，滑动、多媒体控制。最后一个事件被熟知为远程控制事件，因为它可以从一个附件中发出。 UIKit让你的App处理手势更轻松iOS应用可以识别组合的触摸，然后直接以特定方式反馈，比如收缩的触摸会缩小内容，间隔触摸划过内容等。实际上，很多的手势太常见了，所以他们被内置在UIKit中。比如UIControl子类，比如UIButton和UISlider，回应特殊的手势-button的点击和slider的拖动。当你配置这些control，他们会在触摸发生时，发出一个message给目标。你也可以通过使用gesture recognizers在view上实现这个目标动作。当你给一个view添加一个getsture recognizer，这个view会像一个control一样给你指定的触摸回应。 Gesture recognizer提供了一个高度抽象的复杂事件处理逻辑。当使用触摸事件时，请优选gesture recognizer，因为它们很强大，可复用，适用性强。你也可以使用内置的getsure recognizer然后个性化它的行为。或者你可以创造一个新的gesture recognizer来识别一个新的触摸事件。 相关章节：Gesture Recognizers 一个事件为了找到处理它的对象，要遍历一个特定的路径当iOS recognizer是事件时，它首先会将事件传递给初始的看起来最相关的对象，比如touch发生的view。如果初始的对象不能处理事件，iOS会继续传递事件给更大范围的对象，直接它找到了一个对象有足够的上下文处理这个事件。这些对象的序列，就是被熟知的响应链（responder chain），iOS会顺着响应链传递事件，同时它也传递回应事件的责任。这种设计模式让事件处理更加动态和合作性高。 相关章节 响应链 Responder Chain UIEvent封装了触摸，摇晃，远程控制事件许多UIEvent是UIKit UIEvent的实例。一个UIEvent包括了关于事件app需要使用的信息，以决定如何回应这个事件。比如当一个用户事件发生时，手指触摸屏幕或者滑动它的表面，iOS持续的发送event对象给app。每个event对象都有一个type-触摸、摇晃、远程控制来作为它的子类型。 相关章节： 多点触摸、手势、远程控制 当用户触摸界面时，App接收多点触摸事件在你的App上，UIKit controls和gesture recognizers 也行足够你来应对触摸事件了。甚至你可以使用Gesture recognizer来定制你的view。根据经验，你会使用触摸事件当你的app回应和view本身绑定的事件，比如摸出画东西。在这些列子中，你只负责低优先级的触摸事件，事件touch method，在method中，你分析未经加工的触摸事件，然后适当回应。 相关章节 多点触摸 multitouch Event 当用户移动设备时，App接收到移动事件（Motion Event）Motion事件提供了关于设备的地点、方向和移动的信息。通过回应Motion事件，你可以提供微量却强大的功能。加速器和陀螺仪数据能让你判断是倾斜、旋转，还是摇晃。 Motion事件有许多形式，你可以通过不同的framework来处理他们。当用户摇晃设备时，UIKit传递UIEvent对象给app。如果你想要app能接收高速、持续的加速器和陀螺仪数据，请使用Core Motion framework。 相关章节 Motion Event 当用户操作多媒体控制，用户收到远程控制事件iOS controls 和外部附件可以给app发送远程控制事件。这些事件允许用户去控制音频和视频，比如通过耳机调整音量。 相关章节： Remote Control Event]]></content>
      <categories>
        <category>文档翻译</category>
      </categories>
      <tags>
        <tag>Apple文档</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apple文档翻译之UIResponder]]></title>
    <url>%2F2017%2F03%2F21%2FUIResponder%2F</url>
    <content type="text"><![CDATA[UIResponder是回应和处理事件的抽象接口,UIResponder的实例，包括：UIApplication、UIViewController、UIView（包含UIWindow），组成了UIKit处理事件的核心。当事件发生时，UIKit会把事件派发给UIResponder去处理。 有许多种事件，包括触摸、手势、遥控和点击事件。为了处理特定的事件，一个responder（响应）必须重写corresponding方法。比如，要想处理touch事件，一个responder要实现touchesBegan：withEvent,touchedMoved:withEvent:等方法。在触摸事件的列子中，responder使用UIKit提供的事件信息来追踪触摸的改变，然后适时地更新界面。 除了处理事件，UIKit responder还负责转发那边没有被处理的事件给app的其他部分。如果一个指定的responder没有处理事件，它就会转发这个事件到响应链的下一个responder。UIKit动态地管理响应链，使用预定的规则来决定下一个收到事件的对象。比如：一个view转发事件到它的superView，或者Rootview转发事件给它的view controller。 Responder处理UIEvent和其他通过输入界面的自定义输入，最典型的就是系统的键盘。当用户点击UITextField和UITextView，这个view变成了第一个responder，然后展示它的输入界面：键盘。同样的，你可以创造一个自定义的输入界面，然后在其他responders活跃的时候展示它。为了把输入界面和responder联系在一起，要把view赋值给responder的属性。 原文链接 UIResponder 如果有任何建议和优化的地方，欢迎给我留言。]]></content>
      <categories>
        <category>文档翻译</category>
      </categories>
      <tags>
        <tag>Apple文档</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github pages + hexo 原理探究]]></title>
    <url>%2F2017%2F03%2F18%2FgithubPagesStudy%2F</url>
    <content type="text"><![CDATA[缘起利用一个下午搭建起了github pages + hexo 的静态博客，试用了下效果，还是挺满意的，至少比csdn的页面好看多了，哈哈。搭建的过程中，也遇到了很多的问题，尤其是中间如何把hexo 和github连在一起，又是如何更新博客这块，有很多疑问，我自己尝试，还不小心把本地的hexo的文件删除了，不得不重新init了一个，配置都要重新来一遍，所以这篇文章着重探讨，github pages的流程到底是如何展开的。 简单介绍先说下github pages,github pages 是github提供给用户用来展示个人或者项目主页的静态网页系统。每个用户都可以使用自己的github项目创建，上传静态页面的html文件，github会帮你自动更新你的页面。 hexo是一个用来生成静态界面的框架，使用hexo，你就可以直接使用mark down 来写文章，而不用关心前端样式的展现。 数据流我们来看下流程图： 这样看就很简单了，我们本地使用markDown语法写好文件，然后执行hexo或者其他静态网页生成工具，生成好静态文件，然后使用hexo等工具的发布功能，就会使用ssh来更新github项目的文件，即生成一个新的commit然后push。github检测到这个项目更新，就会更新你的网站的内容（会有缓存）。]]></content>
      <categories>
        <category>闲来研究</category>
      </categories>
  </entry>
</search>
